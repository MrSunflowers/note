# Redis

## Redis 的数据类型

以下是 Redis 支持的主要数据类型：

1. **字符串（String）**：
   - 最基本的数据类型。
   - 可以包含任何数据，比如JPEG图像或序列化的Ruby对象。
   - 字符串值最大可以是512MB。

2. **哈希（Hash）**：
   - 键值对的集合。
   - 适合存储对象。
   - 例如，可以存储用户信息，其中键是字段名，值是字段值。

3. **列表（List）**：
   - 字符串列表，按插入顺序排序。
   - 可以添加、移除元素。
   - 支持列表操作，如从两端弹出元素、获取子列表等。

4. **集合（Set）**：
   - 不重复的字符串集合。
   - 支持集合操作，如并集、交集、差集等。
   - 可以用于实现如标签系统、推荐系统等。

5. **有序集合（Sorted Set 也叫 ZSet）**：
   - 类似于集合，但每个元素都会关联一个浮点数分数。
   - 元素按分数排序，但也可以按字典顺序排序。
   - 适用于排行榜、优先级队列等场景。

其他高级数据类型：

1. **位图（Bitmap）**：
   - 字符串数据类型的一种扩展，可以对字符串的位进行操作。
   - 适合实现简单的状态存储，如用户签到、活跃状态等。

2. **超日志（HyperLogLog）**：
   - 用于估计集合中元素数量的概率数据结构。
   - 非常节省内存，但不精确。

3. **地理空间索引（Geo）**：
   - 用于存储地理位置信息，并对这些信息进行操作。
   - 支持计算两个位置之间的距离、查询某个范围内的位置等。

4. **流（Streams）**：
   - 用于实现消息队列的数据类型。
   - 提供了持久化消息队列的功能，支持多个消费者和消息分组。

## 常用命令

**字符串（String）**
- `SET key value`：设置指定 key 的值
- `GET key`：获取指定 key 的值
- `DEL key`：删除指定 key
- `INCR key`：将 key 中存储的数字值增一
- `DECR key`：将 key 中存储的数字值减一
- `INCRBY key increment`：将 key 所储存的值加上给定的增量
- `DECRBY key decrement`：将 key 所储存的值减去给定的减量

**哈希（Hash）**
- `HSET key field value`：将哈希表 key 中的字段 field 的值设为 value
- `HGET key field`：获取存储在哈希表中指定字段的值
- `HDEL key field [field ...]`：删除一个或多个哈希表字段
- `HGETALL key`：获取在哈希表中指定 key 的所有字段和值
- `HINCRBY key field increment`：为哈希表 key 中的指定字段的整数值加上增量 increment

**列表（List）**
- `LPUSH key value [value ...]`：将一个或多个值插入到列表头部
- `RPUSH key value [value ...]`：将一个或多个值插入到列表尾部
- `LRANGE key start stop`：获取列表指定范围内的元素
- `LPOP key`：移除并获取列表的第一个元素
- `RPOP key`：移除并获取列表的最后一个元素
- `LLEN key`：获取列表长度

**集合（Set）**
- `SADD key member [member ...]`：向集合添加一个或多个成员
- `SMEMBERS key`：获取集合中的所有成员
- `SREM key member [member ...]`：移除集合中一个或多个成员
- `SISMEMBER key member`：判断 member 元素是否是集合 key 的成员
- `SCARD key`：获取集合的成员数

**有序集合（Sorted Set）**
- `ZADD key score member [score member ...]`：向有序集合添加一个或多个成员
- `ZRANGE key start stop [WITHSCORES]`：通过索引区间返回有序集合成指定区间内的成员
- `ZREM key member [member ...]`：移除有序集合中的一个或多个成员
- `ZSCORE key member`：获取有序集合中成员的分数值
- `ZCARD key`：获取有序集合的成员数

**位图（Bitmap）**
- `SETBIT key offset value`：对 key 所储存的字符串值，设置或清除指定偏移量上的位
- `GETBIT key offset`：对 key 所储存的字符串值，获取指定偏移量上的位
- `BITOP operation destkey key [key ...]`：对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上

**超日志（HyperLogLog）**
- `PFADD key element [element ...]`：添加指定元素到 HyperLogLog 中
- `PFCOUNT key [key ...]`：返回给定 HyperLogLog 的基数估算值
- `PFMERGE destkey sourcekey [sourcekey ...]`：将多个 HyperLogLog 合并为一个 HyperLogLog

**地理空间索引（Geo）**
- `GEOADD key longitude latitude member [longitude latitude member ...]`：将指定的地理空间位置（经度和纬度）添加到指定的 key 中
- `GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]`：根据给定的经纬度坐标来获取指定范围内的地理位置集合
- `GEOPOS key member [member ...]`：从给定的 key 里返回所有指定 member 的位置（经度和纬度）

**流（Streams）**
- `XADD key ID field value [field value ...]`：向流追加数据
- `XLEN key`：获取流的长度
- `XRANGE key start end [COUNT count]`：获取流中指定范围的元素
- `XREVRANGE key end start [COUNT count]`：获取流中指定范围的元素，但顺序是反的
- `XDEL key ID [ID ...]`：删除流中的指定元素

## 跳表

## Redis 工作模式

(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制

## 一个字符串类型的值能存储最大容量是多少

## Redis 的持久化机制

## 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题

## 布隆过滤器

## redis的过期策略以及内存淘汰机制

redis一般采用的是定期删除+惰性删除策略。

采用定期删除+惰性删除存在的问题

## 内存淘汰策略

应用 解决定期删除+惰性删除存在的问题

## 分布式锁的实现

## 为什么Redis的操作是原子性的，怎么保证原子性的？

## Redis事务

## Redis 的同步机制

## Jedis 与 Redisson 对比有什么优缺点

## 说说 Redis 哈希槽的概念

## Redis 集群的主从复制模型是怎样的

## Redis 集群会有写操作丢失吗？为什么？

## Redis 集群最大节点个数是多少

## Redis key 的过期时间和永久有效分别怎么设置

## Redis 如何做内存优化

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一
个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的
所有信息存储到一张散列表里面.

## Redis 回收进程如何工作的

## 使用过 Redis 做异步队列么，你是怎么用的

## 一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素

## 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来

## keys 指令的问题

## redis 缓存击穿处理方案

分布式锁，保证一次只能有一个请求访问数据库，并更新缓存，其他请求只能等待该请求完成响应后，直接访问缓存数据。

[(37条消息) redis缓存数据更新问题 - CSDN](https://www.csdn.net/tags/Mtzakg5sMDAzNjgtYmxvZwO0O0OO0O0O.html)

[(37条消息) REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案_有啥不一样的博客-CSDN博客_redis缓存击穿怎么解决](https://blog.csdn.net/soulweee/article/details/119179214)

## 高并发 redis 和数据库双写情况下，如何保证数据的一致性

通过MQ消息队列，更新数据库后使用消息队列更新缓存

## 如何解决由于redis主从节点不同步导致的分布式锁失效问题

使用 zookeeper ，红锁会引入更多得不偿失的问题，比如多次io操作，加锁失败处理，加锁过程中节点的原子性等

## Redis 常见性能问题和解决方案

(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3...

## 集群方案

### Redis 集群方案什么情况下会导致整个集群不可用？

## Pipeline 有什么好处，为什么要用 pipeline？

可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发
现影响 redis 的 QPS峰值的一个重要因素是 pipeline 批次指令的数目。
