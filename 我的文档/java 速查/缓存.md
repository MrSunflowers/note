# Redis


## Redis 的数据类型

以下是 Redis 支持的主要数据类型：

1. **字符串（String）**：
   - 最基本的数据类型。
   - 可以包含任何数据，比如JPEG图像或序列化的Ruby对象。
   - 字符串值最大可以是512MB。

2. **哈希（Hash）**：
   - 键值对的集合。
   - 适合存储对象。
   - 例如，可以存储用户信息，其中键是字段名，值是字段值。

3. **列表（List）**：
   - 字符串列表，按插入顺序排序。
   - 可以添加、移除元素。
   - 支持列表操作，如从两端弹出元素、获取子列表等。

4. **集合（Set）**：
   - 不重复的字符串集合。
   - 支持集合操作，如并集、交集、差集等。
   - 可以用于实现如标签系统、推荐系统等。

5. **有序集合（Sorted Set 也叫 ZSet）**：
   - 类似于集合，但每个元素都会关联一个浮点数分数。
   - 元素按分数排序，但也可以按字典顺序排序。
   - 适用于排行榜、优先级队列等场景。

其他高级数据类型：

1. **位图（Bitmap）**：
   - 字符串数据类型的一种扩展，可以对字符串的位进行操作。
   - 适合实现简单的状态存储，如用户签到、活跃状态等。

2. **超日志（HyperLogLog）**：
   - 用于估计集合中元素数量的概率数据结构。
   - 非常节省内存，但不精确。

3. **地理空间索引（Geo）**：
   - 用于存储地理位置信息，并对这些信息进行操作。
   - 支持计算两个位置之间的距离、查询某个范围内的位置等。

4. **流（Streams）**：
   - 用于实现消息队列的数据类型。
   - 提供了持久化消息队列的功能，支持多个消费者和消息分组。


## 常用命令

**字符串（String）**
- `SET key value`：设置指定 key 的值
- `GET key`：获取指定 key 的值
- `DEL key`：删除指定 key
- `INCR key`：将 key 中存储的数字值增一
- `DECR key`：将 key 中存储的数字值减一
- `INCRBY key increment`：将 key 所储存的值加上给定的增量
- `DECRBY key decrement`：将 key 所储存的值减去给定的减量

**哈希（Hash）**
- `HSET key field value`：将哈希表 key 中的字段 field 的值设为 value
- `HGET key field`：获取存储在哈希表中指定字段的值
- `HDEL key field [field ...]`：删除一个或多个哈希表字段
- `HGETALL key`：获取在哈希表中指定 key 的所有字段和值
- `HINCRBY key field increment`：为哈希表 key 中的指定字段的整数值加上增量 increment

**列表（List）**
- `LPUSH key value [value ...]`：将一个或多个值插入到列表头部
- `RPUSH key value [value ...]`：将一个或多个值插入到列表尾部
- `LRANGE key start stop`：获取列表指定范围内的元素
- `LPOP key`：移除并获取列表的第一个元素
- `RPOP key`：移除并获取列表的最后一个元素
- `LLEN key`：获取列表长度

**集合（Set）**
- `SADD key member [member ...]`：向集合添加一个或多个成员
- `SMEMBERS key`：获取集合中的所有成员
- `SREM key member [member ...]`：移除集合中一个或多个成员
- `SISMEMBER key member`：判断 member 元素是否是集合 key 的成员
- `SCARD key`：获取集合的成员数

**有序集合（Sorted Set）**
- `ZADD key score member [score member ...]`：向有序集合添加一个或多个成员
- `ZRANGE key start stop [WITHSCORES]`：通过索引区间返回有序集合成指定区间内的成员
- `ZREM key member [member ...]`：移除有序集合中的一个或多个成员
- `ZSCORE key member`：获取有序集合中成员的分数值
- `ZCARD key`：获取有序集合的成员数

**位图（Bitmap）**
- `SETBIT key offset value`：对 key 所储存的字符串值，设置或清除指定偏移量上的位
- `GETBIT key offset`：对 key 所储存的字符串值，获取指定偏移量上的位
- `BITOP operation destkey key [key ...]`：对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上

**超日志（HyperLogLog）**
- `PFADD key element [element ...]`：添加指定元素到 HyperLogLog 中
- `PFCOUNT key [key ...]`：返回给定 HyperLogLog 的基数估算值
- `PFMERGE destkey sourcekey [sourcekey ...]`：将多个 HyperLogLog 合并为一个 HyperLogLog

**地理空间索引（Geo）**
- `GEOADD key longitude latitude member [longitude latitude member ...]`：将指定的地理空间位置（经度和纬度）添加到指定的 key 中
- `GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]`：根据给定的经纬度坐标来获取指定范围内的地理位置集合
- `GEOPOS key member [member ...]`：从给定的 key 里返回所有指定 member 的位置（经度和纬度）

**流（Streams）**
- `XADD key ID field value [field value ...]`：向流追加数据
- `XLEN key`：获取流的长度
- `XRANGE key start end [COUNT count]`：获取流中指定范围的元素
- `XREVRANGE key end start [COUNT count]`：获取流中指定范围的元素，但顺序是反的
- `XDEL key ID [ID ...]`：删除流中的指定元素


## 设置已存在的 key 的过期时间

在Redis中，`EXPIRE`命令和`PERSIST`命令分别用于设置和取消设置键（key）的过期时间。以下是这两个命令的详细说明和使用示例：


### EXPIRE命令

`EXPIRE`命令用于设置键的过期时间，单位是秒。一旦键过期，它将自动从Redis中删除。

**语法**:
```
EXPIRE key seconds
```

**参数说明**:
- `key`: 要设置过期时间的键。
- `seconds`: 键的过期时间，单位为秒。

**示例**:
假设我们有一个键`user:1`，我们希望它在60秒后过期。

```
EXPIRE user:1 60
```

这表示`user:1`键将在60秒后自动过期并被删除。

### PERSIST命令

`PERSIST`命令用于移除键的过期时间，使键永久有效。

**语法**:
```
PERSIST key
```

**参数说明**:
- `key`: 要移除过期时间的键。

**示例**:
假设我们之前设置了`user:1`键的过期时间为60秒，现在我们希望它永久有效。

```
PERSIST user:1
```

执行这个命令后，`user:1`键的过期时间将被移除，它将永久保存在Redis中，除非显式地删除它。

注意事项

- 如果键不存在，`EXPIRE`命令将返回0，表示键不会过期。
- 如果键已经设置了过期时间，再次使用`EXPIRE`命令将更新其过期时间。
- 使用`PERSIST`命令移除过期时间后，键将不再受过期时间的限制。


## 一个 Redis 实例最多能存放多少的 keys？

在理论上，Redis可以处理多达2^32个keys，因为Redis使用32位无符号整数来表示key的ID。在实际中，Redis的性能和存储能力主要受限于服务器的内存大小。

每个Redis实例至少可以存放2亿5千万个keys。这个数字是通过实际测试得出的，它展示了Redis在处理大量数据时的性能和能力。


### List、Set、Sorted Set他们最多能存放多少元素？

对于List、Set和Sorted Set这些数据结构，每个实例同样可以存放多达2^32个元素。这意味着Redis的存储极限实际上是由系统中的可用内存决定的。只要服务器的内存足够，Redis就可以存储大量的数据。


## 跳表

一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但 redis 中的 ZSet 的 skiplist 却比较特殊，它没法归属到这两大类里面。

参考 Redis 为什么用跳表而不用平衡树 https://juejin.cn/post/6844903446475177998


## 场景实现类

### 队列

一般使用 list 结构作为队列，rpush 入队，lpop 出队

### 消息队列

1. 可以使用 list 结构作为队列，rpush 生产消息，lpop 消费消息，当 lpop 没有消息的时候，可以使用 blpop 在没有消息的时候，它会阻塞住，直到消息到来，也可以设置阻塞时间
2. 使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。但是在消费者下线的情况下，生产的消息会丢失，解决这样的问题得使用专业的消息队列，如RabbitMQ等。

### 延时队列：

使用 sorted set，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangbyscore 指令获取N秒之前的数据轮询进行处理。

以下是使用Sorted Set实现延时队列的基本步骤：

1. **生产消息**：
   使用`ZADD`命令将消息添加到Sorted Set中。消息的score（分数）是消息预定的执行时间的时间戳，而消息内容作为key。这样，消息就会根据预定时间自动排序。

   示例：
   ```shell
   ZADD delay_queue 1617332800 "message content"
   ```
   这里`delay_queue`是Sorted Set的名称，`1617332800`是消息预定执行的时间戳（例如，2021年4月1日 00:00:00 UTC），`"message content"`是消息内容。

2. **消费消息**：
   消费者使用`ZRANGEBYSCORE`命令来获取在特定时间之前到期的消息。消费者可以定期轮询Sorted Set，获取已经到达预定时间的消息。

   示例：
   ```shell
   ZRANGEBYSCORE delay_queue -inf 1617332800
   ```
   这个命令会返回所有在时间戳`1617332800`之前到期的消息。

3. **处理消息**：
   消费者获取到消息后，可以进行相应的处理。处理完成后，消费者需要从Sorted Set中移除已处理的消息。

   示例：
   ```shell
   ZREM delay_queue "message content"
   ```
   这个命令会从`delay_queue`中移除消息内容为`"message content"`的消息。

使用Sorted Set实现延时队列的优点是简单且高效，消息会根据预定时间自动排序，消费者可以轻松地获取到需要处理的消息。然而，需要注意的是，随着消息数量的增加，`ZRANGEBYSCORE`命令的性能可能会受到影响，因此在处理大量消息时，可能需要考虑使用更高效的消息处理策略，比如使用Redis的Stream数据结构。

此外，使用Sorted Set实现延时队列时，需要确保Redis服务器的时间设置是准确的，因为消息的预定时间是基于服务器的时间戳的。如果服务器时间不准确，可能会导致消息处理的延迟或提前。

### 排行榜/计数器

在Redis中，排行榜和计数器可以通过不同的数据结构来实现。以下是两种常见的实现方式：

1. 使用Sorted Set实现排行榜

Redis的Sorted Set（有序集合）非常适合用来实现排行榜，因为它可以存储带有分数的元素，并且可以快速地根据分数进行排序。

排行榜操作：

- **添加或更新分数**：使用`ZADD`命令可以添加新的元素到排行榜，或者更新已存在的元素的分数。
  
  示例：
  ```shell
  ZADD leaderboard 100 "user1"
  ZADD leaderboard 150 "user2"
  ```

- **获取排行榜**：使用`ZRANGE`或`ZREVRANGE`命令可以获取排行榜的元素列表，`ZREVRANGE`命令会根据分数从高到低排序。
  
  示例：
  ```shell
  ZRANGE leaderboard 0 -1 WITHSCORES
  ```

- **获取特定范围的元素**：可以使用`ZRANGEBYSCORE`命令获取特定分数范围内的元素。
  
  示例：
  ```shell
  ZRANGEBYSCORE leaderboard 100 150 WITHSCORES
  ```

- **获取元素排名**：使用`ZREVRANK`命令可以获取元素在排行榜中的排名。
  
  示例：
  ```shell
  ZREVRANK leaderboard "user1"
  ```

- **删除元素**：使用`ZREM`命令可以删除排行榜中的元素。
  
  示例：
  ```shell
  ZREM leaderboard "user1"
  ```

2. 使用String实现计数器

Redis的String数据类型可以用来实现计数器，因为String可以存储数字，并且支持原子性的自增和自减操作。

计数器操作：

- **增加计数**：使用`INCRBY`命令可以增加计数器的值。
  
  示例：
  ```shell
  INCRBY counter 1
  ```

- **减少计数**：使用`DECRBY`命令可以减少计数器的值。
  
  示例：
  ```shell
  DECRBY counter 1
  ```

- **获取计数器的值**：使用`GET`命令可以获取计数器的当前值。
  
  示例：
  ```shell
  GET counter
  ```

使用Redis实现排行榜和计数器时，需要注意的是，由于Redis是内存数据库，数据的持久化需要通过配置RDB快照或AOF日志来实现。此外，对于高并发场景，需要考虑Redis的性能和资源限制，确保操作的原子性和一致性。


### 发布/订阅

Redis的发布/订阅（pub/sub）模式允许客户端订阅一个或多个频道（channel），然后接收发布到这些频道的消息。这种模式非常适合实现消息通知系统、实时通信等场景。

发布/订阅基本操作

1. **订阅频道**：客户端使用`SUBSCRIBE`命令订阅一个或多个频道。

   示例：
   ```shell
   SUBSCRIBE channel1 channel2
   ```

   这个命令会订阅`channel1`和`channel2`两个频道。

2. **发布消息**：客户端使用`PUBLISH`命令向指定的频道发送消息。

   示例：
   ```shell
   PUBLISH channel1 "Hello, World!"
   ```

   这个命令会向`channel1`频道发送消息`"Hello, World!"`。

3. **接收消息**：订阅了频道的客户端会接收到发布到该频道的所有消息。

   当客户端订阅频道后，它会进入等待状态，接收并处理来自Redis服务器的消息。

发布/订阅的使用场景

- **实时消息通知**：例如，一个聊天应用可以使用发布/订阅模式来通知用户收到新消息。
- **事件驱动系统**：例如，一个系统可以发布事件到特定频道，其他订阅了该频道的系统可以监听这些事件并作出响应。
- **分布式系统通信**：在分布式系统中，不同的服务可以通过发布/订阅模式进行通信。

发布/订阅的限制

- **持久性**：Redis的发布/订阅模式不保证消息的持久性。如果订阅者在消息发布时没有连接到Redis服务器，那么它将无法接收到该消息。
- **消息丢失**：如果发布者和订阅者之间的连接断开，那么在断开期间发布的消息将会丢失。

示例

假设我们有两个客户端，一个用于发布消息，另一个用于订阅频道并接收消息。

**发布者**：
```shell
PUBLISH channel1 "Hello, World!"
```

**订阅者**：
```shell
SUBSCRIBE channel1
```

当发布者向`channel1`发送消息时，订阅者将接收到该消息。

发布/订阅模式是Redis提供的一个非常强大的功能，它允许客户端之间进行松耦合的通信。然而，由于其非持久性的特性，它通常不适用于需要持久化消息的场景。对于需要持久化消息的场景，可以考虑使用Redis的其他数据结构，如List或Stream。

### 分布式锁

先拿 setnx 来争抢锁，抢到之后再用 expire 给锁加一个过期时间防止锁忘记了释放。如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，这个时候锁会永远得不到释放了，但是 set 指令有个非常复杂的参数是可以同时把 setnx 和 expire 合成一条指令来用的。

这个复杂参数是`SET`命令的扩展参数，它允许在设置键值的同时设置过期时间，从而避免了使用`SETNX`和`EXPIRE`两个命令可能带来的竞态条件问题。这个参数是`SET`命令的`NX`和`EX`选项的组合，即`SETNX`和`EX`的缩写。

SET命令的NX和EX选项

- `NX`（Not eXists）：如果键不存在，则设置键值对；如果键已存在，则不进行任何操作。
- `EX`（EXpire）：设置键的过期时间，单位是秒。

使用SET命令实现分布式锁

使用`SET`命令实现分布式锁的步骤如下：

1. **设置锁**：
    使用`SET`命令的`NX`和`EX`选项来设置锁，并指定一个过期时间。

    ```shell
    SET lock_key unique_lock_value EX 30 NX
    ```

    这个命令尝试设置`lock_key`键，如果键不存在，则设置成功并返回`OK`，同时设置键的过期时间为30秒。如果键已存在，则命令不进行任何操作并返回`nil`。

2. **锁的持有**：
    如果`SET`命令返回`OK`，表示成功获取了锁，此时可以执行需要互斥访问的代码。

3. **释放锁**：
    在代码执行完毕后，需要删除锁键来释放锁。为了防止误删除其他客户端的锁，通常会检查锁的值是否与设置时的值相同。

    ```shell
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    ```

注意事项

- **锁的唯一标识**：在使用`SET`命令时，需要确保`unique_lock_value`是唯一的，以区分不同客户端获取的锁。通常可以使用UUID或客户端ID等唯一值。
- **锁的过期时间**：设置一个合理的过期时间是非常重要的，以防止锁永久不释放的情况发生。
- **锁的释放**：释放锁时，需要确保只有锁的持有者才能释放锁，以防止锁被误释放。

使用`SET`命令的`NX`和`EX`选项可以简化分布式锁的实现，同时避免了使用`SETNX`和`EXPIRE`两个命令可能带来的竞态条件问题。然而，需要注意的是，即使使用了`SET`命令的组合选项，分布式锁的实现仍然需要考虑异常情况下的锁释放问题，以确保系统的健壮性。

示例

```java

/**
 * 查询三级分类（原生版redis分布式锁版本）
	问题1：（删除锁）
	未执行删除锁逻辑，会导致其他线程无法获得锁，出现死锁
问题2：（设置过期时间）
    锁释放操作可能失败（服务宕机），所以需要设置过期时间
问题3：（设置过期时间的原子性）
    设置过期时间的代码必须在setnx抢占锁的同时设置，保证原子性
问题4：（仅可以删除当前线程占用的锁）
    删除锁时，可能锁已过期删除了其他线程的锁，占锁时设置值为uuid，删除时判断当前uuid是否相等
    并且需要使用lua脚本执行原子删除操作

 */
public Map<String, List<Catalog2VO>> getCatalogJsonFromDBWithRedisLock() {
    // 1.抢占分布式锁，同时设置过期时间
    String uuid = UUID.randomUUID().toString();
    // 使用setnx占锁（setIfAbsent）
    Boolean isLock = redisTemplate.opsForValue().setIfAbsent(CategoryConstant.LOCK_KEY_CATALOG_JSON, uuid, 300, TimeUnit.SECONDS);
    if (isLock) {
        // 2.抢占成功
        Map<String, List<Catalog2VO>> result = null;
        try {
            // 查询DB
            return getCatalogJsonFromDB();
        } finally {
            // 3.查询UUID是否是自己，是自己的lock就删除
            // 封装lua脚本（原子操作解锁）
            // 查询+删除（当前值与目标值是否相等，相等执行删除，不等返回0）
            String luaScript = "if redis.call('get',KEYS[1]) == ARGV[1]\n" +
                    "then\n" +
                    "    return redis.call('del',KEYS[1])\n" +
                    "else\n" +
                    "    return 0\n" +
                    "end";
            // 删除锁
            redisTemplate.execute(new DefaultRedisScript<Long>(luaScript, Long.class), Arrays.asList(CategoryConstant.LOCK_KEY_CATALOG_JSON), uuid);
        }
    } else {
        // 4.加锁失败，自旋重试
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return getCatalogJsonFromDBWithRedisLock();
    }
}
```

## keys 指令

`KEYS` 是 Redis 中用于查找符合特定模式的键（key）的命令。这个命令可以用来列出匹配给定模式的所有键。`KEYS` 命令在生产环境中使用时需要谨慎，因为它可能会对性能产生影响，尤其是在大型数据库中。

**基本用法**

`KEYS` 命令的基本语法如下：

```
KEYS pattern
```

- `pattern` 是一个匹配模式，可以使用通配符：
  - `*` 表示任意数量的字符（包括零个字符）。
  - `?` 表示任意单个字符。
  - `[abc]` 表示匹配括号内的任意一个字符（a、b 或 c）。
  - `[a-f]` 表示匹配括号内的任意一个字符范围（a 到 f）。

**示例**

- 查找所有键：
  ```
  KEYS *
  ```
- 查找以 `user:` 开头的键：
  ```
  KEYS user:*
  ```
- 查找以 `user:` 开头且后面跟着一个数字的键：
  ```
  KEYS user:[0-9]
  ```

**注意事项**

- **性能影响**：`KEYS` 命令在大型数据库中可能会非常慢，因为它需要扫描整个键空间。在生产环境中，应尽量避免使用 `KEYS` 命令，或者只在低负载时段使用。
- **阻塞操作**：在执行 `KEYS` 命令时，Redis 会阻塞其他命令的执行，直到 `KEYS` 命令完成。
- **替代方案**：在生产环境中，推荐使用 `SCAN` 命令来代替 `KEYS`。`SCAN` 命令提供了一种更高效的方式来迭代键集合，它不会阻塞其他命令的执行，并且可以分批次返回结果。

**SCAN 命令**

`SCAN` 命令的基本语法如下：

```
SCAN cursor [MATCH pattern] [COUNT count]
```

- `cursor` 是迭代的游标，初始值为 `0`，表示从头开始迭代。
- `MATCH pattern` 是可选的，用于指定匹配模式。
- `COUNT count` 是可选的，用于指定每次迭代返回的键的数量。

`SCAN` 命令返回两个值：新的游标和匹配的键列表。使用 `SCAN` 命令时，需要在客户端中实现循环逻辑，以迭代整个键空间。

**示例**

使用 `SCAN` 命令迭代所有键：

```
SCAN 0
```

迭代匹配特定模式的键：

```
SCAN 0 MATCH user:*
```

使用 `SCAN` 命令可以有效地减少对Redis性能的影响，特别是在处理大型数据库时。

**SCAN 的缺点**

1. **结果不保证即时性**：`SCAN` 返回的结果是基于当前数据库状态的快照，因此在迭代过程中，数据库的状态可能会发生变化。这意味着 `SCAN` 返回的结果可能不是完全一致的。

2. **使用复杂性**：与 `KEYS` 相比，`SCAN` 需要客户端实现额外的逻辑来处理分批结果。这增加了使用 `SCAN` 的复杂性，尤其是在需要精确匹配特定模式时。

3. **可能需要多次迭代**：`SCAN` 命令可能需要多次迭代才能返回所有匹配的键，这取决于键的数量和 `COUNT` 参数的设置。这可能使得 `SCAN` 在某些情况下不如 `KEYS` 直观。

**总结**

`SCAN` 提供了一种更安全、更高效的方式来迭代 Redis 中的键集合，特别是在处理大型数据库时。尽管它在使用上比 `KEYS` 更复杂，但其非阻塞和分批处理的特性使其成为生产环境中处理键集合的首选命令。在需要精确匹配特定模式时，`SCAN` 与 `MATCH` 选项结合使用，可以提供与 `KEYS` 类似的功能，同时避免了 `KEYS` 可能带来的性能问题。

## Redis 的持久化机制

Redis提供了两种主要的数据持久化方式：快照（Snapshotting）和追加文件（Append Only File，AOF）。这两种方式可以单独使用，也可以结合使用，以提供数据的持久性和可靠性。

**快照(默认)（RDB）**

快照持久化是通过创建数据集的副本来保存在某个时间点的数据状态。Redis通过创建子进程来执行快照操作，这样可以避免阻塞主进程处理客户端请求。RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态 （ 默认下，持久化到 dump.rdb 文件，并且在 redis 重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB 的快照文件，同步到内存中的时间是 20-30 秒）

- **RDB文件**：在指定的时间间隔内，如果达到了指定的更改次数，Redis会创建一个快照并保存到磁盘上。这个快照文件被称为RDB文件。
- **触发条件**：可以通过`save`命令手动触发快照，或者通过配置文件设置自动触发快照的条件，如`save 900 1`表示每900秒内至少有1次更改时创建快照。还有一个是 BGSAVE 命令，SAVE 会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE 命令会派生出一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求，创建 RDB 文件结束之前，客户端发送的 BGSAVE 和 SAVE 命令会被服务器拒绝，**建议使用 BGSAVE 命令**。且通过配置文件·设置自动触发快照就是自动执行的 BGSAVE 命令。
- **恢复数据**：在Redis重启时，可以通过加载RDB文件来恢复数据。

**追加文件（AOF）**

AOF 持久化是通过记录每次写操作到一个日志文件中，然后在 Redis 重启时重新执行这些命令来恢复数据。如果同时启用了 RDB 和 AOF 方式，AOF 优先，启动时只加载 AOF 文件恢复数据。

- **AOF文件**：每次写操作都会被追加到AOF文件的末尾，因此AOF文件会逐渐增长。
- **触发条件**：可以通过配置文件设置AOF重写的条件，如`auto-aof-rewrite-percentage`和`auto-aof-rewrite-min-size`，以控制AOF文件的大小。
- **恢复数据**：在Redis重启时，可以通过重放AOF文件中的命令来恢复数据。

**混合持久化**

Redis 4.0引入了混合持久化（RDB-AOF混合持久化）的方式，它结合了RDB和AOF的优点：

- **混合持久化**：在Redis重启时，首先尝试加载AOF文件来恢复数据。如果AOF文件损坏或不存在，则加载RDB文件来恢复数据。
- **配置**：可以通过配置`aof-use-rdb-preamble yes`来启用混合持久化。

**选择持久化方式**

选择哪种持久化方式取决于应用的需求：

- **如果需要快速重启和数据恢复**，并且可以接受数据丢失的风险，可以选择RDB。
- **如果需要更高的数据安全性**，并且可以接受更高的性能开销，可以选择AOF。
- **如果需要平衡性能和数据安全性**，可以选择混合持久化。

在实际应用中，建议根据数据的重要性和业务需求来选择合适的持久化策略，并进行适当的配置和测试。

## 高并发环境下的缓存问题

### 缓存穿透（不存在的数据）

```json
缓存穿透:
	查询一个一定不存在的数据，导致一定会查询缓存+查询DB，缓存失去意义（大并发过来时任然会查询db）
风险：
	利用不存在的数据进行攻击，数据库顺时压力增大，最终导致崩溃
解决：
	方法1：将null结果缓存，并加入短暂过期时间
	弊端：查询条件使用UUID生成，仍然出现缓存穿透问题，并且redis存满了null
	方法2：布隆过滤器，不放行不存在的查询
    在redis维护id的hash表过滤掉id不存在的查询（不到达DB层查询）
```

### 缓存雪崩（大面积失效）

```json
缓存雪崩：
	高并发状态下，大面积redis数据失效，导致所有查询到达DB，DB瞬时压力过重雪崩
解决：
	方法1：规避雪崩，设置随机的有效时间（实际上无需设置随机时间，因为每个缓存放入库中的时间本身就不固定）
		让每一个缓存过期时间重复率降低，
	方法2：永不失效
	方法3：
		事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
		事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
		事后：利用 redis 持久化机制保存的数据尽快恢复缓存 
问题：如果已经出现了缓存雪崩，如何解决？
	方法1：熔断、降级
```

### 缓存击穿（一条失效）

```json
缓存击穿：
	高并发状态下，一条数据过期，导致短时间内大量请求到达DB
解决：
	方法1：加分布式锁
	例原子操作（Redis的SETNX或者Memcache的ADD）
	流程：查询cache失败，竞争锁，竞争成功查询cache，查询成功返回释放锁
		查询失败则查询DB，并set缓存，并释放锁
	方法2：永不失效
```

### 数据一致性

实际上，对于频繁修改的数据并不适合放在缓存中，因为数据可能刚写到缓存中就发生了变化，缓存即失去了意义，且缓存本身的作用是分担数据库压力和提供高于数据库的处理效率，在高并发环境下，缓存和DB的数据一致性应分情况讨论

**即是否允许暂时性数据不一致**

若允许数据暂时性不一致，那么解决方案根据“暂时”也可以指定许多不同的方案，例如使用消息中间件，缓存DB双写等，但无论是哪种方案，数据库和缓存的数据都无法保证强一致

若必须保证缓存DB的强一致性，则只有一种方案可行，即分布式锁，在加锁的状态中同时更新数据库和缓存

### 多级缓存

多级缓存即 DB ＋ 分布式缓存 ＋ 本地缓存，在实际工作中，请慎重考虑是否真的有必要引入多级缓存，如没有强制业务需求，强烈不建议使用多级缓存，会使业务复杂化，带来的性能提升并不理想

## 布隆过滤器

[布隆过滤器](https://blog.csdn.net/qq_41125219/article/details/119982158)

布隆过滤器可以用于检索一个元素是否在一个集合中。

**优点**：

- 时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）
- 保密性强，布隆过滤器不存储元素本身
- 存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）

**缺点**：

- 有一定的误判率，但是可以通过调整参数来降低
- 无法获取元素本身
- 很难删除元素

**用途**：

- 解决Redis缓存穿透问题（面试重点）
- 邮件过滤，使用布隆过滤器来做邮件黑名单过滤
- 对爬虫网址进行过滤，爬过的不再爬
- 解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)
- HBase\RocksDB\LevelDB等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求

























## redis的过期策略以及内存淘汰机制

redis一般采用的是定期删除+惰性删除策略。

采用定期删除+惰性删除存在的问题

## 内存淘汰策略

应用 解决定期删除+惰性删除存在的问题

## Redis事务

## Redis 集群的同步机制

## Jedis 与 Redisson 对比有什么优缺点

## 说说 Redis 哈希槽的概念

## Redis 集群的主从复制模型是怎样的

## Redis 集群会有写操作丢失吗？为什么？

## Redis 集群最大节点个数是多少

## Redis 如何做内存优化

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一
个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的
所有信息存储到一张散列表里面.

## Redis 回收进程如何工作的



## redis 缓存击穿处理方案

分布式锁，保证一次只能有一个请求访问数据库，并更新缓存，其他请求只能等待该请求完成响应后，直接访问缓存数据。

[(37条消息) redis缓存数据更新问题 - CSDN](https://www.csdn.net/tags/Mtzakg5sMDAzNjgtYmxvZwO0O0OO0O0O.html)

[(37条消息) REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案_有啥不一样的博客-CSDN博客_redis缓存击穿怎么解决](https://blog.csdn.net/soulweee/article/details/119179214)

## 高并发 redis 和数据库双写情况下，如何保证数据的一致性

通过MQ消息队列，更新数据库后使用消息队列更新缓存

## 如何解决由于redis主从节点不同步导致的分布式锁失效问题

使用 zookeeper ，红锁会引入更多得不偿失的问题，比如多次io操作，加锁失败处理，加锁过程中节点的原子性等

## Redis 常见性能问题和解决方案

(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3...

## 集群方案

### Redis 集群方案什么情况下会导致整个集群不可用？

## Pipeline 有什么好处，为什么要用 pipeline？

可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发
现影响 redis 的 QPS峰值的一个重要因素是 pipeline 批次指令的数目。
