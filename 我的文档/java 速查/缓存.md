# Redis

## Redis 的数据类型

以下是 Redis 支持的主要数据类型：

1. **字符串（String）**：
   - 最基本的数据类型。
   - 可以包含任何数据，比如JPEG图像或序列化的Ruby对象。
   - 字符串值最大可以是512MB。

2. **哈希（Hash）**：
   - 键值对的集合。
   - 适合存储对象。
   - 例如，可以存储用户信息，其中键是字段名，值是字段值。

3. **列表（List）**：
   - 字符串列表，按插入顺序排序。
   - 可以添加、移除元素。
   - 支持列表操作，如从两端弹出元素、获取子列表等。

4. **集合（Set）**：
   - 不重复的字符串集合。
   - 支持集合操作，如并集、交集、差集等。
   - 可以用于实现如标签系统、推荐系统等。

5. **有序集合（Sorted Set 也叫 ZSet）**：
   - 类似于集合，但每个元素都会关联一个浮点数分数。
   - 元素按分数排序，但也可以按字典顺序排序。
   - 适用于排行榜、优先级队列等场景。

其他高级数据类型：

1. **位图（Bitmap）**：
   - 字符串数据类型的一种扩展，可以对字符串的位进行操作。
   - 适合实现简单的状态存储，如用户签到、活跃状态等。

2. **超日志（HyperLogLog）**：
   - 用于估计集合中元素数量的概率数据结构。
   - 非常节省内存，但不精确。

3. **地理空间索引（Geo）**：
   - 用于存储地理位置信息，并对这些信息进行操作。
   - 支持计算两个位置之间的距离、查询某个范围内的位置等。

4. **流（Streams）**：
   - 用于实现消息队列的数据类型。
   - 提供了持久化消息队列的功能，支持多个消费者和消息分组。

## 常用命令

**字符串（String）**
- `SET key value`：设置指定 key 的值
- `GET key`：获取指定 key 的值
- `DEL key`：删除指定 key
- `INCR key`：将 key 中存储的数字值增一
- `DECR key`：将 key 中存储的数字值减一
- `INCRBY key increment`：将 key 所储存的值加上给定的增量
- `DECRBY key decrement`：将 key 所储存的值减去给定的减量

**哈希（Hash）**
- `HSET key field value`：将哈希表 key 中的字段 field 的值设为 value
- `HGET key field`：获取存储在哈希表中指定字段的值
- `HDEL key field [field ...]`：删除一个或多个哈希表字段
- `HGETALL key`：获取在哈希表中指定 key 的所有字段和值
- `HINCRBY key field increment`：为哈希表 key 中的指定字段的整数值加上增量 increment

**列表（List）**
- `LPUSH key value [value ...]`：将一个或多个值插入到列表头部
- `RPUSH key value [value ...]`：将一个或多个值插入到列表尾部
- `LRANGE key start stop`：获取列表指定范围内的元素
- `LPOP key`：移除并获取列表的第一个元素
- `RPOP key`：移除并获取列表的最后一个元素
- `LLEN key`：获取列表长度

**集合（Set）**
- `SADD key member [member ...]`：向集合添加一个或多个成员
- `SMEMBERS key`：获取集合中的所有成员
- `SREM key member [member ...]`：移除集合中一个或多个成员
- `SISMEMBER key member`：判断 member 元素是否是集合 key 的成员
- `SCARD key`：获取集合的成员数

**有序集合（Sorted Set）**
- `ZADD key score member [score member ...]`：向有序集合添加一个或多个成员
- `ZRANGE key start stop [WITHSCORES]`：通过索引区间返回有序集合成指定区间内的成员
- `ZREM key member [member ...]`：移除有序集合中的一个或多个成员
- `ZSCORE key member`：获取有序集合中成员的分数值
- `ZCARD key`：获取有序集合的成员数

**位图（Bitmap）**
- `SETBIT key offset value`：对 key 所储存的字符串值，设置或清除指定偏移量上的位
- `GETBIT key offset`：对 key 所储存的字符串值，获取指定偏移量上的位
- `BITOP operation destkey key [key ...]`：对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上

**超日志（HyperLogLog）**
- `PFADD key element [element ...]`：添加指定元素到 HyperLogLog 中
- `PFCOUNT key [key ...]`：返回给定 HyperLogLog 的基数估算值
- `PFMERGE destkey sourcekey [sourcekey ...]`：将多个 HyperLogLog 合并为一个 HyperLogLog

**地理空间索引（Geo）**
- `GEOADD key longitude latitude member [longitude latitude member ...]`：将指定的地理空间位置（经度和纬度）添加到指定的 key 中
- `GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]`：根据给定的经纬度坐标来获取指定范围内的地理位置集合
- `GEOPOS key member [member ...]`：从给定的 key 里返回所有指定 member 的位置（经度和纬度）

**流（Streams）**
- `XADD key ID field value [field value ...]`：向流追加数据
- `XLEN key`：获取流的长度
- `XRANGE key start end [COUNT count]`：获取流中指定范围的元素
- `XREVRANGE key end start [COUNT count]`：获取流中指定范围的元素，但顺序是反的
- `XDEL key ID [ID ...]`：删除流中的指定元素

## 设置已存在的 key 的过期时间

在Redis中，`EXPIRE`命令和`PERSIST`命令分别用于设置和取消设置键（key）的过期时间。以下是这两个命令的详细说明和使用示例：

### EXPIRE命令

`EXPIRE`命令用于设置键的过期时间，单位是秒。一旦键过期，它将自动从Redis中删除。

**语法**:
```
EXPIRE key seconds
```

**参数说明**:
- `key`: 要设置过期时间的键。
- `seconds`: 键的过期时间，单位为秒。

**示例**:
假设我们有一个键`user:1`，我们希望它在60秒后过期。

```
EXPIRE user:1 60
```

这表示`user:1`键将在60秒后自动过期并被删除。

### PERSIST命令

`PERSIST`命令用于移除键的过期时间，使键永久有效。

**语法**:
```
PERSIST key
```

**参数说明**:
- `key`: 要移除过期时间的键。

**示例**:
假设我们之前设置了`user:1`键的过期时间为60秒，现在我们希望它永久有效。

```
PERSIST user:1
```

执行这个命令后，`user:1`键的过期时间将被移除，它将永久保存在Redis中，除非显式地删除它。

注意事项

- 如果键不存在，`EXPIRE`命令将返回0，表示键不会过期。
- 如果键已经设置了过期时间，再次使用`EXPIRE`命令将更新其过期时间。
- 使用`PERSIST`命令移除过期时间后，键将不再受过期时间的限制。

## 一个 Redis 实例最多能存放多少的 keys？

在理论上，Redis可以处理多达2^32个keys，因为Redis使用32位无符号整数来表示key的ID。在实际中，Redis的性能和存储能力主要受限于服务器的内存大小。

每个Redis实例至少可以存放2亿5千万个keys。这个数字是通过实际测试得出的，它展示了Redis在处理大量数据时的性能和能力。

### List、Set、Sorted Set他们最多能存放多少元素？

对于List、Set和Sorted Set这些数据结构，每个实例同样可以存放多达2^32个元素。这意味着Redis的存储极限实际上是由系统中的可用内存决定的。只要服务器的内存足够，Redis就可以存储大量的数据。

## 场景实现类

### 队列

一般使用 list 结构作为队列，rpush 入队，lpop 出队

### 消息队列

1. 可以使用 list 结构作为队列，rpush 生产消息，lpop 消费消息，当 lpop 没有消息的时候，可以使用 blpop 在没有消息的时候，它会阻塞住，直到消息到来，也可以设置阻塞时间
2. 使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。但是在消费者下线的情况下，生产的消息会丢失，解决这样的问题得使用专业的消息队列，如RabbitMQ等。

### 延时队列：

使用 sorted set，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangbyscore 指令获取N秒之前的数据轮询进行处理。

以下是使用Sorted Set实现延时队列的基本步骤：

1. **生产消息**：
   使用`ZADD`命令将消息添加到Sorted Set中。消息的score（分数）是消息预定的执行时间的时间戳，而消息内容作为key。这样，消息就会根据预定时间自动排序。

   示例：
   ```shell
   ZADD delay_queue 1617332800 "message content"
   ```
   这里`delay_queue`是Sorted Set的名称，`1617332800`是消息预定执行的时间戳（例如，2021年4月1日 00:00:00 UTC），`"message content"`是消息内容。

2. **消费消息**：
   消费者使用`ZRANGEBYSCORE`命令来获取在特定时间之前到期的消息。消费者可以定期轮询Sorted Set，获取已经到达预定时间的消息。

   示例：
   ```shell
   ZRANGEBYSCORE delay_queue -inf 1617332800
   ```
   这个命令会返回所有在时间戳`1617332800`之前到期的消息。

3. **处理消息**：
   消费者获取到消息后，可以进行相应的处理。处理完成后，消费者需要从Sorted Set中移除已处理的消息。

   示例：
   ```shell
   ZREM delay_queue "message content"
   ```
   这个命令会从`delay_queue`中移除消息内容为`"message content"`的消息。

使用Sorted Set实现延时队列的优点是简单且高效，消息会根据预定时间自动排序，消费者可以轻松地获取到需要处理的消息。然而，需要注意的是，随着消息数量的增加，`ZRANGEBYSCORE`命令的性能可能会受到影响，因此在处理大量消息时，可能需要考虑使用更高效的消息处理策略，比如使用Redis的Stream数据结构。

此外，使用Sorted Set实现延时队列时，需要确保Redis服务器的时间设置是准确的，因为消息的预定时间是基于服务器的时间戳的。如果服务器时间不准确，可能会导致消息处理的延迟或提前。

### 排行榜/计数器

在Redis中，排行榜和计数器可以通过不同的数据结构来实现。以下是两种常见的实现方式：

1. 使用Sorted Set实现排行榜

Redis的Sorted Set（有序集合）非常适合用来实现排行榜，因为它可以存储带有分数的元素，并且可以快速地根据分数进行排序。

排行榜操作：

- **添加或更新分数**：使用`ZADD`命令可以添加新的元素到排行榜，或者更新已存在的元素的分数。
  
  示例：
  ```shell
  ZADD leaderboard 100 "user1"
  ZADD leaderboard 150 "user2"
  ```

- **获取排行榜**：使用`ZRANGE`或`ZREVRANGE`命令可以获取排行榜的元素列表，`ZREVRANGE`命令会根据分数从高到低排序。
  
  示例：
  ```shell
  ZRANGE leaderboard 0 -1 WITHSCORES
  ```

- **获取特定范围的元素**：可以使用`ZRANGEBYSCORE`命令获取特定分数范围内的元素。
  
  示例：
  ```shell
  ZRANGEBYSCORE leaderboard 100 150 WITHSCORES
  ```

- **获取元素排名**：使用`ZREVRANK`命令可以获取元素在排行榜中的排名。
  
  示例：
  ```shell
  ZREVRANK leaderboard "user1"
  ```

- **删除元素**：使用`ZREM`命令可以删除排行榜中的元素。
  
  示例：
  ```shell
  ZREM leaderboard "user1"
  ```

2. 使用String实现计数器

Redis的String数据类型可以用来实现计数器，因为String可以存储数字，并且支持原子性的自增和自减操作。

计数器操作：

- **增加计数**：使用`INCRBY`命令可以增加计数器的值。
  
  示例：
  ```shell
  INCRBY counter 1
  ```

- **减少计数**：使用`DECRBY`命令可以减少计数器的值。
  
  示例：
  ```shell
  DECRBY counter 1
  ```

- **获取计数器的值**：使用`GET`命令可以获取计数器的当前值。
  
  示例：
  ```shell
  GET counter
  ```

使用Redis实现排行榜和计数器时，需要注意的是，由于Redis是内存数据库，数据的持久化需要通过配置RDB快照或AOF日志来实现。此外，对于高并发场景，需要考虑Redis的性能和资源限制，确保操作的原子性和一致性。

### 发布/订阅

Redis的发布/订阅（pub/sub）模式允许客户端订阅一个或多个频道（channel），然后接收发布到这些频道的消息。这种模式非常适合实现消息通知系统、实时通信等场景。

发布/订阅基本操作

1. **订阅频道**：客户端使用`SUBSCRIBE`命令订阅一个或多个频道。

   示例：
   ```shell
   SUBSCRIBE channel1 channel2
   ```

   这个命令会订阅`channel1`和`channel2`两个频道。

2. **发布消息**：客户端使用`PUBLISH`命令向指定的频道发送消息。

   示例：
   ```shell
   PUBLISH channel1 "Hello, World!"
   ```

   这个命令会向`channel1`频道发送消息`"Hello, World!"`。

3. **接收消息**：订阅了频道的客户端会接收到发布到该频道的所有消息。

   当客户端订阅频道后，它会进入等待状态，接收并处理来自Redis服务器的消息。

发布/订阅的使用场景

- **实时消息通知**：例如，一个聊天应用可以使用发布/订阅模式来通知用户收到新消息。
- **事件驱动系统**：例如，一个系统可以发布事件到特定频道，其他订阅了该频道的系统可以监听这些事件并作出响应。
- **分布式系统通信**：在分布式系统中，不同的服务可以通过发布/订阅模式进行通信。

发布/订阅的限制

- **持久性**：Redis的发布/订阅模式不保证消息的持久性。如果订阅者在消息发布时没有连接到Redis服务器，那么它将无法接收到该消息。
- **消息丢失**：如果发布者和订阅者之间的连接断开，那么在断开期间发布的消息将会丢失。

示例

假设我们有两个客户端，一个用于发布消息，另一个用于订阅频道并接收消息。

**发布者**：
```shell
PUBLISH channel1 "Hello, World!"
```

**订阅者**：
```shell
SUBSCRIBE channel1
```

当发布者向`channel1`发送消息时，订阅者将接收到该消息。

发布/订阅模式是Redis提供的一个非常强大的功能，它允许客户端之间进行松耦合的通信。然而，由于其非持久性的特性，它通常不适用于需要持久化消息的场景。对于需要持久化消息的场景，可以考虑使用Redis的其他数据结构，如List或Stream。

### 分布式锁

先拿 setnx 来争抢锁，抢到之后再用 expire 给锁加一个过期时间防止锁忘记了释放。如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，这个时候锁会永远得不到释放了，但是 set 指令有个非常复杂的参数是可以同时把 setnx 和 expire 合成一条指令来用的。

这个复杂参数是`SET`命令的扩展参数，它允许在设置键值的同时设置过期时间，从而避免了使用`SETNX`和`EXPIRE`两个命令可能带来的竞态条件问题。这个参数是`SET`命令的`NX`和`EX`选项的组合，即`SETNX`和`EX`的缩写。

SET命令的NX和EX选项

- `NX`（Not eXists）：如果键不存在，则设置键值对；如果键已存在，则不进行任何操作。
- `EX`（EXpire）：设置键的过期时间，单位是秒。

使用SET命令实现分布式锁

使用`SET`命令实现分布式锁的步骤如下：

1. **设置锁**：
    使用`SET`命令的`NX`和`EX`选项来设置锁，并指定一个过期时间。

    ```shell
    SET lock_key unique_lock_value EX 30 NX
    ```

    这个命令尝试设置`lock_key`键，如果键不存在，则设置成功并返回`OK`，同时设置键的过期时间为30秒。如果键已存在，则命令不进行任何操作并返回`nil`。

2. **锁的持有**：
    如果`SET`命令返回`OK`，表示成功获取了锁，此时可以执行需要互斥访问的代码。

3. **释放锁**：
    在代码执行完毕后，需要删除锁键来释放锁。为了防止误删除其他客户端的锁，通常会检查锁的值是否与设置时的值相同。

    ```shell
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    ```

注意事项

- **锁的唯一标识**：在使用`SET`命令时，需要确保`unique_lock_value`是唯一的，以区分不同客户端获取的锁。通常可以使用UUID或客户端ID等唯一值。
- **锁的过期时间**：设置一个合理的过期时间是非常重要的，以防止锁永久不释放的情况发生。
- **锁的释放**：释放锁时，需要确保只有锁的持有者才能释放锁，以防止锁被误释放。

使用`SET`命令的`NX`和`EX`选项可以简化分布式锁的实现，同时避免了使用`SETNX`和`EXPIRE`两个命令可能带来的竞态条件问题。然而，需要注意的是，即使使用了`SET`命令的组合选项，分布式锁的实现仍然需要考虑异常情况下的锁释放问题，以确保系统的健壮性。











## 跳表

## Redis 工作模式

(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制

## Redis 的持久化机制

## 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题

## 布隆过滤器

## redis的过期策略以及内存淘汰机制

redis一般采用的是定期删除+惰性删除策略。

采用定期删除+惰性删除存在的问题

## 内存淘汰策略

应用 解决定期删除+惰性删除存在的问题

## 分布式锁的实现

## 为什么Redis的操作是原子性的，怎么保证原子性的？

## Redis事务

## Redis 的同步机制

## Jedis 与 Redisson 对比有什么优缺点

## 说说 Redis 哈希槽的概念

## Redis 集群的主从复制模型是怎样的

## Redis 集群会有写操作丢失吗？为什么？

## Redis 集群最大节点个数是多少

## Redis key 的过期时间和永久有效分别怎么设置

## Redis 如何做内存优化

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一
个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的
所有信息存储到一张散列表里面.

## Redis 回收进程如何工作的

## 使用过 Redis 做异步队列么，你是怎么用的

## 一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素

## 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来

## keys 指令的问题

## redis 缓存击穿处理方案

分布式锁，保证一次只能有一个请求访问数据库，并更新缓存，其他请求只能等待该请求完成响应后，直接访问缓存数据。

[(37条消息) redis缓存数据更新问题 - CSDN](https://www.csdn.net/tags/Mtzakg5sMDAzNjgtYmxvZwO0O0OO0O0O.html)

[(37条消息) REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案_有啥不一样的博客-CSDN博客_redis缓存击穿怎么解决](https://blog.csdn.net/soulweee/article/details/119179214)

## 高并发 redis 和数据库双写情况下，如何保证数据的一致性

通过MQ消息队列，更新数据库后使用消息队列更新缓存

## 如何解决由于redis主从节点不同步导致的分布式锁失效问题

使用 zookeeper ，红锁会引入更多得不偿失的问题，比如多次io操作，加锁失败处理，加锁过程中节点的原子性等

## Redis 常见性能问题和解决方案

(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3...

## 集群方案

### Redis 集群方案什么情况下会导致整个集群不可用？

## Pipeline 有什么好处，为什么要用 pipeline？

可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发
现影响 redis 的 QPS峰值的一个重要因素是 pipeline 批次指令的数目。
