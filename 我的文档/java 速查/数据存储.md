# 关系型数据库

## MySQL

### mysql 的存储引擎类型及其区别

1. **InnoDB**（默认存储引擎）
   - 支持事务处理，提供ACID（原子性、一致性、隔离性、持久性）特性。
   - 支持行级锁定，适合高并发的事务处理。
   - 支持外键约束，保证数据的完整性。
   - 支持MVCC（多版本并发控制），提高读写性能。
   - 适用于OLTP（在线事务处理）系统，如电子商务、银行系统等。

2. **MyISAM**
   - 不支持事务处理。
   - 支持表级锁定，适合读操作多、写操作少的场景。
   - 不支持外键约束。
   - 适用于OLAP（在线分析处理）系统，如数据仓库、报表系统等。
   - 由于不支持事务，所以执行速度较快。

3. **MEMORY**（也称为HEAP）
   - 数据存储在内存中，读写速度非常快。
   - 不支持事务处理。
   - 支持表级锁定。
   - 适用于临时数据存储，如缓存、会话数据等。
   - 数据在重启后会丢失。

4. **ARCHIVE**
   - 用于存储大量数据，但不经常访问的数据。
   - 支持数据压缩，节省存储空间。
   - 不支持索引，只支持插入和查询操作。
   - 适用于日志记录、历史数据存储等场景。

5. **CSV**
   - 数据以CSV格式存储，可以被Excel等电子表格软件直接读取。
   - 不支持索引，查询性能较低。
   - 适用于数据交换和数据迁移。

6. **BLACKHOLE**
   - 用于数据的黑洞存储，所有写入的数据都会被丢弃。
   - 不存储数据，但可以记录日志。
   - 适用于测试和日志记录。

7. **FEDERATED**
   - 允许MySQL服务器访问远程数据库。
   - 不存储数据，而是作为远程数据库的代理。
   - 适用于分布式数据库系统。

8. **NDB（也称为NDBCLUSTER）**
   - 用于MySQL集群，提供高可用性和高性能。
   - 支持数据的自动复制和分片。
   - 适用于需要高可用性和高并发的应用。

### MySQL 的锁类型

MySQL数据库支持多种锁机制，以确保数据的一致性和完整性。锁的类型主要分为两大类：表级锁和行级锁。此外，还有意向锁等其他类型的锁。下面详细介绍这些锁类型：

1. **表级锁（Table Locks）**
   - **表锁（Table Locks）**：这是最粗粒度的锁，锁定整个表。当一个事务对表进行写操作时，其他事务必须等待该事务完成才能进行读写操作。表锁通常用于MyISAM和MEMORY存储引擎。
   - **元数据锁（Metadata Locks, MDL）**：MySQL 5.5及以上版本引入了元数据锁，用于保护数据库对象（如表、视图等）的结构。当一个事务正在修改表结构时，其他事务不能修改或访问该表。

2. **行级锁（Row Locks）**
   - **行锁（Row Locks）**：这是最细粒度的锁，只锁定表中的一行或几行数据。InnoDB存储引擎支持行级锁，这使得并发性能更高，因为其他事务可以同时访问表中的不同行。
   - **间隙锁（Gap Locks）**：InnoDB存储引擎使用间隙锁来防止幻读。间隙锁锁定的是索引记录之间的间隙，而不是记录本身。这可以防止其他事务在间隙中插入新记录。
   - **Next-Key Locks**：这是行锁和间隙锁的组合，用于锁定索引记录及其前面的间隙。Next-Key Locks可以防止幻读和不可重复读。

3. **意向锁（Intention Locks）**
   - **意向共享锁（Intention Shared Lock, IS）**：当事务意图在表的某些行上设置共享锁时，事务会在表上设置意向共享锁。
   - **意向排他锁（Intention Exclusive Lock, IX）**：当事务意图在表的某些行上设置排他锁时，事务会在表上设置意向排他锁。
   - 意向锁的主要目的是为了提高锁的兼容性检查效率。例如，当一个事务需要在表上设置排他锁时，它只需要检查意向排他锁，而不需要检查表中的每一行是否被其他事务锁定。

4. **自增锁（AUTO-INC Locks）**
   - 用于处理自增列的插入操作。当一个事务插入具有自增列的表时，InnoDB会使用自增锁来保证自增列的值是唯一的。

5. **页级锁（Page Locks）**
   - 在某些存储引擎中，如InnoDB，页级锁是行级锁和表级锁的中间级别。页级锁锁定的是数据页，而不是单个行。这可以减少锁的数量，提高性能。

选择合适的锁类型和粒度对于数据库的性能至关重要。InnoDB存储引擎通过行级锁提供了更好的并发控制，而MyISAM存储引擎则使用表级锁。在设计数据库时，应根据应用的读写模式和性能需求来选择合适的存储引擎和锁策略。在高并发环境下，InnoDB的行级锁通常能提供更好的性能。

### 一级索引和二级索引

一级索引：索引与索引的数据存储在一起，都存储在同一个 B+tree 中的叶子节点，通过定位索引就直接可以查找到数据，一般主键索引都是一级索引

二级索引：二级索引的叶子节点存储的是**主键**而不是数据。也就是说，在找到索引后，需要得到对应的主键，再回到一级索引中找主键对应的数据记录。

一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。

二级索引存储主键值而不是存储数据，当数据需要更新的时候，二级索引不需要修改，只需要修改一级索引，一个表只能有一个一级索引，其他的都是二级索引，这样只需要修改一级索引就可以了，不需要重新构建二级索引

[(37条消息) MySQL的一级索引和二级索引介绍_无趣的人民艺术家的博客-CSDN博客_一级索引和二级索引](https://blog.csdn.net/weixin_43606861/article/details/116202806)

### 索引的最左匹配原则

在MySQL中，索引是以 B+Tree 的形式存在的，它是 B_Tree 的变体，其定义基本与 B_Tree 相同，下图就是B+Tree的数据结构，图中非叶子节点，蓝色部分代表索引，黄色部分代表指向下一个节点的指针，叶子节点则代表实际保存的数据。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205071508253.png)

B+树与B树主要存在以下区别

- 非叶子节点的子树指针与关键字个数相同

- 非叶子节点的子树指针P[i]，指向关键字值[K[i], K[i+1]）的子树
- **非叶子节点仅用来索引，数据都保存在叶子节点中**。
- **所有叶子节点具有一个链表指针指向下一个叶子节点，形成一个链表结构**
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是**最大**（或**最小**）元素，上图就是在子节点元素中最小，这个与我们具体定义的规则有关。

如果是联合索引，当建立联合索引时，联合索引当然还是一颗B+树，比如建立一个联合索引(a, b),那么它的索引结构应该是这样的。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205072115193.png)



a索引：1，1，2，2，3，3

b索引：1，2，1，4，1，2

通过观察可以发现，在联合索引中，对于a索引来说，索引是有序排列的，对于b索引是无序排列的。**同时还可以发现对于a值相等的情况下，b值也是有序的。**

这种有序是相对的，a>1 and b=4 遇到这种范围查询，就不会再去走索引，这种情况下a值可以走索引，而b值在这个范围内是无序的，所以最终也不会走索引。

那么就基本可以得出最左匹配原则的定义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like) 就会停止匹配

例如建立一个索引

```sql
INDEX score_age_index (`score`, `age`)
```

**对于全值匹配来说**

```sql
select name from tb_student where age=20 and score=90;
```

查询会走索引，虽然定义索引的顺序是(score, age)，mysql 可以进行优化，自动帮我们改变顺序。

**对于单值来说**

```sql
select name from tb_student where score=90;
```

也是会走索引的，但是下面

```sql
select name from tb_student where age=19;
```

是不会走索引的，因为它并没有从最左连续匹配

**对于字符串类型来说**

它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。

```sql
select * from tb_student  where a like 'As%'; //前缀都是排好序的，走索引查询
select * from tb_student  where  a like '%As'//全表查询
select * from tb_student  where  a like '%As%'//全表查询
```

**对于范围值来说**

可以对左边的列进行范围查询，结果是一定会走索引的。

```sql
select name from tb_student where score > 60 and score < 90;
```

多个列同时进行范围查找时，只有对索引左边的那个列进行范围查找才用到B+树索引，也就是只有score用到了索引，在90>score>60的情况下，age是无序的，不能用索引，找到90>score>60的记录后，只能根据条件 age>20 继续逐条过滤.

**对于精确匹配某一列并范围匹配另一列**

如果左边的列是精确查找的，右边的列可以进行范围查找，因为如果score=90，age是有序的

**排序**

```sql
select name from tb_student order by score,age;
```

因为b+树索引本身就是按照上述规则排序的，order by的子句后面的顺序也必须按照索引列的顺序给出，就会走索引。如果数据库中的数据量过小的时候，mysql数据库会自动为我们做优化，它会认为全表扫描要比索引更快，所以就采用全表扫描方式。

```sql
explain select name from tb_student order by age,score;
```

列的顺序反过来就不会走索引

如果最左边列的值是定值，则对其他列顺序排序是可以用到索引的。

### mysql 的可重复读是如何实现的

InnoDB 里面每个事务都有一个唯一的事务 ID，叫作 transaction id。它在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。而表中的每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

表中的每行记录在更新的时候都会同时记录一条 undo log，这条 log 就会记录上当前事务的 transaction id，记为 row trx_id。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

在可重复读隔离级别下，一个事务在启动时，InnoDB 会为事务构造一个数组，用来保存这个事务启动瞬间，当前**正在”活跃“的所有事务ID**。”活跃“指的是，启动了但还没提交的事务。

这个数组里面事务 ID 为最小值记为低水位，**当前系统里面已经创建过的事务 ID 的最大值**加 1 记为高水位。

这个视图数组把所有的 row trx_id 分成了几种不同的情况。

- 如果当前读到的这行数据的 trx_id 小于低水位，表示这个版本的数据在当前事务启动前已经提交，是安全的，可见
- 如果当前读到的这行数据的 trx_id 大于高水位，表示这个版本的数据是在当前事务启动后生成的，不可见
- 如果当前读到的这行数据的 trx_id 大于低水位，小于高水位，分为两种情况
  - 如果当前读到的这行数据的 trx_id 在数组中，表示这个版本在当前事务启动时还未提交，不可见
  - 如果当前读到的这行数据的 trx_id 不在数组中，表示这个版本在当前事务启动时已经提交，可见

假设事务A, B, C 的 trx_id 分别为 100, 101, 102。事务 A 开始前活跃的事务 ID 只有 99，并且 id=1 这一行数据的 trx_id=90，数据 K = 1。假设 A,B,C 按顺序启动，得出事务启动瞬间的视图数组：事务A：[99, 100]，事务B：[99, 100, 101]，事务C：[99, 100, 101, 102]。此时进行如下操作：

1. 事务C通过更新语句，把 k 更新为 2，此时trx_id=102；
2. 事务B通过更新语句，把 k 更新为 3，此时trx_id=101；
3. 事务B通过查询语句，查询到最新一条记录为3，trx_id=101，满足隔离条件，返回 k=3；
4. 事务A通过查询语句：
   1. 查询到最新一条记录为3，trx_id=101，比高水位大，不可见；
   2. 通过 undo log，找到上一个历史版本，trx_id=102，比高水位大，还是不可见；
   3. 继续找上一个历史版本，trx_id=90，比低水位小，可见。

也就是说**事务B更新的时候是能看到事务C的修改的**

如果事务B在更新的看不到事务C的修改就会出问题：

1. 事务B查询到最新一条记录为2，trx_id=102，比高水位大，不可见；
2. 通过 undo log，找到上一个版本，trx_id=90，比低水位小，可见；
3. 返回记录 k=1，执行 k=k+1，把 k 更新为2，此时 trx_id=101。

此时事务B覆盖了事务C的更新，所以，InnoDB在更新时运用一条规则：**更新数据都是先读后写的，而这个读，只能读当前最新的值，称为“当前读“ （current read）**，因此，事务B在更新时要拿到最新的数据，在此基础上做更新。紧接着，事务B在读取的时候，查询到最新的记录为3， trx_id=101 为当前事务ID，可见

再假设另一种情况：

事务B在更新之后，事务C紧接着更新，事务B回滚了，事务C成功提交

如果按照当前读的定义，会发生以下事故，假设当前 K=1：

1. 事务B把 k 更新为 2；
2. 事务C读取到当前最新值，k=2，更新为3；
3. 事务B回滚；
4. 事务C提交。

这时候，事务C发现自己想要执行的是 +1 操作，结果变成了 ”+2“ 操作。

InnoDB 肯定不允许这种情况的发生，因此事务B在执行更新语句时，会给该行加上行锁，直到事务B结束，才会释放这个锁。

小结

1. InnoDB 的行数据有多个版本，每个版本都有 row trx_id。
2. 事务根据 undo log 和 trx_id 构建出满足当前隔离级别的一致性视图。
3. 可重复读的核心是一致性读，而事务更新数据的时候，只能使用当前读，如果当前记录的行锁被其他事务占用，就需要进入锁等待。

## oracle

### oracle 中的表分区方式

范围分区、Hash分区、List分区、时间分区

## sql 的执行顺序

SQL语句的执行顺序通常遵循以下步骤，以`SELECT`语句为例：

1. **FROM**：首先，SQL引擎会处理`FROM`子句，确定查询的数据源，这可以是单个表、多个表的连接、子查询等。

2. **JOIN**：如果在`FROM`子句中使用了`JOIN`操作，那么会根据`JOIN`条件进行表的连接操作。

3. **ON**：在`JOIN`操作之后，会应用`ON`子句中的条件来过滤连接结果。

4. **WHERE**：接着，SQL引擎会处理`WHERE`子句中的条件，过滤掉不符合条件的行。

5. **GROUP BY**：如果使用了`GROUP BY`子句，那么会根据指定的列对结果集进行分组。

6. **HAVING**：在`GROUP BY`之后，如果使用了`HAVING`子句，那么会根据`HAVING`子句中的条件过滤分组后的结果。

7. **SELECT**：然后，SQL引擎会处理`SELECT`子句，确定最终返回哪些列。

8. **DISTINCT**：如果在`SELECT`子句中使用了`DISTINCT`关键字，那么会去除结果集中的重复行。

9. **ORDER BY**：最后，如果使用了`ORDER BY`子句，那么会根据指定的列对结果集进行排序。

10. **LIMIT/OFFSET**：在某些数据库系统中，可以使用`LIMIT`和`OFFSET`子句来限制返回的行数和指定返回结果的起始位置。

需要注意的是，不同的数据库系统可能会有细微的差别，例如在某些数据库中，`WHERE`子句可能在`GROUP BY`之后执行，或者`HAVING`子句在`ORDER BY`之后执行。此外，`SELECT`子句中的计算表达式和函数调用通常在`FROM`和`WHERE`子句之后执行。

在编写SQL语句时，了解这些执行顺序对于编写高效且正确的查询至关重要。例如，如果在`WHERE`子句中使用了聚合函数（如`COUNT`, `SUM`, `AVG`等），这通常会导致语法错误，因为聚合函数应该在`GROUP BY`之后使用。同样，如果在`SELECT`列表中使用了`ORDER BY`子句中未出现的列，这可能会导致意外的结果，因为`ORDER BY`子句是在`SELECT`子句之后执行的。

## 怎样避免数据库死锁

1，尽量不要在一个事务中实现过于复杂的查询或更新操作。原因很简单，越是复杂的数据库操作，占用数据库资源的时间越长，引发死锁的可能性越大。

2，尽量不要在数据库事务中要求用户响应。原因同1，这也会导致事务长时间无法结束，浪费数据库资料。

3，死锁是由于并发访问数据库资源造成的，减少死锁就应该限制应用系统的并发访问量。我们应该合理设置后台服务的线程数，将大量数据的操作分解，分步骤，分阶段的执行。也应该避免在用户量大的时候大规模的进行后台数据库操作，应该将大规模的数据库操作放在用户量最少的时候进行。

4，尽可能以分区表或分区视图的方式拆分包含大量数据的表，将它们保存在不同的物量磁盘和文件组中。在访问数据时，可以分散访问保存在不同分区的数据，从而减少因为在大型表中放置锁而造成其它事务长时间等待的概率。

5，尽量避免使用占用很长的复杂查询,在条件允许的情况下应该尽量使用分页查询或缩小结果集的方式。因为复杂查询会长时间占用数据库资源，增加发生死锁的概率。

6，尽可能使用较低的隔离级别，如READ UNCOMMITTED，因为隔离级别低时，事务之间相互等待的情况会减少，这样每个事务都会尽可能快地完成数据库操作，然后释放其拥有的锁资源，这样就会降低出现锁等待或死锁的概率。当然，用户在设计数据库应用程序时，需要考虑如何解决事务中数据不一致的情况。

7，应该注意统一访问表的顺序，尽量避免有的事务先查询表A然后更新表B，而有的事务先查询表B再更新表A的情况。

8，如果一个事务中只进行读取数据的操作，则可以在该事务中使用快照(SNAPSHOT)隔离级别。因为在快照隔离级别中，数据库引擎不会阻塞其他事务对当前事务所占用资源的修改操作，当前事务会认为它所拥有的资源没有被修改过（实际上它所拥有的资源是一个快照）。这样就可以减少因为等待资源而产生死锁的情况。

[(37条消息) 数据库常见死锁原因及处理_zxcodestudy的博客-CSDN博客_数据库的死锁](https://blog.csdn.net/qq_16681169/article/details/74784193?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~default-1-74784193-blog-105745720.pc_relevant_without_ctrlist_v4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~default-1-74784193-blog-105745720.pc_relevant_without_ctrlist_v4&utm_relevant_index=1)

