# 关系型数据库

## MySQL

### mysql 的存储引擎类型及其区别

1. **InnoDB**（默认存储引擎）
   - 支持事务处理，提供ACID（原子性、一致性、隔离性、持久性）特性。
   - 支持行级锁定，适合高并发的事务处理。
   - 支持外键约束，保证数据的完整性。
   - 支持MVCC（多版本并发控制），提高读写性能。
   - 适用于OLTP（在线事务处理）系统，如电子商务、银行系统等。

2. **MyISAM**
   - 不支持事务处理。
   - 支持表级锁定，适合读操作多、写操作少的场景。
   - 不支持外键约束。
   - 适用于OLAP（在线分析处理）系统，如数据仓库、报表系统等。
   - 由于不支持事务，所以执行速度较快。

3. **MEMORY**（也称为HEAP）
   - 数据存储在内存中，读写速度非常快。
   - 不支持事务处理。
   - 支持表级锁定。
   - 适用于临时数据存储，如缓存、会话数据等。
   - 数据在重启后会丢失。

4. **ARCHIVE**
   - 用于存储大量数据，但不经常访问的数据。
   - 支持数据压缩，节省存储空间。
   - 不支持索引，只支持插入和查询操作。
   - 适用于日志记录、历史数据存储等场景。

5. **CSV**
   - 数据以CSV格式存储，可以被Excel等电子表格软件直接读取。
   - 不支持索引，查询性能较低。
   - 适用于数据交换和数据迁移。

6. **BLACKHOLE**
   - 用于数据的黑洞存储，所有写入的数据都会被丢弃。
   - 不存储数据，但可以记录日志。
   - 适用于测试和日志记录。

7. **FEDERATED**
   - 允许MySQL服务器访问远程数据库。
   - 不存储数据，而是作为远程数据库的代理。
   - 适用于分布式数据库系统。

8. **NDB（也称为NDBCLUSTER）**
   - 用于MySQL集群，提供高可用性和高性能。
   - 支持数据的自动复制和分片。
   - 适用于需要高可用性和高并发的应用。

### 锁

客户端发往 MySQL 的一条条 SQL 语句，实际上都可以理解成一个个单独的事务（一条sql语句默认就是一个事务）。而事务是基于数据库连接的，每个数据库连接在MySQL中，又会用一条工作线程来维护，也意味着一个事务的执行，本质上就是一条工作线程在执行，当出现多个事务同时执行时，这种情况则被称之为并发事务，所谓的并发事务也就是指多条线程并发执行。

多线程并发执行自然就会出问题，也就是脏写、脏读、不可重复读及幻读问题。而对于这些问题又可以通过调整事务的隔离级别来避免，不同的隔离级别中，工作线程执行SQL语句时，用的锁粒度、类型不同。

**锁分类**

MySQL 的锁机制与索引机制类似，都是由存储引擎负责实现的，这也就意味着不同的存储引擎，支持的锁也并不同，这里是指不同的引擎实现的锁粒度不同。但除开从锁粒度来划分锁之外，其实锁也可以从其他的维度来划分，因此也会造出很多关于锁的名词，下面先简单梳理一下 MySQL 的锁体系：

- 以锁粒度的维度划分
  - 全局锁：锁定数据库中的所有表。加上全局锁之后，整个数据库只能允许读，不允许做任何写操作
  - 表级锁：每次操作锁住整张表。主要分为三类
    - 表锁（分为表共享读锁 read lock、表独占写锁 write lock）
    - 元数据锁（meta data lock，MDL）：基于表的元数据加锁，加锁后整张表不允许其他事务操作。这里的元数据可以简单理解为一张表的表结构
    - 意向锁（分为意向共享锁、意向排他锁）：这个是InnoDB中为了支持多粒度的锁，为了兼容行锁、表锁而设计的，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查
  - 行级锁：每次操作锁住对应的行数据。主要分为三类
    - 记录锁 / Record 锁：也就是行锁，一条记录和一行数据是同一个意思。防止其他事务对此行进行update和delete，在 RC、RR隔离级别下都支持
    - 间隙锁 / Gap 锁：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
    - 临键锁 / Next-Key 锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能，在RR隔离级别下支持
- 以互斥性的角度划分
  - 共享锁 / S锁：不同事务之间不会相互排斥、可以同时获取的锁
  - 排他锁 / X锁：不同事务之间会相互排斥、同时只能允许一个事务获取的锁
  - 共享排他锁 / SX锁：MySQL5.7 版本中新引入的锁，主要是解决SMO带来的问题
- 以操作类型的维度划分
  - 读锁：查询数据时使用的锁
  - 写锁：执行插入、删除、修改、DDL语句时使用的锁
- 以加锁方式的维度划分
  - 显示锁：编写SQL语句时，手动指定加锁的粒度
  - 隐式锁：执行SQL语句时，根据隔离级别自动为SQL操作加锁
- 以思想的维度划分
  - 乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁
  - 悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行

放眼望下来，是不是看着还蛮多的，但总归说来说去其实就共享锁、排他锁两种，只是加的方式不同、加的地方不同，因此就演化出了这么多锁的称呼。

**共享锁与排他锁**

共享锁（S锁）

一个事务已获取共享锁，当另一个事务尝试对具备共享锁的数据进行读操作时，可正常读；进行写操作时，会被共享锁排斥。

> 事务T1对ID=18的数据加了一个共享锁，此时事务T2、T3也来读取ID=18的这条数据，这时T2、T3是可以获取共享锁执行的；但此刻又来了一个事务T4，它则是想对ID=18的这条数据执行修改操作，此时共享锁会出现排斥行为，不允许T4获取锁执行。

在MySQL中，我们可以在SQL语句后加上相关的关键字来使用共享锁，语法如下：

```sql
SELECT ... LOCK IN SHARE MODE;
-- MySQL8.0之后也优化了写法，如下：
SELECT ... FOR SHARE;
```

这种通过在SQL后添加关键字的加锁形式，被称为显式锁，而实际上为数据库设置了不同的事务隔离级别后，MySQL也会对SQL自动加锁，这种形式则被称之为隐式锁。

排他锁（X锁）

当一个线程获取到独占锁后，会排斥其他线程（进行读写操作），如若其他线程也想对共享资源/同一数据进行操作，必须等到当前线程释放锁并竞争到锁资源才行。

> 值得注意的一点是：**排他锁并不是只能用于写操作，对于一个读操作，咱们也可以手动地指定为获取排他锁，当一个事务在读数据时，获取了排他锁，那当其他事务来读、写同一数据时，都会被排斥**。比如事务T1对ID=18的这条数据加了一个排他锁，此时T2来加排他锁读取这条数据，T3来修改这条数据，都会被T1排斥。

在MySQL中，可以通过如下方式显式获取独占锁：

```sql
SELECT ... FOR UPTATE;
```

**MySQL 中锁的释放**

其实MySQL中释放锁的动作都是隐式的，毕竟如果交给咱们来释放，很容易由于操作不当造成死锁问题发生。因此对于锁的释放工作，MySQL自己来干，就类似于JVM中的GC机制一样，把内存释放的工作留给了自己完成。

但对于锁的释放时机，在不同的隔离级别中也并不相同，比如在“读未提交”级别中，是SQL执行完成后就立马释放锁；而在“可重复读”级别中，是在事务结束后才会释放。

> 如果完全按照数据库规范来实现RC隔离级别，为了保证其他事务可以读到未提交的数据，那就必须得在SQL执行完成后，立马释放掉锁，这时另一个事务才能读到SQL对应写的数据，但在InnoDB引擎中，它基于MVCC机制实现了该效果，为此，InnoDB的RC级别中，SQL执行结束后并不会释放锁。

#### 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

```sql
# 加全局锁、获取全局锁
flush tables with read lock;  

# 数据备份。具体指令可见 
mysqldump -u 用户名 -p 数据库名 > /back/backup.sql

# 释放全局锁
unlock tables;
```

数据库中加全局锁，是一个比较重的操作，存在以下问题：

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。

在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。

```sql
mysqldump --single-transaction -uroot –p123456 test > backup.sql
```

#### 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。

#### 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。在MySQL诸多的存储引擎中，仅有InnoDB引擎支持行锁（不考虑那些闭源自研的），MyISAM等引擎不支持行锁，因为InnoDB支持聚簇索引——将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。InnoDB中如果能够命中索引数据，就会加行锁，无法命中则会加表锁。

**页面锁**

页面锁是 Berkeley DB 存储引擎支持的一种锁粒度，当然，由于BDB引擎被Oracle收购的原因，因此 MySQL5.1 以后不再直接性的支持该引擎（需自己整合），因此页锁见的也比较少。

### 索引

索引的具体实现方式与数据库有关，不同的数据库管理系统（DBMS）可能会采用不同的数据结构和算法来实现索引，以优化查询性能和数据管理。

#### 索引的分类

在 InnoDB 存储引擎中，索引可以按照它们的特点分为两种主要类型：主键索引（Primary Index）和辅助索引（Secondary Index）。主键索引和辅助索引都使用 B+ 树数据结构来实现。

##### 主键索引（一级索引）

主键索引是一种特殊的索引，它唯一标识表中的每一行记录。在InnoDB中，每张表必须有一个主键索引，如果表中没有显式定义主键，InnoDB 会自动选择一个**唯一的非空**列作为主键，或者创建一个隐藏的行 ID（称为聚簇索引）作为主键。

聚簇索引也叫聚集索引。并不是一种单独的索引类型，而是一种数据存储方式。虽然是使用 B+ 树数据结构，但实现细节有所不同。

- 在聚簇索引中，数据行本身存储在索引的叶子节点中。这意味着，当通过聚簇索引访问数据时，实际上是在访问数据行本身。而在B+树中，叶子节点通常存储数据的引用（如行指针或行ID），而不是数据行本身。
- 聚簇索引的索引键通常是表的主键，而B+树的索引键可以是任何列或列组合。
- 聚簇索引的索引键必须是唯一的，因为数据行是根据索引键的值排序的。而B+树的索引键可以是唯一的，也可以不是唯一的，这取决于索引的类型（唯一索引或非唯一索引）。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171703423.png)

其余特点则与B＋树类似：

- 所有的非叶子结点可以看成是索引部分，节点中含有其子树中最大或最小的关键字
- 叶子节点中身依关键字大小自小到大顺序连接，形成一个有序的双向链表
- 查询必须最终查找到叶子节点

##### 辅助索引（二级索引）

- 辅助索引也称为非聚簇索引，它们是除了主键索引之外的其他索引。辅助索引的叶子节点存储了主键值和索引列的值，而不是整个数据行。
- 当通过辅助索引查询数据时，首先通过辅助索引找到主键值，然后使用主键值在主键索引中定位到完整的数据行。这种机制称为“回表”操作，它比直接通过主键索引查询要多一次查找。
- 主键索引可以单独存在，辅助索引不能单独存在，必须依附于主键索引






[(37条消息) MySQL的一级索引和二级索引介绍_无趣的人民艺术家的博客-CSDN博客_一级索引和二级索引](https://blog.csdn.net/weixin_43606861/article/details/116202806)

#### 索引的最左匹配原则

在MySQL中，索引是以 B+Tree 的形式存在的，它是 B_Tree 的变体，其定义基本与 B_Tree 相同，下图就是B+Tree的数据结构，图中非叶子节点，蓝色部分代表索引，黄色部分代表指向下一个节点的指针，叶子节点则代表实际保存的数据。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205071508253.png)

B+树与B树主要存在以下区别

- 非叶子节点的子树指针与关键字个数相同

- 非叶子节点的子树指针P[i]，指向关键字值[K[i], K[i+1]）的子树
- **非叶子节点仅用来索引，数据都保存在叶子节点中**。
- **所有叶子节点具有一个链表指针指向下一个叶子节点，形成一个链表结构**
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是**最大**（或**最小**）元素，上图就是在子节点元素中最小，这个与我们具体定义的规则有关。

如果是联合索引，当建立联合索引时，联合索引当然还是一颗B+树，比如建立一个联合索引(a, b),那么它的索引结构应该是这样的。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205072115193.png)



a索引：1，1，2，2，3，3

b索引：1，2，1，4，1，2

通过观察可以发现，在联合索引中，对于a索引来说，索引是有序排列的，对于b索引是无序排列的。**同时还可以发现对于a值相等的情况下，b值也是有序的。**

这种有序是相对的，a>1 and b=4 遇到这种范围查询，就不会再去走索引，这种情况下a值可以走索引，而b值在这个范围内是无序的，所以最终也不会走索引。

那么就基本可以得出最左匹配原则的定义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like) 就会停止匹配

例如建立一个索引

```sql
INDEX score_age_index (`score`, `age`)
```

**对于全值匹配来说**

```sql
select name from tb_student where age=20 and score=90;
```

查询会走索引，虽然定义索引的顺序是(score, age)，mysql 可以进行优化，自动帮我们改变顺序。

**对于单值来说**

```sql
select name from tb_student where score=90;
```

也是会走索引的，但是下面

```sql
select name from tb_student where age=19;
```

是不会走索引的，因为它并没有从最左连续匹配

**对于字符串类型来说**

它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。

```sql
select * from tb_student  where a like 'As%'; //前缀都是排好序的，走索引查询
select * from tb_student  where  a like '%As'//全表查询
select * from tb_student  where  a like '%As%'//全表查询
```

**对于范围值来说**

可以对左边的列进行范围查询，结果是一定会走索引的。

```sql
select name from tb_student where score > 60 and score < 90;
```

多个列同时进行范围查找时，只有对索引左边的那个列进行范围查找才用到B+树索引，也就是只有score用到了索引，在90>score>60的情况下，age是无序的，不能用索引，找到90>score>60的记录后，只能根据条件 age>20 继续逐条过滤.

**对于精确匹配某一列并范围匹配另一列**

如果左边的列是精确查找的，右边的列可以进行范围查找，因为如果score=90，age是有序的

**排序**

```sql
select name from tb_student order by score,age;
```

因为b+树索引本身就是按照上述规则排序的，order by的子句后面的顺序也必须按照索引列的顺序给出，就会走索引。如果数据库中的数据量过小的时候，mysql数据库会自动为我们做优化，它会认为全表扫描要比索引更快，所以就采用全表扫描方式。

```sql
explain select name from tb_student order by age,score;
```

列的顺序反过来就不会走索引

如果最左边列的值是定值，则对其他列顺序排序是可以用到索引的。

### mysql 的可重复读是如何实现的

InnoDB 里面每个事务都有一个唯一的事务 ID，叫作 transaction id。它在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。而表中的每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

表中的每行记录在更新的时候都会同时记录一条 undo log，这条 log 就会记录上当前事务的 transaction id，记为 row trx_id。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

在可重复读隔离级别下，一个事务在启动时，InnoDB 会为事务构造一个数组，用来保存这个事务启动瞬间，当前**正在”活跃“的所有事务ID**。”活跃“指的是，启动了但还没提交的事务。

这个数组里面事务 ID 为最小值记为低水位，**当前系统里面已经创建过的事务 ID 的最大值**加 1 记为高水位。

这个视图数组把所有的 row trx_id 分成了几种不同的情况。

- 如果当前读到的这行数据的 trx_id 小于低水位，表示这个版本的数据在当前事务启动前已经提交，是安全的，可见
- 如果当前读到的这行数据的 trx_id 大于高水位，表示这个版本的数据是在当前事务启动后生成的，不可见
- 如果当前读到的这行数据的 trx_id 大于低水位，小于高水位，分为两种情况
  - 如果当前读到的这行数据的 trx_id 在数组中，表示这个版本在当前事务启动时还未提交，不可见
  - 如果当前读到的这行数据的 trx_id 不在数组中，表示这个版本在当前事务启动时已经提交，可见

假设事务A, B, C 的 trx_id 分别为 100, 101, 102。事务 A 开始前活跃的事务 ID 只有 99，并且 id=1 这一行数据的 trx_id=90，数据 K = 1。假设 A,B,C 按顺序启动，得出事务启动瞬间的视图数组：事务A：[99, 100]，事务B：[99, 100, 101]，事务C：[99, 100, 101, 102]。此时进行如下操作：

1. 事务C通过更新语句，把 k 更新为 2，此时trx_id=102；
2. 事务B通过更新语句，把 k 更新为 3，此时trx_id=101；
3. 事务B通过查询语句，查询到最新一条记录为3，trx_id=101，满足隔离条件，返回 k=3；
4. 事务A通过查询语句：
   1. 查询到最新一条记录为3，trx_id=101，比高水位大，不可见；
   2. 通过 undo log，找到上一个历史版本，trx_id=102，比高水位大，还是不可见；
   3. 继续找上一个历史版本，trx_id=90，比低水位小，可见。

也就是说**事务B更新的时候是能看到事务C的修改的**

如果事务B在更新的看不到事务C的修改就会出问题：

1. 事务B查询到最新一条记录为2，trx_id=102，比高水位大，不可见；
2. 通过 undo log，找到上一个版本，trx_id=90，比低水位小，可见；
3. 返回记录 k=1，执行 k=k+1，把 k 更新为2，此时 trx_id=101。

此时事务B覆盖了事务C的更新，所以，InnoDB在更新时运用一条规则：**更新数据都是先读后写的，而这个读，只能读当前最新的值，称为“当前读“ （current read）**，因此，事务B在更新时要拿到最新的数据，在此基础上做更新。紧接着，事务B在读取的时候，查询到最新的记录为3， trx_id=101 为当前事务ID，可见

再假设另一种情况：

事务B在更新之后，事务C紧接着更新，事务B回滚了，事务C成功提交

如果按照当前读的定义，会发生以下事故，假设当前 K=1：

1. 事务B把 k 更新为 2；
2. 事务C读取到当前最新值，k=2，更新为3；
3. 事务B回滚；
4. 事务C提交。

这时候，事务C发现自己想要执行的是 +1 操作，结果变成了 ”+2“ 操作。

InnoDB 肯定不允许这种情况的发生，因此事务B在执行更新语句时，会给该行加上行锁，直到事务B结束，才会释放这个锁。

小结

1. InnoDB 的行数据有多个版本，每个版本都有 row trx_id。
2. 事务根据 undo log 和 trx_id 构建出满足当前隔离级别的一致性视图。
3. 可重复读的核心是一致性读，而事务更新数据的时候，只能使用当前读，如果当前记录的行锁被其他事务占用，就需要进入锁等待。

## oracle

### oracle 中的表分区方式

范围分区、Hash分区、List分区、时间分区

## sql 的执行顺序

SQL语句的执行顺序通常遵循以下步骤，以`SELECT`语句为例：

1. **FROM**：首先，SQL引擎会处理`FROM`子句，确定查询的数据源，这可以是单个表、多个表的连接、子查询等。

2. **JOIN**：如果在`FROM`子句中使用了`JOIN`操作，那么会根据`JOIN`条件进行表的连接操作。

3. **ON**：在`JOIN`操作之后，会应用`ON`子句中的条件来过滤连接结果。

4. **WHERE**：接着，SQL引擎会处理`WHERE`子句中的条件，过滤掉不符合条件的行。

5. **GROUP BY**：如果使用了`GROUP BY`子句，那么会根据指定的列对结果集进行分组。

6. **HAVING**：在`GROUP BY`之后，如果使用了`HAVING`子句，那么会根据`HAVING`子句中的条件过滤分组后的结果。

7. **SELECT**：然后，SQL引擎会处理`SELECT`子句，确定最终返回哪些列。

8. **DISTINCT**：如果在`SELECT`子句中使用了`DISTINCT`关键字，那么会去除结果集中的重复行。

9. **ORDER BY**：最后，如果使用了`ORDER BY`子句，那么会根据指定的列对结果集进行排序。

10. **LIMIT/OFFSET**：在某些数据库系统中，可以使用`LIMIT`和`OFFSET`子句来限制返回的行数和指定返回结果的起始位置。

需要注意的是，不同的数据库系统可能会有细微的差别，例如在某些数据库中，`WHERE`子句可能在`GROUP BY`之后执行，或者`HAVING`子句在`ORDER BY`之后执行。此外，`SELECT`子句中的计算表达式和函数调用通常在`FROM`和`WHERE`子句之后执行。

在编写SQL语句时，了解这些执行顺序对于编写高效且正确的查询至关重要。例如，如果在`WHERE`子句中使用了聚合函数（如`COUNT`, `SUM`, `AVG`等），这通常会导致语法错误，因为聚合函数应该在`GROUP BY`之后使用。同样，如果在`SELECT`列表中使用了`ORDER BY`子句中未出现的列，这可能会导致意外的结果，因为`ORDER BY`子句是在`SELECT`子句之后执行的。

## 怎样避免数据库死锁

1，尽量不要在一个事务中实现过于复杂的查询或更新操作。原因很简单，越是复杂的数据库操作，占用数据库资源的时间越长，引发死锁的可能性越大。

2，尽量不要在数据库事务中要求用户响应。原因同1，这也会导致事务长时间无法结束，浪费数据库资料。

3，死锁是由于并发访问数据库资源造成的，减少死锁就应该限制应用系统的并发访问量。我们应该合理设置后台服务的线程数，将大量数据的操作分解，分步骤，分阶段的执行。也应该避免在用户量大的时候大规模的进行后台数据库操作，应该将大规模的数据库操作放在用户量最少的时候进行。

4，尽可能以分区表或分区视图的方式拆分包含大量数据的表，将它们保存在不同的物量磁盘和文件组中。在访问数据时，可以分散访问保存在不同分区的数据，从而减少因为在大型表中放置锁而造成其它事务长时间等待的概率。

5，尽量避免使用占用很长的复杂查询,在条件允许的情况下应该尽量使用分页查询或缩小结果集的方式。因为复杂查询会长时间占用数据库资源，增加发生死锁的概率。

6，尽可能使用较低的隔离级别，如READ UNCOMMITTED，因为隔离级别低时，事务之间相互等待的情况会减少，这样每个事务都会尽可能快地完成数据库操作，然后释放其拥有的锁资源，这样就会降低出现锁等待或死锁的概率。当然，用户在设计数据库应用程序时，需要考虑如何解决事务中数据不一致的情况。

7，应该注意统一访问表的顺序，尽量避免有的事务先查询表A然后更新表B，而有的事务先查询表B再更新表A的情况。

8，如果一个事务中只进行读取数据的操作，则可以在该事务中使用快照(SNAPSHOT)隔离级别。因为在快照隔离级别中，数据库引擎不会阻塞其他事务对当前事务所占用资源的修改操作，当前事务会认为它所拥有的资源没有被修改过（实际上它所拥有的资源是一个快照）。这样就可以减少因为等待资源而产生死锁的情况。

[(37条消息) 数据库常见死锁原因及处理_zxcodestudy的博客-CSDN博客_数据库的死锁](https://blog.csdn.net/qq_16681169/article/details/74784193?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~default-1-74784193-blog-105745720.pc_relevant_without_ctrlist_v4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~default-1-74784193-blog-105745720.pc_relevant_without_ctrlist_v4&utm_relevant_index=1)

