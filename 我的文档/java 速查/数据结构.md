[TOC]

# 树

树是一种拥有N个节点的有限数据集，在任意一颗非空树中：

1. 有且仅有一个根节点
2. 当N>1时，其余节点可分为多个互不相交的子树

树中的每个节点存储了该节点的数据和指向其子树的指针，该节点拥有的子树的数量称为节点的**度**，度为0的节点称为**叶子节点**或**终端节点**，度不为0的节点称为**非终端节点**或**分支节点**，节点的层次从根节点开始算起，根节点为第一层，根节点的孩子节点为第二层，树中节点的最大层次称为树的**深度**或**高度**，如果树中节点的各个子树从左至右是有顺序的（即不能互换的），则该树称为有序树，否则称为无序树。

## 二叉树

二叉树的特点是每个节点至多只能存在两颗子树，即二叉树中不存在度大于2的节点，二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树需要满足：

1. 在二叉树的第n层上，至多有2的n-1次幂个节点
2. 深度为K的二叉树至多有2的K次幂-1个节点
3. 对于任意一颗二叉树，如果其终端节点数为N1，度为2的节点数为N2，则N1 = N2 +1 

一颗深度为K且有2的K次幂 -1 个节点二叉树称为**满二叉树**，可以对满二叉树的节点进行连续编号，自上而下，从左到右，当且仅当其每一个节点都与编号一一对应时，称为**完全二叉树**。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152005279.png)

### 遍历二叉树

先序遍历：

先访问根节点，先序遍历左子树，先序遍历右子树

中序遍历：

中序遍历左子树，访问根节点，中序遍历右子树

后序遍历：

后序遍历左子树，后序遍历右子树，访问根节点。

除了上述遍历方法外，还可以从上到下，从左至右进行遍历。可以看出，无论是通过什么方式进行遍历操作，实质上都是按一定规则将二叉树中的节点排列成一个线性序列的过程。

但是，当以二叉链表的形式存储树时，每个节点中只存储了节点的左右孩子信息，而不能直接得到该节点需要遍历的下一个节点是谁，一个最简单的解决方法是在每个节点中增加两个指针 fow 和 bkwd，分别指示在任意一次遍历时得到的前驱和后继信息，另一方面，在有N个节点的二叉链表中本身就存在N+1个空指针，由此设想能否利用这些空链来存放信息，相当于**把一棵二叉树变成一个双向链表**。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152041858.jpeg)

## 赫夫曼树

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

```
WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3
```

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152050663.png)

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

### 构建哈夫曼树的过程

对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152056271.png)

图中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。

## 二叉排序树

二叉排序树：

1. 左子树上所有的节点均小于其根节点的值，右子树上所有的节点均大于根节点的值，其左子树和右子树也分别为二叉排序树。

二叉排序树即二叉查找树，根据定义可见，其查找过程类似于二分查找，首先将给定的值与根节点比较，若相等则查找结束，否则根据大小关系，分别在左子树或右子树中查找。

### 二叉排序树的插入

二叉排序树是一种动态树表，其树的结构通常是在查找的过程中，当树中不存在关键字时进行插入，**新插入的节点一定是一个新添加的终端节点**，而且是查找不成功时查找路径上**访问的最后一个节点的左孩子或者是右孩子节点**。

也就是说中序遍历二叉查找树可以得到一个关键字的有序序列，一个无序序列可以通过构造一个二叉查找树变成一个有序序列，构造的过程就是排序过程。不仅如此，每次插入的新节点都是叶子节点，则在插入节点时，仅需改动某个节点的指针，由空变为非空即可。

### 二叉排序树的删除

删除一个节点相当于删除有序序列中的一个元素，分为以下几种情况：

1. 删除的节点为终端节点，因为其没有子节点，只需要更改其父节点的指针为空即可
2. 删除的节点有一个子节点，则只需直接让子节点代替自己的位置即可，即其父节点原本指向自己的指针，直接指向自己的子节点
3. 删除的节点有两个子节点，可以转化为**删除度为0或1的结点的问题**，根据树的定义，直接在**右子树中寻找最小的节点，或者左子树中寻找最大的节点替换该节点**即可，其中根据替换节点的情况分为 2 种:
    1. 替换节点为终端节点，对替换节点进行直接删除即可
    1. 替换节点有一个子节点，则直接让替换节点的子节点代替替换节点的位置即可

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152326723.png)

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152340051.png)

由于二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造： 

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152258360.png)

所以这样可能会导致查找效率变低。

## 平衡二叉树

平衡二叉树又称为 AVL 树，其是具有以下性质的二叉树：

1. 它的左子树和右子树都是平衡二叉树
2. 左子树和右子树的深度差的绝对值不超过1，若将节点的**平衡因子**定义为该节点的左子树减去右子树的深度差，则平衡因子只可能是 1，0，-1，只要平衡因子的绝对值大于1则该树就不是平衡的。

其插入过程与二叉排序树相同，**新插入的节点也一定是一个新添加的终端节点**，但是在插入节点之后可能会破坏树原有的平衡，可以通过自旋来实现，假设由于在二叉树上插入节点而导致最小子树的根节点失去平衡的节点为A，即A为离插入节点最近的一个平衡被破坏的节点，在插入一个新节点后，需要**从插入的位置沿向根的路径回溯，更新并检查各节点的平衡因子**， 如果在某一节点发现高度不平衡，停止回溯，**从发现不平衡的节点算起，沿刚才回溯的路径直接下两层的节点，**如果这三个节点处于一条直线上，则采用单旋进行平衡化。 **如果这三个节点处于一条折线上，则采用双旋转进行平衡化。**

**对于判断回溯的路径的三个节点是否处于一条直线**，则需判断从发现不平衡的节点算起，不平衡的节点与其回溯路径的前一节点平衡因子同符号（也就是正负号），则处于一条直线，否则为一条折线。

则失去平衡后的调整方式可以归纳为以下四点：

### 单向右旋

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162037880.webp)

由于在根节点的左子树的左节点上插入节点，也就是插入了 61，导致离插入节点最近的平衡被破坏的节点为 88，**这三个节点处于一条直线上，因为 88 平衡因子为 2 ，70 为 1 ，同符号且全部为正**，此时对 88 进行单向右旋处理，即一次向右的顺时针旋转操作。

更复杂的情况

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162044936.webp)

由于在根节点的左子树的左子树的左节点上插入节点，也就是插入了 BL 的子节点，回溯发现平衡被破坏的节点为 A，从 A 算起，**A、B、BL这三个节点处于一条直线上**，此时对 A 进行单向右旋处理，即一次向右的顺时针旋转操作。

### 单向左旋

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162057061.webp)

由于在根节点的右子树的右子树的右节点上插入节点，也就是插入了 120 的子节点，回溯发现平衡被破坏的节点为 88，**88、96、120 这三个节点处于一条直线上，同符号且全部为负**，此时对 88 进行单向右旋处理，即一次向左的逆时针旋转操作。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162059483.webp)

由于在根节点的右子树的右子树的右节点上插入节点，也就是插入了 BR 的子节点，导致离插入节点最近的平衡被破坏的节点为 A，**A、B、BR 这三个节点处于一条直线上**，此时对 A 进行单向右旋处理，即一次向左的逆时针旋转操作。

### 双向旋转LR

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162212775.png)

现有一棵AVL树，每个节点的平衡因子的绝对值 都没有超过1，所以该AVL是平衡的， 此时，我们新节点插入的位置有四种，分别为上述图中标出来的1、2、3、4这四个位置。

**当我们新节点插入的是3位置**

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162221051.png)

此时**由于A、B、E这三个节点不在一条直线上，平衡因子异号且为 2 和 -1，所以我们需要双旋转。先以中间节点 B 为旋转点，EB进行左单旋转**。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162222137.png)

**再以 A 为旋转点，EA 为轴进行右单旋转**

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162223490.png)

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162224817.png)

**当新节点插入的位置在4号位置时**

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162228776.png)

先右单旋转后左单旋转和先左后右旋转是一样的思路，平衡因子异号且为 -2 和 1。

### 平衡二叉树节点的删除

上述过程详细说明了平衡二叉树插入和调整的过程，下面进行删除和调整的操作

**当左子树上节点的删除相当于我们在右子树上插入了一个新节点，而右子树上节点的删除相当于在左子树上插入了一个新节点，根据这一点，我们进行判断并采取对应的平衡调整操作**

这里规定**根节点的左子树的高度减去右子树的高度为**根节点的平衡因子

平衡二叉树节点的删除过程与二叉排序树一致，不同点在于删除节点之后需要做平衡处理

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171614402.webp)



我们将上图中的节点7删除，可以发现这是一个叶子节点。我们直接删除。得到下面的二叉树。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171614546.webp)

然后在向根节点回溯并更新平衡因子时发现节点 20 不平衡，查看其平衡因子为 -2 ，那么可以得出导致不平衡的原因在于右子树，向右子树查找，发现 20 和 30 的平衡因子为 -2 与 1 不同号，则对节点 20 进行 RL 旋转

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171628339.webp)

 接下来进行左旋，得到下图，这就是调整后的树的形状。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171628567.webp)



在删除时还有一种特殊情况

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171630695.webp)

 我们将上图中节点8删除，得到下图：

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171630308.webp)



节点 25 和 30 的平衡因子分别为 -2 和 0，此时对节点 25 进行左旋即可

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171632699.webp)

## B-树 （B树）

B树和B-树在概念上是相同的，它们都是多路平衡搜索树，用于优化数据的存储和检索。在计算机科学文献中，B树和B-树通常指的是同一种数据结构，只是在不同的文献或上下文中可能会有不同的称呼。

 二叉查找树的结构

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162253969.png)

第1次磁盘IO：

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162253258.png)

第2次磁盘IO：

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162253044.png)

第3次磁盘IO：

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162253054.png)

第4次磁盘IO：

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162253492.png)

 **为了减少磁盘 IO 的次数,需要把原本 "瘦高" 的树结构变得 "矮胖" , 这就是B-树的特征之一**

一个3阶B-树

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205162254225.png)

B-树是一种平衡多路查找树，一颗 m 阶（ m 为每个节点上最大的子树数量，比如 4 阶的 B- 树的每个节点最多可以拥有 4 颗子树）的 B- 树需要满足：

1. 树中每个节点至多有 m 颗子树，也就是至多拥有 m-1 个关键字；
2. 如果根节点不是终端节点，则至少拥有两颗子树，也就是至少拥有一个关键字；
3. 除根节点之外的所有非终端节点至少有 m/2 颗子树；
4. 每个节点中的元素从小到大排列，其中元素之间的指针指向的子树正好是元素的值域划分；
5. 所有的终端节点都在最后一层，且不包含任何数据，可以看做是查询失败，实际上这些节点并不存在，指向这些节点的指针为空。

### B-树的插入

 B-树插入新节点的过程比较复杂，而且分成很多种情况。

假如我们要插入的值是4

自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171653388.png)

由于 B-树的规定，节点 3，5 已经是两元素节点，无法再增加。父亲节点  2， 6  也是两元素节点，也无法再增加， 根节点 9 是单元素节点，可以升级为两元素节点。于是**拆分**节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171654014.png)

就为了插入一个元素，让整个B-树的那么多节点都发生了连锁改变， 正因为如此，让B-树能够始终维持【多路平衡】。这也是B-树的一大优势：【自平衡】

### B-树的删除

删除元素 11， 自顶向下查找元素11的节点位置。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171655945.png)

删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。这个过程称为**左旋**。

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171656802.png)

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171656893.png)

B- 树主要应用于【文件系统】以及部分【数据库索引】，比如非关系型数据库 MongoDB，而大部分关系型数据库，比如Mysql，则使用 B+ 树作为【索引】

## B+ 树

B+树是 B- 树的变种，一颗 m 阶的B+树和m阶的 B- 树的差异在于

1. 有 n 颗子树的节点中包含了 n 个关键字。
2. 所有的终端节点中包含了全部关键字的信息，以及指向这些记录的指针，且终端节点本身依关键字大小自小到大顺序连接。
3. 所有的非终端节点可以看成是索引部分，节点中进含有其子树中最大或最小的关键字

![img](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205171703423.png)

卫星数据指的的是索引元素所指向的数据记录，比如数据库中的某一行，在B-树中，无论中间节点还是终端节点都带有卫星数据。

需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针

- B+树的中间节点没有卫星数据，所以同样大小的磁盘可以容纳更多的节点元素；
- 在数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询的IO次数也更少；
- B+树的查询必须最终查找到叶子节点，而B-树只要查找匹配的元素即可，无论匹配的元素处于中间节点还是叶子节点。
- B-树的查找性能并不稳定（最好情况只查询根节点，最坏情况是查找叶子节点）。而B+树的每一次查找都是稳定的。

## 红黑树

红黑树和AVL树都是自平衡的二叉搜索树，它们通过特定的旋转和颜色变化（红黑树）或节点旋转（AVL树）来保持树的平衡，从而保证查找、插入和删除操作的效率。尽管它们有相似之处，但它们在平衡策略和性能上存在一些区别：

1. **平衡策略**：
   - **AVL树**：AVL树是一种高度平衡的二叉搜索树。在AVL树中，任何节点的两个子树的高度最多相差1。这意味着AVL树在插入和删除操作后，需要通过旋转操作来保持这种严格的平衡状态。AVL树的平衡性保证了查找操作的效率非常高，因为树的高度被严格控制，最坏情况下查找操作的时间复杂度为O(log n)。
   - **红黑树**：红黑树是一种相对宽松平衡的二叉搜索树。在红黑树中，任何节点的两个子树的高度最多相差两倍。红黑树通过颜色标记和旋转操作来保持平衡，但不像AVL树那样严格。红黑树的平衡策略允许在插入和删除操作后，树的平衡性在一定范围内波动，但仍然保证了查找操作的效率。

2. **旋转操作**：
   - **AVL树**：AVL树在插入和删除操作后，可能需要进行多次旋转来保持平衡。这些旋转操作包括单旋转和双旋转。
   - **红黑树**：红黑树的旋转操作相对较少，通常只需要进行一次或两次旋转。红黑树的旋转操作通常比AVL树的旋转操作简单。

3. **插入和删除操作的性能**：
   - **AVL树**：由于AVL树的严格平衡性，插入和删除操作可能需要多次旋转，这可能导致AVL树在这些操作上比红黑树慢。
   - **红黑树**：红黑树的插入和删除操作通常比AVL树快，因为它们需要的旋转操作较少。

4. **应用场景**：
   - **AVL树**：AVL树适用于查找操作频繁，而插入和删除操作相对较少的场景。例如，它适合用于实现字典或数据库索引。
   - **红黑树**：红黑树适用于插入和删除操作频繁，而查找操作也相对频繁的场景。例如，它适合用于实现C++ STL中的`map`和`set`容器。

总的来说，AVL树提供了更快的查找速度，但插入和删除操作可能较慢；而红黑树在插入和删除操作上更快，但查找速度略逊于AVL树。在实际应用中，选择哪种树结构取决于具体的应用场景和性能需求。

[数据结构——红黑树 - 简书 (jianshu.com)](https://www.jianshu.com/p/eb6e3fa41c66)
