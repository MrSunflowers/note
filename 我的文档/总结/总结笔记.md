[TOC]
## sql 的执行顺序

form、where、group by…… having、聚合函数、select、order by

## G1垃圾回收器原理

从JDK9开始，G1作为服务端模式下的默认垃圾收集器，G1 也遵循分代收集理论，但其堆内存布局不再坚持固定大小以及固定数量的分代区域划分，而是把内存空间划分为多个独立的区域，每个区域都可以根据需要扮演新生代、survivor区或是老年代，收集器可以根据扮演的不同角色采取不同的收集方式，分区中海油一种特殊的Humongous区域专门存储大对象，G1认为只要对象大于一个分区的容量的一半就可判定为大对象，每个分区的大小可以通过虚拟机参数自定义设置，对于那种超过了一个分区大小的对象来说，将会被存放在N个连续的Humongous分区中，G1的大多数行为都把Humongous分区作为老年区的一部分来看待。G1将每个分区看做是最小的收集单元，每次收集到的内存空间都是基础分区的整数倍，G1会跟踪每个分区里面垃圾的回收价值，然后在后台维护一个优先级列表，每次根据允许的停顿时间优先处理收益最大的回收空间

## 双亲委派模式被破坏的情况下加载到重复的类如何处理

## oracle 中的表分区方式

范围分区、Hash分区、List分区、时间分区

## HashMap 中链表转为红黑树的条件

链表长度大于8且数组长度大于64

## HashMap 中 put 方法的整体流程

## HashMap 的负载因子为什么是 0.75

## java 中 io 底层的执行流程

## java 使用反射创建对象有几种方式

1. 使用反射的Class类的newInstance()方法：
2. 使用反射的Constructor类的newInstance()方法

## 获取Class类的四种方式

1. 调用运行时类的属性 Object.class
2. 通过运行时类的对象 调用 obj.getClass()
3. 调用Class的静态方法 Class.forName(String path)
4. 使用类的加载器 ClassLoader

## java 反射中 class.forName 与 classLoader 加载类的区别

Class.forName 会执行加载类中的静态代码块，并初始化类，classLoader 不会。加载顺序为父类的静态代码块先执行，子类的静态代码块后执行，new 的时候执行构造方法。

## Spring MVC 中获取参数的注解

## 一级索引和二级索引

[(37条消息) MySQL的一级索引和二级索引介绍_无趣的人民艺术家的博客-CSDN博客_一级索引和二级索引](https://blog.csdn.net/weixin_43606861/article/details/116202806)

## oracle 中的存储引擎有几种

## 假如HashCode为200，HashMap 中如何计算要存放数组的位置

## 索引的最左匹配原则

[(37条消息) 联合索引最左匹配原则_Torey_Li的博客-CSDN博客_联合索引最左原则](https://blog.csdn.net/Torey_Li/article/details/115033373?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-115033373-null-null.pc_agg_new_rank&utm_term=where索引最左匹配原则&spm=1000.2123.3001.4430)

## Spring中默认的事物传播机制

[(37条消息) spring事务传播机制_钧令的博客-CSDN博客_spring事务的传播机制](https://blog.csdn.net/qq_44956318/article/details/119110150)

## ArrayList、Hashtable、HashMap初始化大小

- ArrayList初始化n=10个空间扩容(n3)/2 + 1,如果不够设置传入的值
- HashMap初始化n=16空间扩容2n,在并发环境下，可能会形成环状链表（扩容时可能造成）
- Hashtable初始化n=11空间扩容2n+1
- jdk1.6ConcurrentHashMap初始化segments=16个空间每个segments是初始化一个HashEntry 扩容segments=n2
- jdk1.7ConcurrentHashMap初始化segments=16个空间每个segments是初始化两个HashEntry 扩容segments=n*2
  

[(37条消息) HashTable和HashMap的默认大小_symop的博客-CSDN博客_hashtable默认长度](https://blog.csdn.net/weixin_40757126/article/details/106011601?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106011601-blog-84501027.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106011601-blog-84501027.pc_relevant_paycolumn_v3&utm_relevant_index=1)

## redis 缓存击穿处理方案

分布式锁，保证一次只能有一个请求访问数据库，并更新缓存，其他请求只能等待该请求完成响应后，直接访问缓存数据。

[(37条消息) redis缓存数据更新问题 - CSDN](https://www.csdn.net/tags/Mtzakg5sMDAzNjgtYmxvZwO0O0OO0O0O.html)

[(37条消息) REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案_有啥不一样的博客-CSDN博客_redis缓存击穿怎么解决](https://blog.csdn.net/soulweee/article/details/119179214)

## 关于Zookeeper来实现分布式锁的几个问题

[(37条消息) 关于Zookeeper来实现分布式锁的几个问题_wh柒八九的博客-CSDN博客_zookeeper 分布式锁的问题](https://blog.csdn.net/qq_31960623/article/details/119057082?utm_term=zookeeper做分布式锁问题&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-119057082-null-null&spm=3001.4430)
