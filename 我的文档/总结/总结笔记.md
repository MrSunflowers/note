[TOC]

# 数据库

## sql 的执行顺序

form、where、group by…… having、聚合函数、select、order by

## oracle 中的表分区方式

范围分区、Hash分区、List分区、时间分区

## 一级索引和二级索引

一级索引：索引与索引的数据存储在一起，都存储在同一个 B+tree 中的叶子节点，通过定位索引就直接可以查找到数据，一般主键索引都是一级索引

二级索引：二级索引的叶子节点存储的是**主键**而不是数据。也就是说，在找到索引后，需要得到对应的主键，再回到一级索引中找主键对应的数据记录。

一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。

二级索引存储主键值而不是存储数据，当数据需要更新的时候，二级索引不需要修改，只需要修改一级索引，一个表只能有一个一级索引，其他的都是二级索引，这样只需要修改一级索引就可以了，不需要重新构建二级索引

[(37条消息) MySQL的一级索引和二级索引介绍_无趣的人民艺术家的博客-CSDN博客_一级索引和二级索引](https://blog.csdn.net/weixin_43606861/article/details/116202806)

## 索引的最左匹配原则

在MySQL中，索引是以 B+Tree 的形式存在的，它是 B_Tree 的变体，其定义基本与 B_Tree 相同，下图就是B+Tree的数据结构，图中非叶子节点，蓝色部分代表索引，黄色部分代表指向下一个节点的指针，叶子节点则代表实际保存的数据。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205071508253.png)

B+树与B树主要存在以下区别

- 非叶子节点的子树指针与关键字个数相同

- 非叶子节点的子树指针P[i]，指向关键字值[K[i], K[i+1]）的子树
- **非叶子节点仅用来索引，数据都保存在叶子节点中**。
- **所有叶子节点具有一个链表指针指向下一个叶子节点，形成一个链表结构**
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是**最大**（或**最小**）元素，上图就是在子节点元素中最小，这个与我们具体定义的规则有关。

如果是联合索引



## mysql 的可重复读是如何实现的

# JVM

## G1垃圾回收器原理

从JDK9开始，G1作为服务端模式下的默认垃圾收集器，G1 也遵循分代收集理论，但其堆内存布局不再坚持固定大小以及固定数量的分代区域划分，而是把内存空间划分为多个独立的区域，每个区域都可以根据需要扮演新生代、survivor区或是老年代，收集器可以根据扮演的不同角色采取不同的收集方式，分区中海油一种特殊的Humongous区域专门存储大对象，G1认为只要对象大于一个分区的容量的一半就可判定为大对象，每个分区的大小可以通过虚拟机参数自定义设置，对于那种超过了一个分区大小的对象来说，将会被存放在N个连续的Humongous分区中，G1的大多数行为都把Humongous分区作为老年区的一部分来看待。G1将每个分区看做是最小的收集单元，每次收集到的内存空间都是基础分区的整数倍，G1会跟踪每个分区里面垃圾的回收价值，然后在后台维护一个优先级列表，每次根据允许的停顿时间优先处理收益最大的回收空间

## 双亲委派模式被破坏的情况下加载到重复的类如何处理

- 比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则必定不相等

  所以在双亲委派模式被破坏的情况下加载到重复的类，两个类会同时存在，并相互隔离，但不相等

## 锁的膨胀

轻量级锁和偏向锁都是为了解决无竞争情况下的优化问题

当轻量级锁出现两个线程以上争用一个锁的时候会膨胀为重量级锁，后面等待的线程也就必须进入阻塞状态

偏向锁一旦出现另外的线程去尝试获取这个锁的情况，会立即结束偏向模式，并根据锁对象目前是否处于被锁定的状态决定是否撤销偏向，撤销后恢复至未锁定或轻量级锁定状态，后续就会按照轻量级锁一样执行。

在java中一旦某个对象计算过哈希码，就应该一直保持不变(不强制)，否则很多依赖哈希码的java aip都可能存在出错风险，而作为大多数对象哈希码来源的 Object::hashCode() 方法，返回的是对象的一致性哈希码，这个值是存储在对象头中的，用来保证它的不变性，所以当一个对象已经经过一致性哈希码的计算后，就再也无法进入偏向状态了，而当一个偏向状态的对象在接收到计算一致性哈希码的请求后，它的偏向状态会立即取消，并膨胀为重量级锁。

这里的计算一致性哈希码的请求指的是 Object::hashCode() 和 System::identityHashCode(Object) 方法的调用，如果重写了对象的 hashCode 方法，则并不会产生此请求。



# 集合框架

## HashMap 中链表转为红黑树的条件

链表长度大于8且数组长度大于64

## HashMap 中 put 方法的整体流程

## HashMap 的负载因子为什么是 0.75

## 假如HashCode为200，HashMap 中如何计算要存放数组的位置

## ArrayList、Hashtable、HashMap初始化大小

- ArrayList初始化n=10个空间扩容(n3)/2 + 1,如果不够设置传入的值
- HashMap初始化n=16空间扩容2n,在并发环境下，可能会形成环状链表（扩容时可能造成）
- Hashtable初始化n=11空间扩容2n+1
- jdk1.6ConcurrentHashMap初始化segments=16个空间每个segments是初始化一个HashEntry 扩容segments=n2
- jdk1.7ConcurrentHashMap初始化segments=16个空间每个segments是初始化两个HashEntry 扩容segments=n*2


# java io

## java 中 io 底层的执行流程

# java 反射

## java 使用反射创建对象有几种方式

1. 使用反射的Class类的newInstance()方法：
2. 使用反射的Constructor类的newInstance()方法

## 获取Class类的四种方式

1. 调用运行时类的属性 Object.class
2. 通过运行时类的对象 调用 obj.getClass()
3. 调用Class的静态方法 Class.forName(String path)
4. 使用类的加载器 ClassLoader

## java 反射中 class.forName 与 classLoader 加载类的区别

Class.forName 会执行加载类中的静态代码块，并初始化类，classLoader 不会。加载顺序为父类的静态代码块先执行，子类的静态代码块后执行，new 的时候执行构造方法。

# Spring MVC

## Spring MVC 中获取参数的注解

# Spring

## Spring中默认的事物传播机制

[(37条消息) spring事务传播机制_钧令的博客-CSDN博客_spring事务的传播机制](https://blog.csdn.net/qq_44956318/article/details/119110150)



[(37条消息) HashTable和HashMap的默认大小_symop的博客-CSDN博客_hashtable默认长度](https://blog.csdn.net/weixin_40757126/article/details/106011601?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106011601-blog-84501027.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106011601-blog-84501027.pc_relevant_paycolumn_v3&utm_relevant_index=1)

# redis

## redis 缓存击穿处理方案

分布式锁，保证一次只能有一个请求访问数据库，并更新缓存，其他请求只能等待该请求完成响应后，直接访问缓存数据。

[(37条消息) redis缓存数据更新问题 - CSDN](https://www.csdn.net/tags/Mtzakg5sMDAzNjgtYmxvZwO0O0OO0O0O.html)

[(37条消息) REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案_有啥不一样的博客-CSDN博客_redis缓存击穿怎么解决](https://blog.csdn.net/soulweee/article/details/119179214)

# Zookeeper

## 关于Zookeeper来实现分布式锁的几个问题

[(37条消息) 关于Zookeeper来实现分布式锁的几个问题_wh柒八九的博客-CSDN博客_zookeeper 分布式锁的问题](https://blog.csdn.net/qq_31960623/article/details/119057082?utm_term=zookeeper做分布式锁问题&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-119057082-null-null&spm=3001.4430)
