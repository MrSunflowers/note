[TOC]

# 数据库

## sql 的执行顺序

form、where、group by…… having、聚合函数、select、order by

## oracle 中的表分区方式

范围分区、Hash分区、List分区、时间分区

## 一级索引和二级索引

一级索引：索引与索引的数据存储在一起，都存储在同一个 B+tree 中的叶子节点，通过定位索引就直接可以查找到数据，一般主键索引都是一级索引

二级索引：二级索引的叶子节点存储的是**主键**而不是数据。也就是说，在找到索引后，需要得到对应的主键，再回到一级索引中找主键对应的数据记录。

一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。

二级索引存储主键值而不是存储数据，当数据需要更新的时候，二级索引不需要修改，只需要修改一级索引，一个表只能有一个一级索引，其他的都是二级索引，这样只需要修改一级索引就可以了，不需要重新构建二级索引

[(37条消息) MySQL的一级索引和二级索引介绍_无趣的人民艺术家的博客-CSDN博客_一级索引和二级索引](https://blog.csdn.net/weixin_43606861/article/details/116202806)

## 索引的最左匹配原则

在MySQL中，索引是以 B+Tree 的形式存在的，它是 B_Tree 的变体，其定义基本与 B_Tree 相同，下图就是B+Tree的数据结构，图中非叶子节点，蓝色部分代表索引，黄色部分代表指向下一个节点的指针，叶子节点则代表实际保存的数据。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205071508253.png)

B+树与B树主要存在以下区别

- 非叶子节点的子树指针与关键字个数相同

- 非叶子节点的子树指针P[i]，指向关键字值[K[i], K[i+1]）的子树
- **非叶子节点仅用来索引，数据都保存在叶子节点中**。
- **所有叶子节点具有一个链表指针指向下一个叶子节点，形成一个链表结构**
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是**最大**（或**最小**）元素，上图就是在子节点元素中最小，这个与我们具体定义的规则有关。

如果是联合索引，当建立联合索引时，联合索引当然还是一颗B+树，比如建立一个联合索引(a, b),那么它的索引结构应该是这样的。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205072115193.png)



a索引：1，1，2，2，3，3

b索引：1，2，1，4，1，2

通过观察可以发现，在联合索引中，对于a索引来说，索引是有序排列的，对于b索引是无序排列的。**同时还可以发现对于a值相等的情况下，b值也是有序的。**

这种有序是相对的，a>1 and b=4 遇到这种范围查询，就不会再去走索引，这种情况下a值可以走索引，而b值在这个范围内是无序的，所以最终也不会走索引。

那么就基本可以得出最左匹配原则的定义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like) 就会停止匹配

例如建立一个索引

```sql
INDEX score_age_index (`score`, `age`)
```

**对于全值匹配来说**

```sql
select name from tb_student where age=20 and score=90;
```

查询会走索引，虽然定义索引的顺序是(score, age)，mysql 可以进行优化，自动帮我们改变顺序。

**对于单值来说**

```sql
select name from tb_student where score=90;
```

也是会走索引的，但是下面

```sql
select name from tb_student where age=19;
```

是不会走索引的，因为它并没有从最左连续匹配

**对于字符串类型来说**

它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。

```sql
select * from tb_student  where a like 'As%'; //前缀都是排好序的，走索引查询
select * from tb_student  where  a like '%As'//全表查询
select * from tb_student  where  a like '%As%'//全表查询
```

**对于范围值来说**

可以对左边的列进行范围查询，结果是一定会走索引的。

```sql
select name from tb_student where score > 60 and score < 90;
```

多个列同时进行范围查找时，只有对索引左边的那个列进行范围查找才用到B+树索引，也就是只有score用到了索引，在90>score>60的情况下，age是无序的，不能用索引，找到90>score>60的记录后，只能根据条件 age>20 继续逐条过滤.

**对于精确匹配某一列并范围匹配另一列**

如果左边的列是精确查找的，右边的列可以进行范围查找，因为如果score=90，age是有序的

**排序**

```sql
select name from tb_student order by score,age;
```

因为b+树索引本身就是按照上述规则排序的，order by的子句后面的顺序也必须按照索引列的顺序给出，就会走索引。如果数据库中的数据量过小的时候，mysql数据库会自动为我们做优化，它会认为全表扫描要比索引更快，所以就采用全表扫描方式。

```sql
explain select name from tb_student order by age,score;
```

列的顺序反过来就不会走索引

如果最左边列的值是定值，则对其他列顺序排序是可以用到索引的。

## mysql 的可重复读是如何实现的

InnoDB 里面每个事务都有一个唯一的事务 ID，叫作 transaction id。它在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。而表中的每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

表中的每行记录在更新的时候都会同时记录一条 undo log，这条 log 就会记录上当前事务的 transaction id，记为 row trx_id。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

在可重复读隔离级别下，一个事务在启动时，InnoDB 会为事务构造一个数组，用来保存这个事务启动瞬间，当前**正在”活跃“的所有事务ID**。”活跃“指的是，启动了但还没提交的事务。

这个数组里面事务 ID 为最小值记为低水位，**当前系统里面已经创建过的事务 ID 的最大值**加 1 记为高水位。

这个视图数组把所有的 row trx_id 分成了几种不同的情况。

- 如果当前读到的这行数据的 trx_id 小于低水位，表示这个版本的数据在当前事务启动前已经提交，是安全的，可见
- 如果当前读到的这行数据的 trx_id 大于高水位，表示这个版本的数据是在当前事务启动后生成的，不可见
- 如果当前读到的这行数据的 trx_id 大于低水位，小于高水位，分为两种情况
  - 如果当前读到的这行数据的 trx_id 在数组中，表示这个版本在当前事务启动时还未提交，不可见
  - 如果当前读到的这行数据的 trx_id 不在数组中，表示这个版本在当前事务启动时已经提交，可见

假设事务A, B, C 的 trx_id 分别为 100, 101, 102。事务 A 开始前活跃的事务 ID 只有 99，并且 id=1 这一行数据的 trx_id=90，数据 K = 1。假设 A,B,C 按顺序启动，得出事务启动瞬间的视图数组：事务A：[99, 100]，事务B：[99, 100, 101]，事务C：[99, 100, 101, 102]。此时进行如下操作：

1. 事务C通过更新语句，把 k 更新为 2，此时trx_id=102；
2. 事务B通过更新语句，把 k 更新为 3，此时trx_id=101；
3. 事务B通过查询语句，查询到最新一条记录为3，trx_id=101，满足隔离条件，返回 k=3；
4. 事务A通过查询语句：
   1. 查询到最新一条记录为3，trx_id=101，比高水位大，不可见；
   2. 通过 undo log，找到上一个历史版本，trx_id=102，比高水位大，还是不可见；
   3. 继续找上一个历史版本，trx_id=90，比低水位小，可见。

也就是说**事务B更新的时候是能看到事务C的修改的**

如果事务B在更新的看不到事务C的修改就会出问题：

1. 事务B查询到最新一条记录为2，trx_id=102，比高水位大，不可见；
2. 通过 undo log，找到上一个版本，trx_id=90，比低水位小，可见；
3. 返回记录 k=1，执行 k=k+1，把 k 更新为2，此时 trx_id=101。

此时事务B覆盖了事务C的更新，所以，InnoDB在更新时运用一条规则：**更新数据都是先读后写的，而这个读，只能读当前最新的值，称为“当前读“ （current read）**，因此，事务B在更新时要拿到最新的数据，在此基础上做更新。紧接着，事务B在读取的时候，查询到最新的记录为3， trx_id=101 为当前事务ID，可见

再假设另一种情况：

事务B在更新之后，事务C紧接着更新，事务B回滚了，事务C成功提交

如果按照当前读的定义，会发生以下事故，假设当前 K=1：

1. 事务B把 k 更新为 2；
2. 事务C读取到当前最新值，k=2，更新为3；
3. 事务B回滚；
4. 事务C提交。

这时候，事务C发现自己想要执行的是 +1 操作，结果变成了 ”+2“ 操作。

InnoDB 肯定不允许这种情况的发生，因此事务B在执行更新语句时，会给该行加上行锁，直到事务B结束，才会释放这个锁。

小结

1. InnoDB 的行数据有多个版本，每个版本都有 row trx_id。
2. 事务根据 undo log 和 trx_id 构建出满足当前隔离级别的一致性视图。
3. 可重复读的核心是一致性读，而事务更新数据的时候，只能使用当前读，如果当前记录的行锁被其他事务占用，就需要进入锁等待。

## 怎样避免数据库死锁



1，尽量不要在一个事务中实现过于复杂的查询或更新操作。原因很简单，越是复杂的数据库操作，占用数据库资源的时间越长，引发死锁的可能性越大。

2，尽量不要在数据库事务中要求用户响应。原因同1，这也会导致事务长时间无法结束，浪费数据库资料。

3，死锁是由于并发访问数据库资源造成的，减少死锁就应该限制应用系统的并发访问量。我们应该合理设置后台服务的线程数，将大量数据的操作分解，分步骤，分阶段的执行。也应该避免在用户量大的时候大规模的进行后台数据库操作，应该将大规模的数据库操作放在用户量最少的时候进行。

4，尽可能以分区表或分区视图的方式拆分包含大量数据的表，将它们保存在不同的物量磁盘和文件组中。在访问数据时，可以分散访问保存在不同分区的数据，从而减少因为在大型表中放置锁而造成其它事务长时间等待的概率。

5，尽量避免使用占用很长的复杂查询,在条件允许的情况下应该尽量使用分页查询或缩小结果集的方式。因为复杂查询会长时间占用数据库资源，增加发生死锁的概率。

6，尽可能使用较低的隔离级别，如READ UNCOMMITTED，因为隔离级别低时，事务之间相互等待的情况会减少，这样每个事务都会尽可能快地完成数据库操作，然后释放其拥有的锁资源，这样就会降低出现锁等待或死锁的概率。当然，用户在设计数据库应用程序时，需要考虑如何解决事务中数据不一致的情况。

7，应该注意统一访问表的顺序，尽量避免有的事务先查询表A然后更新表B，而有的事务先查询表B再更新表A的情况。

8，如果一个事务中只进行读取数据的操作，则可以在该事务中使用快照(SNAPSHOT)隔离级别。因为在快照隔离级别中，数据库引擎不会阻塞其他事务对当前事务所占用资源的修改操作，当前事务会认为它所拥有的资源没有被修改过（实际上它所拥有的资源是一个快照）。这样就可以减少因为等待资源而产生死锁的情况。

[(37条消息) 数据库常见死锁原因及处理_zxcodestudy的博客-CSDN博客_数据库的死锁](https://blog.csdn.net/qq_16681169/article/details/74784193?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~default-1-74784193-blog-105745720.pc_relevant_without_ctrlist_v4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~default-1-74784193-blog-105745720.pc_relevant_without_ctrlist_v4&utm_relevant_index=1)

# JVM

## G1垃圾回收器原理

从JDK9开始，G1作为服务端模式下的默认垃圾收集器，G1 也遵循分代收集理论，但其堆内存布局不再坚持固定大小以及固定数量的分代区域划分，而是把内存空间划分为多个独立的区域，每个区域都可以根据需要扮演新生代、survivor区或是老年代，收集器可以根据扮演的不同角色采取不同的收集方式，分区中海油一种特殊的Humongous区域专门存储大对象，G1认为只要对象大于一个分区的容量的一半就可判定为大对象，每个分区的大小可以通过虚拟机参数自定义设置，对于那种超过了一个分区大小的对象来说，将会被存放在N个连续的Humongous分区中，G1的大多数行为都把Humongous分区作为老年区的一部分来看待。G1将每个分区看做是最小的收集单元，每次收集到的内存空间都是基础分区的整数倍，G1会跟踪每个分区里面垃圾的回收价值，然后在后台维护一个优先级列表，每次根据允许的停顿时间优先处理收益最大的回收空间

## 双亲委派模式被破坏的情况下加载到重复的类如何处理

- 比较两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则必定不相等

  所以在双亲委派模式被破坏的情况下加载到重复的类，两个类会同时存在，并相互隔离，但不相等

## 锁的膨胀

轻量级锁和偏向锁都是为了解决无竞争情况下的优化问题

当轻量级锁出现两个线程以上争用一个锁的时候会膨胀为重量级锁，后面等待的线程也就必须进入阻塞状态

偏向锁一旦出现另外的线程去尝试获取这个锁的情况，会立即结束偏向模式，并根据锁对象目前是否处于被锁定的状态决定是否撤销偏向，撤销后恢复至未锁定或轻量级锁定状态，后续就会按照轻量级锁一样执行。

在java中一旦某个对象计算过哈希码，就应该一直保持不变(不强制)，否则很多依赖哈希码的java aip都可能存在出错风险，而作为大多数对象哈希码来源的 Object::hashCode() 方法，返回的是对象的一致性哈希码，这个值是存储在对象头中的，用来保证它的不变性，所以当一个对象已经经过一致性哈希码的计算后，就再也无法进入偏向状态了，而当一个偏向状态的对象在接收到计算一致性哈希码的请求后，它的偏向状态会立即取消，并膨胀为重量级锁。

这里的计算一致性哈希码的请求指的是 Object::hashCode() 和 System::identityHashCode(Object) 方法的调用，如果重写了对象的 hashCode 方法，则并不会产生此请求。



# 集合框架

## HashMap 中链表转为红黑树的条件

链表长度大于8且数组长度大于64

## HashMap 中 put 方法的整体流程

## HashMap 的负载因子为什么是 0.75

## 假如HashCode为200，HashMap 中如何计算要存放数组的位置

## ArrayList、Hashtable、HashMap初始化大小

- ArrayList初始化n=10个空间扩容(n3)/2 + 1,如果不够设置传入的值

- HashMap初始化n=16空间扩容2n,在并发环境下，可能会形成环状链表（扩容时可能造成）

- Hashtable初始化n=11空间扩容2n+1

- jdk1.6ConcurrentHashMap初始化segments=16个空间每个segments是初始化一个HashEntry 扩容segments=n2

- jdk1.7ConcurrentHashMap初始化segments=16个空间每个segments是初始化两个HashEntry 扩容segments=n*2

  

  [(37条消息) HashTable和HashMap的默认大小_symop的博客-CSDN博客_hashtable默认长度](https://blog.csdn.net/weixin_40757126/article/details/106011601?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106011601-blog-84501027.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106011601-blog-84501027.pc_relevant_paycolumn_v3&utm_relevant_index=1)


# java io

## java 中 io 底层的执行流程

[深入理解javaio读写原理及底层流程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/442239987)

# java 反射

## java 使用反射创建对象有几种方式

1. 使用反射的Class类的newInstance()方法：
2. 使用反射的Constructor类的newInstance()方法

## 获取Class类的四种方式

1. 调用运行时类的属性 Object.class
2. 通过运行时类的对象 调用 obj.getClass()
3. 调用Class的静态方法 Class.forName(String path)
4. 使用类的加载器 ClassLoader

## java 反射中 class.forName 与 classLoader 加载类的区别

Class.forName 会执行加载类中的静态代码块，并初始化类，classLoader 不会。加载顺序为父类的静态代码块先执行，子类的静态代码块后执行，new 的时候执行构造方法。

# Spring MVC

## Spring MVC 中获取参数的注解

# Spring

## Spring中默认的事物传播机制

[(37条消息) spring事务传播机制_钧令的博客-CSDN博客_spring事务的传播机制](https://blog.csdn.net/qq_44956318/article/details/119110150)



# redis

## redis 缓存击穿处理方案

分布式锁，保证一次只能有一个请求访问数据库，并更新缓存，其他请求只能等待该请求完成响应后，直接访问缓存数据。

[(37条消息) redis缓存数据更新问题 - CSDN](https://www.csdn.net/tags/Mtzakg5sMDAzNjgtYmxvZwO0O0OO0O0O.html)

[(37条消息) REDIS缓存穿透，缓存击穿，缓存雪崩原因+解决方案_有啥不一样的博客-CSDN博客_redis缓存击穿怎么解决](https://blog.csdn.net/soulweee/article/details/119179214)

## 高并发 redis 和数据库双写情况下，如何保证数据的一致性

通过MQ消息队列，更新数据库后使用消息队列更新缓存

# Zookeeper

## 关于Zookeeper来实现分布式锁的几个问题

[(37条消息) 关于Zookeeper来实现分布式锁的几个问题_wh柒八九的博客-CSDN博客_zookeeper 分布式锁的问题](https://blog.csdn.net/qq_31960623/article/details/119057082?utm_term=zookeeper做分布式锁问题&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-119057082-null-null&spm=3001.4430)
