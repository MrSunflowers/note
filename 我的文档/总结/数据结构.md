# 树

树是一种拥有N个节点的有限数据集，在任意一颗非空树中：

1. 有且仅有一个根节点
2. 当N>1时，其余节点可分为多个互不相交的子树

树中的每个节点存储了该节点的数据和指向其子树的指针，该节点拥有的子树的数量称为节点的**度**，度为0的节点称为**叶子节点**或**终端节点**，度不为0的节点称为**非终端节点**或**分支节点**，节点的层次从根节点开始算起，根节点为第一层，根节点的孩子节点为第二层，树中节点的最大层次称为树的**深度**或**高度**，如果树中节点的各个子树从左至右是有顺序的（即不能互换的），则该树称为有序树，否则称为无序树。

## 二叉树

二叉树的特点是每个节点至多只能存在两颗子树，即二叉树中不存在度大于2的节点，二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树需要满足：

1. 在二叉树的第n层上，至多有2的n-1次幂个节点
2. 深度为K的二叉树至多有2的K次幂-1个节点
3. 对于任意一颗二叉树，如果其终端节点数为N1，度为2的节点数为N2，则N1 = N2 +1 

一颗深度为K且有2的K次幂 -1 个节点二叉树称为**满二叉树**，可以对满二叉树的节点进行连续编号，自上而下，从左到右，当且仅当其每一个节点都与编号一一对应时，称为**完全二叉树**。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152005279.png)

### 遍历二叉树

先序遍历：

先访问根节点，先序遍历左子树，先序遍历右子树

中序遍历：

中序遍历左子树，访问根节点，中序遍历右子树

后序遍历：

后序遍历左子树，后序遍历右子树，访问根节点。

除了上述遍历方法外，还可以从上到下，从左至右进行遍历。可以看出，无论是通过什么方式进行遍历操作，实质上都是按一定规则将二叉树中的节点排列成一个线性序列的过程。

但是，当以二叉链表的形式存储树时，每个节点中只存储了节点的左右孩子信息，而不能直接得到该节点需要遍历的下一个节点是谁，一个最简单的解决方法是在每个节点中增加两个指针 fow 和 bkwd，分别指示在任意一次遍历时得到的前驱和后继信息，另一方面，在有N个节点的二叉链表中本身就存在N+1个空指针，由此设想能否利用这些空链来存放信息，相当于**把一棵二叉树变成一个双向链表**。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152041858.jpeg)

## 赫夫曼树

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

```
WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3
```

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152050663.png)

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

### 构建哈夫曼树的过程

对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152056271.png)

图中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。

## 二叉排序树

二叉排序树：

左子树上所有的节点均小于其根节点的值，右子树上所有的节点均大于根节点的值，其左子树和右子树也分别为二叉排序树。

二叉排序树即二叉查找树，根据定义可见，其查找过程类似于二分查找，首先将给定的值与根节点比较，若相等则查找结束，否则根据大小关系，分别在左子树或右子树中查找。

### 二叉排序树的插入

二叉排序树是一种动态树表，其树的结构通常是在查找的过程中，当树中不存在关键字是进行插入，新插入的节点一定是一个新添加的叶子节点，而且是查找不成功时查找路径上访问的最后一个节点的左孩子或者是右孩子节点。

也就是说中序遍历二叉查找树可以得到一个关键字的有序序列，一个无序序列可以通过构造一个二叉查找树变成一个有序序列，构造的过程就是排序过程。不仅如此，每次插入的新节点都是叶子节点，则在插入节点时，仅需改动某个节点的指针，由空变为非空即可。

### 二叉排序树的删除

删除一个节点相当于删除有序序列中的一个元素，分为以下几种情况：

1. 删除的节点为叶子节点，因为其没有子节点，只需要更改其父节点的指针为空即可
2. 删除的节点有一个子节点，则只需使其子节直接变为父节点的左节点或右节点即可，也就是直接让子节点代替自己
3. 删除的节点有两个子节点，直接在右子树中寻找最小的节点替换该节点即可，若最小节点有还有右子树，则用其子节点直接代替最小节点

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152326723.png)

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152340051.png)

由于二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造： 

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/images/202205152258360.png)

所以这样可能会导致查找效率变低。

## 平衡二叉树

平衡二叉树又称为 AVL 树，其是具有以下性质的二叉树：

1. 它的左子树和右子树都是平衡二叉树
2. 左子树和右子树的深度差不超过1，若将节点的**平衡因子**定义为该节点的左子树减去右子树的深度差，则平衡因子只可能是1，0，-1，只要平衡因子的绝对值大于1则该树就不是平衡的。

