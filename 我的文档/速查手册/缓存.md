# Redis

## Redis 的数据类型

以下是 Redis 支持的主要数据类型：

1. **字符串（String）**：
   - 最基本的数据类型。
   - 可以包含任何数据，比如JPEG图像或序列化的Ruby对象。
   - 字符串值最大可以是512MB。

2. **哈希（Hash）**：
   - 键值对的集合。
   - 适合存储对象。
   - 例如，可以存储用户信息，其中键是字段名，值是字段值。

3. **列表（List）**：
   - 字符串列表，按插入顺序排序。
   - 可以添加、移除元素。
   - 支持列表操作，如从两端弹出元素、获取子列表等。

4. **集合（Set）**：
   - 不重复的字符串集合。
   - 支持集合操作，如并集、交集、差集等。
   - 可以用于实现如标签系统、推荐系统等。

5. **有序集合（Sorted Set 也叫 ZSet）**：
   - 类似于集合，但每个元素都会关联一个浮点数分数。
   - 元素按分数排序，但也可以按字典顺序排序。
   - 适用于排行榜、优先级队列等场景。

其他高级数据类型：

1. **位图（Bitmap）**：
   - 字符串数据类型的一种扩展，可以对字符串的位进行操作。
   - 适合实现简单的状态存储，如用户签到、活跃状态等。

2. **超日志（HyperLogLog）**：
   - 用于估计集合中元素数量的概率数据结构。
   - 非常节省内存，但不精确。

3. **地理空间索引（Geo）**：
   - 用于存储地理位置信息，并对这些信息进行操作。
   - 支持计算两个位置之间的距离、查询某个范围内的位置等。

4. **流（Streams）**：
   - 用于实现消息队列的数据类型。
   - 提供了持久化消息队列的功能，支持多个消费者和消息分组。


## 常用命令

**字符串（String）**
- `SET key value`：设置指定 key 的值
- `GET key`：获取指定 key 的值
- `DEL key`：删除指定 key
- `INCR key`：将 key 中存储的数字值增一
- `DECR key`：将 key 中存储的数字值减一
- `INCRBY key increment`：将 key 所储存的值加上给定的增量
- `DECRBY key decrement`：将 key 所储存的值减去给定的减量

**哈希（Hash）**
- `HSET key field value`：将哈希表 key 中的字段 field 的值设为 value
- `HGET key field`：获取存储在哈希表中指定字段的值
- `HDEL key field [field ...]`：删除一个或多个哈希表字段
- `HGETALL key`：获取在哈希表中指定 key 的所有字段和值
- `HINCRBY key field increment`：为哈希表 key 中的指定字段的整数值加上增量 increment

**列表（List）**
- `LPUSH key value [value ...]`：将一个或多个值插入到列表头部
- `RPUSH key value [value ...]`：将一个或多个值插入到列表尾部
- `LRANGE key start stop`：获取列表指定范围内的元素
- `LPOP key`：移除并获取列表的第一个元素
- `RPOP key`：移除并获取列表的最后一个元素
- `LLEN key`：获取列表长度

**集合（Set）**
- `SADD key member [member ...]`：向集合添加一个或多个成员
- `SMEMBERS key`：获取集合中的所有成员
- `SREM key member [member ...]`：移除集合中一个或多个成员
- `SISMEMBER key member`：判断 member 元素是否是集合 key 的成员
- `SCARD key`：获取集合的成员数

**有序集合（Sorted Set）**
- `ZADD key score member [score member ...]`：向有序集合添加一个或多个成员
- `ZRANGE key start stop [WITHSCORES]`：通过索引区间返回有序集合成指定区间内的成员
- `ZREM key member [member ...]`：移除有序集合中的一个或多个成员
- `ZSCORE key member`：获取有序集合中成员的分数值
- `ZCARD key`：获取有序集合的成员数

**位图（Bitmap）**
- `SETBIT key offset value`：对 key 所储存的字符串值，设置或清除指定偏移量上的位
- `GETBIT key offset`：对 key 所储存的字符串值，获取指定偏移量上的位
- `BITOP operation destkey key [key ...]`：对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上

**超日志（HyperLogLog）**
- `PFADD key element [element ...]`：添加指定元素到 HyperLogLog 中
- `PFCOUNT key [key ...]`：返回给定 HyperLogLog 的基数估算值
- `PFMERGE destkey sourcekey [sourcekey ...]`：将多个 HyperLogLog 合并为一个 HyperLogLog

**地理空间索引（Geo）**
- `GEOADD key longitude latitude member [longitude latitude member ...]`：将指定的地理空间位置（经度和纬度）添加到指定的 key 中
- `GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]`：根据给定的经纬度坐标来获取指定范围内的地理位置集合
- `GEOPOS key member [member ...]`：从给定的 key 里返回所有指定 member 的位置（经度和纬度）

**流（Streams）**
- `XADD key ID field value [field value ...]`：向流追加数据
- `XLEN key`：获取流的长度
- `XRANGE key start end [COUNT count]`：获取流中指定范围的元素
- `XREVRANGE key end start [COUNT count]`：获取流中指定范围的元素，但顺序是反的
- `XDEL key ID [ID ...]`：删除流中的指定元素


## 设置已存在的 key 的过期时间

在Redis中，`EXPIRE`命令和`PERSIST`命令分别用于设置和取消设置键（key）的过期时间。以下是这两个命令的详细说明和使用示例：


### EXPIRE命令

`EXPIRE`命令用于设置键的过期时间，单位是秒。一旦键过期，它将自动从Redis中删除。

**语法**:
```
EXPIRE key seconds
```

**参数说明**:
- `key`: 要设置过期时间的键。
- `seconds`: 键的过期时间，单位为秒。

**示例**:
假设我们有一个键`user:1`，我们希望它在60秒后过期。

```
EXPIRE user:1 60
```

这表示`user:1`键将在60秒后自动过期并被删除。

### PERSIST命令

`PERSIST`命令用于移除键的过期时间，使键永久有效。

**语法**:
```
PERSIST key
```

**参数说明**:
- `key`: 要移除过期时间的键。

**示例**:
假设我们之前设置了`user:1`键的过期时间为60秒，现在我们希望它永久有效。

```
PERSIST user:1
```

执行这个命令后，`user:1`键的过期时间将被移除，它将永久保存在Redis中，除非显式地删除它。

注意事项

- 如果键不存在，`EXPIRE`命令将返回0，表示键不会过期。
- 如果键已经设置了过期时间，再次使用`EXPIRE`命令将更新其过期时间。
- 使用`PERSIST`命令移除过期时间后，键将不再受过期时间的限制。


## 一个 Redis 实例最多能存放多少的 keys？

在理论上，Redis可以处理多达2^32个keys，因为Redis使用32位无符号整数来表示key的ID。在实际中，Redis的性能和存储能力主要受限于服务器的内存大小。

每个Redis实例至少可以存放2亿5千万个keys。这个数字是通过实际测试得出的，它展示了Redis在处理大量数据时的性能和能力。


### List、Set、Sorted Set他们最多能存放多少元素？

对于List、Set和Sorted Set这些数据结构，每个实例同样可以存放多达2^32个元素。这意味着Redis的存储极限实际上是由系统中的可用内存决定的。只要服务器的内存足够，Redis就可以存储大量的数据。


## 跳表

一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但 redis 中的 ZSet 的 skiplist 却比较特殊，它没法归属到这两大类里面。

参考 Redis 为什么用跳表而不用平衡树 https://juejin.cn/post/6844903446475177998


## 场景实现类

### 队列

一般使用 list 结构作为队列，rpush 入队，lpop 出队

### 消息队列

1. 可以使用 list 结构作为队列，rpush 生产消息，lpop 消费消息，当 lpop 没有消息的时候，可以使用 blpop 在没有消息的时候，它会阻塞住，直到消息到来，也可以设置阻塞时间
2. 使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。但是在消费者下线的情况下，生产的消息会丢失，解决这样的问题得使用专业的消息队列，如RabbitMQ等。

### 延时队列：

使用 sorted set，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangbyscore 指令获取N秒之前的数据轮询进行处理。

以下是使用Sorted Set实现延时队列的基本步骤：

1. **生产消息**：
   使用`ZADD`命令将消息添加到Sorted Set中。消息的score（分数）是消息预定的执行时间的时间戳，而消息内容作为key。这样，消息就会根据预定时间自动排序。

   示例：
   ```shell
   ZADD delay_queue 1617332800 "message content"
   ```
   这里`delay_queue`是Sorted Set的名称，`1617332800`是消息预定执行的时间戳（例如，2021年4月1日 00:00:00 UTC），`"message content"`是消息内容。

2. **消费消息**：
   消费者使用`ZRANGEBYSCORE`命令来获取在特定时间之前到期的消息。消费者可以定期轮询Sorted Set，获取已经到达预定时间的消息。

   示例：
   ```shell
   ZRANGEBYSCORE delay_queue -inf 1617332800
   ```
   这个命令会返回所有在时间戳`1617332800`之前到期的消息。

3. **处理消息**：
   消费者获取到消息后，可以进行相应的处理。处理完成后，消费者需要从Sorted Set中移除已处理的消息。

   示例：
   ```shell
   ZREM delay_queue "message content"
   ```
   这个命令会从`delay_queue`中移除消息内容为`"message content"`的消息。

使用Sorted Set实现延时队列的优点是简单且高效，消息会根据预定时间自动排序，消费者可以轻松地获取到需要处理的消息。然而，需要注意的是，随着消息数量的增加，`ZRANGEBYSCORE`命令的性能可能会受到影响，因此在处理大量消息时，可能需要考虑使用更高效的消息处理策略，比如使用Redis的Stream数据结构。

此外，使用Sorted Set实现延时队列时，需要确保Redis服务器的时间设置是准确的，因为消息的预定时间是基于服务器的时间戳的。如果服务器时间不准确，可能会导致消息处理的延迟或提前。

### 排行榜/计数器

在Redis中，排行榜和计数器可以通过不同的数据结构来实现。以下是两种常见的实现方式：

1. 使用Sorted Set实现排行榜

Redis的Sorted Set（有序集合）非常适合用来实现排行榜，因为它可以存储带有分数的元素，并且可以快速地根据分数进行排序。

排行榜操作：

- **添加或更新分数**：使用`ZADD`命令可以添加新的元素到排行榜，或者更新已存在的元素的分数。
  
  示例：
  ```shell
  ZADD leaderboard 100 "user1"
  ZADD leaderboard 150 "user2"
  ```

- **获取排行榜**：使用`ZRANGE`或`ZREVRANGE`命令可以获取排行榜的元素列表，`ZREVRANGE`命令会根据分数从高到低排序。
  
  示例：
  ```shell
  ZRANGE leaderboard 0 -1 WITHSCORES
  ```

- **获取特定范围的元素**：可以使用`ZRANGEBYSCORE`命令获取特定分数范围内的元素。
  
  示例：
  ```shell
  ZRANGEBYSCORE leaderboard 100 150 WITHSCORES
  ```

- **获取元素排名**：使用`ZREVRANK`命令可以获取元素在排行榜中的排名。
  
  示例：
  ```shell
  ZREVRANK leaderboard "user1"
  ```

- **删除元素**：使用`ZREM`命令可以删除排行榜中的元素。
  
  示例：
  ```shell
  ZREM leaderboard "user1"
  ```

2. 使用String实现计数器

Redis的String数据类型可以用来实现计数器，因为String可以存储数字，并且支持原子性的自增和自减操作。

计数器操作：

- **增加计数**：使用`INCRBY`命令可以增加计数器的值。
  
  示例：
  ```shell
  INCRBY counter 1
  ```

- **减少计数**：使用`DECRBY`命令可以减少计数器的值。
  
  示例：
  ```shell
  DECRBY counter 1
  ```

- **获取计数器的值**：使用`GET`命令可以获取计数器的当前值。
  
  示例：
  ```shell
  GET counter
  ```

使用Redis实现排行榜和计数器时，需要注意的是，由于Redis是内存数据库，数据的持久化需要通过配置RDB快照或AOF日志来实现。此外，对于高并发场景，需要考虑Redis的性能和资源限制，确保操作的原子性和一致性。


### 发布/订阅

Redis的发布/订阅（pub/sub）模式允许客户端订阅一个或多个频道（channel），然后接收发布到这些频道的消息。这种模式非常适合实现消息通知系统、实时通信等场景。

发布/订阅基本操作

1. **订阅频道**：客户端使用`SUBSCRIBE`命令订阅一个或多个频道。

   示例：
   ```shell
   SUBSCRIBE channel1 channel2
   ```

   这个命令会订阅`channel1`和`channel2`两个频道。

2. **发布消息**：客户端使用`PUBLISH`命令向指定的频道发送消息。

   示例：
   ```shell
   PUBLISH channel1 "Hello, World!"
   ```

   这个命令会向`channel1`频道发送消息`"Hello, World!"`。

3. **接收消息**：订阅了频道的客户端会接收到发布到该频道的所有消息。

   当客户端订阅频道后，它会进入等待状态，接收并处理来自Redis服务器的消息。

发布/订阅的使用场景

- **实时消息通知**：例如，一个聊天应用可以使用发布/订阅模式来通知用户收到新消息。
- **事件驱动系统**：例如，一个系统可以发布事件到特定频道，其他订阅了该频道的系统可以监听这些事件并作出响应。
- **分布式系统通信**：在分布式系统中，不同的服务可以通过发布/订阅模式进行通信。

发布/订阅的限制

- **持久性**：Redis的发布/订阅模式不保证消息的持久性。如果订阅者在消息发布时没有连接到Redis服务器，那么它将无法接收到该消息。
- **消息丢失**：如果发布者和订阅者之间的连接断开，那么在断开期间发布的消息将会丢失。

示例

假设我们有两个客户端，一个用于发布消息，另一个用于订阅频道并接收消息。

**发布者**：
```shell
PUBLISH channel1 "Hello, World!"
```

**订阅者**：
```shell
SUBSCRIBE channel1
```

当发布者向`channel1`发送消息时，订阅者将接收到该消息。

发布/订阅模式是Redis提供的一个非常强大的功能，它允许客户端之间进行松耦合的通信。然而，由于其非持久性的特性，它通常不适用于需要持久化消息的场景。对于需要持久化消息的场景，可以考虑使用Redis的其他数据结构，如List或Stream。

### 分布式锁

先拿 setnx 来争抢锁，抢到之后再用 expire 给锁加一个过期时间防止锁忘记了释放。如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，这个时候锁会永远得不到释放了，但是 set 指令有个非常复杂的参数是可以同时把 setnx 和 expire 合成一条指令来用的。

这个复杂参数是`SET`命令的扩展参数，它允许在设置键值的同时设置过期时间，从而避免了使用`SETNX`和`EXPIRE`两个命令可能带来的竞态条件问题。这个参数是`SET`命令的`NX`和`EX`选项的组合，即`SETNX`和`EX`的缩写。

SET命令的NX和EX选项

- `NX`（Not eXists）：如果键不存在，则设置键值对；如果键已存在，则不进行任何操作。
- `EX`（EXpire）：设置键的过期时间，单位是秒。

使用SET命令实现分布式锁

使用`SET`命令实现分布式锁的步骤如下：

1. **设置锁**：
    使用`SET`命令的`NX`和`EX`选项来设置锁，并指定一个过期时间。

    ```shell
    SET lock_key unique_lock_value EX 30 NX
    ```

    这个命令尝试设置`lock_key`键，如果键不存在，则设置成功并返回`OK`，同时设置键的过期时间为30秒。如果键已存在，则命令不进行任何操作并返回`nil`。

2. **锁的持有**：
    如果`SET`命令返回`OK`，表示成功获取了锁，此时可以执行需要互斥访问的代码。

3. **释放锁**：
    在代码执行完毕后，需要删除锁键来释放锁。为了防止误删除其他客户端的锁，通常会检查锁的值是否与设置时的值相同。

    ```shell
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    ```

注意事项

- **锁的唯一标识**：在使用`SET`命令时，需要确保`unique_lock_value`是唯一的，以区分不同客户端获取的锁。通常可以使用UUID或客户端ID等唯一值。
- **锁的过期时间**：设置一个合理的过期时间是非常重要的，以防止锁永久不释放的情况发生。
- **锁的释放**：释放锁时，需要确保只有锁的持有者才能释放锁，以防止锁被误释放。

使用`SET`命令的`NX`和`EX`选项可以简化分布式锁的实现，同时避免了使用`SETNX`和`EXPIRE`两个命令可能带来的竞态条件问题。然而，需要注意的是，即使使用了`SET`命令的组合选项，分布式锁的实现仍然需要考虑异常情况下的锁释放问题，以确保系统的健壮性。

示例

```java

/**
 * 查询三级分类（原生版redis分布式锁版本）
	问题1：（删除锁）
	未执行删除锁逻辑，会导致其他线程无法获得锁，出现死锁
问题2：（设置过期时间）
    锁释放操作可能失败（服务宕机），所以需要设置过期时间
问题3：（设置过期时间的原子性）
    设置过期时间的代码必须在setnx抢占锁的同时设置，保证原子性
问题4：（仅可以删除当前线程占用的锁）
    删除锁时，可能锁已过期删除了其他线程的锁，占锁时设置值为uuid，删除时判断当前uuid是否相等
    并且需要使用lua脚本执行原子删除操作

 */
public Map<String, List<Catalog2VO>> getCatalogJsonFromDBWithRedisLock() {
    // 1.抢占分布式锁，同时设置过期时间
    String uuid = UUID.randomUUID().toString();
    // 使用setnx占锁（setIfAbsent）
    Boolean isLock = redisTemplate.opsForValue().setIfAbsent(CategoryConstant.LOCK_KEY_CATALOG_JSON, uuid, 300, TimeUnit.SECONDS);
    if (isLock) {
        // 2.抢占成功
        Map<String, List<Catalog2VO>> result = null;
        try {
            // 查询DB
            return getCatalogJsonFromDB();
        } finally {
            // 3.查询UUID是否是自己，是自己的lock就删除
            // 封装lua脚本（原子操作解锁）
            // 查询+删除（当前值与目标值是否相等，相等执行删除，不等返回0）
            String luaScript = "if redis.call('get',KEYS[1]) == ARGV[1]\n" +
                    "then\n" +
                    "    return redis.call('del',KEYS[1])\n" +
                    "else\n" +
                    "    return 0\n" +
                    "end";
            // 删除锁
            redisTemplate.execute(new DefaultRedisScript<Long>(luaScript, Long.class), Arrays.asList(CategoryConstant.LOCK_KEY_CATALOG_JSON), uuid);
        }
    } else {
        // 4.加锁失败，自旋重试
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return getCatalogJsonFromDBWithRedisLock();
    }
}
```

## keys 指令

`KEYS` 是 Redis 中用于查找符合特定模式的键（key）的命令。这个命令可以用来列出匹配给定模式的所有键。`KEYS` 命令在生产环境中使用时需要谨慎，因为它可能会对性能产生影响，尤其是在大型数据库中。

**基本用法**

`KEYS` 命令的基本语法如下：

```
KEYS pattern
```

- `pattern` 是一个匹配模式，可以使用通配符：
  - `*` 表示任意数量的字符（包括零个字符）。
  - `?` 表示任意单个字符。
  - `[abc]` 表示匹配括号内的任意一个字符（a、b 或 c）。
  - `[a-f]` 表示匹配括号内的任意一个字符范围（a 到 f）。

**示例**

- 查找所有键：
  ```
  KEYS *
  ```
- 查找以 `user:` 开头的键：
  ```
  KEYS user:*
  ```
- 查找以 `user:` 开头且后面跟着一个数字的键：
  ```
  KEYS user:[0-9]
  ```

**注意事项**

- **性能影响**：`KEYS` 命令在大型数据库中可能会非常慢，因为它需要扫描整个键空间。在生产环境中，应尽量避免使用 `KEYS` 命令，或者只在低负载时段使用。
- **阻塞操作**：在执行 `KEYS` 命令时，Redis 会阻塞其他命令的执行，直到 `KEYS` 命令完成。
- **替代方案**：在生产环境中，推荐使用 `SCAN` 命令来代替 `KEYS`。`SCAN` 命令提供了一种更高效的方式来迭代键集合，它不会阻塞其他命令的执行，并且可以分批次返回结果。

**SCAN 命令**

`SCAN` 命令的基本语法如下：

```
SCAN cursor [MATCH pattern] [COUNT count]
```

- `cursor` 是迭代的游标，初始值为 `0`，表示从头开始迭代。
- `MATCH pattern` 是可选的，用于指定匹配模式。
- `COUNT count` 是可选的，用于指定每次迭代返回的键的数量。

`SCAN` 命令返回两个值：新的游标和匹配的键列表。使用 `SCAN` 命令时，需要在客户端中实现循环逻辑，以迭代整个键空间。

**示例**

使用 `SCAN` 命令迭代所有键：

```
SCAN 0
```

迭代匹配特定模式的键：

```
SCAN 0 MATCH user:*
```

使用 `SCAN` 命令可以有效地减少对Redis性能的影响，特别是在处理大型数据库时。

**SCAN 的缺点**

1. **结果不保证即时性**：`SCAN` 返回的结果是基于当前数据库状态的快照，因此在迭代过程中，数据库的状态可能会发生变化。这意味着 `SCAN` 返回的结果可能不是完全一致的。

2. **使用复杂性**：与 `KEYS` 相比，`SCAN` 需要客户端实现额外的逻辑来处理分批结果。这增加了使用 `SCAN` 的复杂性，尤其是在需要精确匹配特定模式时。

3. **可能需要多次迭代**：`SCAN` 命令可能需要多次迭代才能返回所有匹配的键，这取决于键的数量和 `COUNT` 参数的设置。这可能使得 `SCAN` 在某些情况下不如 `KEYS` 直观。

**总结**

`SCAN` 提供了一种更安全、更高效的方式来迭代 Redis 中的键集合，特别是在处理大型数据库时。尽管它在使用上比 `KEYS` 更复杂，但其非阻塞和分批处理的特性使其成为生产环境中处理键集合的首选命令。在需要精确匹配特定模式时，`SCAN` 与 `MATCH` 选项结合使用，可以提供与 `KEYS` 类似的功能，同时避免了 `KEYS` 可能带来的性能问题。

## Redis 的持久化机制

Redis提供了两种主要的数据持久化方式：快照（Snapshotting）和追加文件（Append Only File，AOF）。这两种方式可以单独使用，也可以结合使用，以提供数据的持久性和可靠性。

**快照(默认)（RDB）**

快照持久化是通过创建数据集的副本来保存在某个时间点的数据状态。Redis通过创建子进程来执行快照操作，这样可以避免阻塞主进程处理客户端请求。RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态 （ 默认下，持久化到 dump.rdb 文件，并且在 redis 重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB 的快照文件，同步到内存中的时间是 20-30 秒）

- **RDB文件**：在指定的时间间隔内，如果达到了指定的更改次数，Redis会创建一个快照并保存到磁盘上。这个快照文件被称为RDB文件。
- **触发条件**：可以通过`save`命令手动触发快照，或者通过配置文件设置自动触发快照的条件，如`save 900 1`表示每900秒内至少有1次更改时创建快照。还有一个是 BGSAVE 命令，SAVE 会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE 命令会派生出一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求，创建 RDB 文件结束之前，客户端发送的 BGSAVE 和 SAVE 命令会被服务器拒绝，**建议使用 BGSAVE 命令**。且通过配置文件·设置自动触发快照就是自动执行的 BGSAVE 命令。
- **恢复数据**：在Redis重启时，可以通过加载RDB文件来恢复数据。

**追加文件（AOF）**

AOF 持久化是通过记录每次写操作到一个日志文件中，然后在 Redis 重启时重新执行这些命令来恢复数据。如果同时启用了 RDB 和 AOF 方式，AOF 优先，启动时只加载 AOF 文件恢复数据。

- **AOF文件**：每次写操作都会被追加到AOF文件的末尾，因此AOF文件会逐渐增长。
- **触发条件**：可以通过配置文件设置AOF重写的条件，如`auto-aof-rewrite-percentage`和`auto-aof-rewrite-min-size`，以控制AOF文件的大小。
- **恢复数据**：在Redis重启时，可以通过重放AOF文件中的命令来恢复数据。

**混合持久化**

Redis 4.0引入了混合持久化（RDB-AOF混合持久化）的方式，它结合了RDB和AOF的优点：

- **混合持久化**：在Redis重启时，首先尝试加载AOF文件来恢复数据。如果AOF文件损坏或不存在，则加载RDB文件来恢复数据。
- **配置**：可以通过配置`aof-use-rdb-preamble yes`来启用混合持久化。

**选择持久化方式**

选择哪种持久化方式取决于应用的需求：

- **如果需要快速重启和数据恢复**，并且可以接受数据丢失的风险，可以选择RDB。
- **如果需要更高的数据安全性**，并且可以接受更高的性能开销，可以选择AOF。
- **如果需要平衡性能和数据安全性**，可以选择混合持久化。

在实际应用中，建议根据数据的重要性和业务需求来选择合适的持久化策略，并进行适当的配置和测试。

## 高并发环境下的缓存问题

### 缓存穿透（不存在的数据）

```json
缓存穿透:
	查询一个一定不存在的数据，导致一定会查询缓存+查询DB，缓存失去意义（大并发过来时任然会查询db）
风险：
	利用不存在的数据进行攻击，数据库顺时压力增大，最终导致崩溃
解决：
	方法1：将null结果缓存，并加入短暂过期时间
	弊端：查询条件使用UUID生成，仍然出现缓存穿透问题，并且redis存满了null
	方法2：布隆过滤器，不放行不存在的查询
    在redis维护id的hash表过滤掉id不存在的查询（不到达DB层查询）
```

### 缓存雪崩（大面积失效）

```json
缓存雪崩：
	高并发状态下，大面积redis数据失效，导致所有查询到达DB，DB瞬时压力过重雪崩
解决：
	方法1：规避雪崩，设置随机的有效时间（实际上无需设置随机时间，因为每个缓存放入库中的时间本身就不固定）
		让每一个缓存过期时间重复率降低，
	方法2：永不失效
	方法3：
		事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
		事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
		事后：利用 redis 持久化机制保存的数据尽快恢复缓存 
问题：如果已经出现了缓存雪崩，如何解决？
	方法1：熔断、降级
```

### 缓存击穿（一条失效）

```json
缓存击穿：
	高并发状态下，一条数据过期，导致短时间内大量请求到达DB
解决：
	方法1：加分布式锁
	例原子操作（Redis的SETNX或者Memcache的ADD）
	流程：查询cache失败，竞争锁，竞争成功查询cache，查询成功返回释放锁
		查询失败则查询DB，并set缓存，并释放锁
	方法2：永不失效
```

### 数据一致性

实际上，对于频繁修改的数据并不适合放在缓存中，因为数据可能刚写到缓存中就发生了变化，缓存即失去了意义，且缓存本身的作用是分担数据库压力和提供高于数据库的处理效率，在高并发环境下，缓存和DB的数据一致性应分情况讨论

**即是否允许暂时性数据不一致**

若允许数据暂时性不一致，那么解决方案根据“暂时”也可以指定许多不同的方案，例如使用消息中间件，缓存DB双写等，但无论是哪种方案，数据库和缓存的数据都无法保证强一致

若必须保证缓存DB的强一致性，则只有一种方案可行，即分布式锁，在加锁的状态中同时更新数据库和缓存

### 多级缓存

多级缓存即 DB ＋ 分布式缓存 ＋ 本地缓存，在实际工作中，请慎重考虑是否真的有必要引入多级缓存，如没有强制业务需求，强烈不建议使用多级缓存，会使业务复杂化，带来的性能提升并不理想

## 布隆过滤器

[布隆过滤器](https://blog.csdn.net/qq_41125219/article/details/119982158)

布隆过滤器可以用于检索一个元素是否在一个集合中。即某样东西**一定不存在**或者**可能存在**，也就是说布隆过滤器说这个数不存在则一定不存，布隆过滤器说这个数存在可能不存在。

**优点**：

- 时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）
- 保密性强，布隆过滤器不存储元素本身
- 存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）

**缺点**：

- 有一定的误判率，但是可以通过调整参数来降低，一般建议设置为 0.01
- 无法获取元素本身
- 很难删除元素

**用途**：

- 解决Redis缓存穿透问题（面试重点）
- 邮件过滤，使用布隆过滤器来做邮件黑名单过滤
- 对爬虫网址进行过滤，爬过的不再爬
- 解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)
- HBase\RocksDB\LevelDB等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求

## 布隆过滤器无法删除问题

1. 定时异步重建布隆过滤器，例如在另一台服务器异步重构并替换
2. 计数布隆过滤器，可以计算布隆过滤器中某一位被引用的次数

## Redis 过期键的删除策略

Redis 过期键的删除策略主要涉及两种机制：被动删除和主动删除。

**被动删除**

当客户端尝试访问一个已经过期的键时，Redis 会进行检查。如果发现键已经过期，Redis 会立即删除这个键，并返回一个错误给客户端（例如，返回`nil`或`not found`）。这种策略是被动的，因为只有在键被访问时才会检查其是否过期。

**主动删除**

Redis 会周期性地（默认情况下，每秒运行10次）随机选择一些设置了过期时间的键进行检查，如果发现某个键已经过期，则删除该键。这种策略是主动的，因为即使没有客户端访问这些键，Redis 也会定期检查并删除过期的键。

**混合策略**

实际上，Redis 使用的是被动删除和主动删除的混合策略。被动删除确保了当键被访问时，如果键已经过期，它会被立即删除。而主动删除则确保了即使键没有被访问，过期的键也会在一定时间后被删除，从而避免了内存中无用数据的积累。

**定期删除**

除了上述两种策略外，Redis 还有一个定期删除（也称为定时删除）的机制。Redis 会周期性地检查数据库中的键，删除那些已经过期的键。这个过程是异步进行的，不会阻塞主线程，因此对性能的影响较小。

总结

Redis 的过期键删除策略结合了被动删除和主动删除，以及定期删除机制，确保了过期键能够及时被清理，同时避免了对性能的显著影响。这种策略使得 Redis 能够高效地管理内存，同时保持了良好的性能。在实际使用中，Redis 的过期键删除策略能够很好地满足大多数应用场景的需求。

实际上 redis采用的是定期删除+惰性删除策略

为什么不用定时删除策略?

定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.

定期删除+惰性删除是如何工作的呢?

定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?

不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

## 内存淘汰策略

应用 解决定期删除+惰性删除存在的问题

Redis 提供了几种内存淘汰策略，用于在内存使用达到上限时决定哪些数据应该被删除以释放空间。这些策略可以通过配置文件或使用`CONFIG SET`命令动态设置。以下是Redis支持的内存淘汰策略：

1. **noeviction**：
   - 这是默认策略。当内存使用达到配置的上限时，如果尝试写入数据，Redis将返回错误，不会删除任何数据。

2. **allkeys-lru**：
   - 当内存使用达到上限时，删除最近最少使用的键（LRU，Least Recently Used）。这个策略适用于所有键，无论它们是否设置了过期时间。

3. **volatile-lru**：
   - 当内存使用达到上限时，只考虑设置了过期时间的键，并删除最近最少使用的键。如果所有键都设置了过期时间，那么它与`allkeys-lru`策略相同。

4. **allkeys-random**：
   - 当内存使用达到上限时，随机删除一些键。这个策略适用于所有键，无论它们是否设置了过期时间。

5. **volatile-random**：
   - 当内存使用达到上限时，只考虑设置了过期时间的键，并随机删除一些键。

6. **volatile-ttl**：
   - 当内存使用达到上限时，删除具有最近到期时间的键（即TTL值最小的键）。这个策略只考虑设置了过期时间的键。

7. **volatile-lfu**：
   - 当内存使用达到上限时，删除使用频率最低的键（LFU，Least Frequently Used）。这个策略只适用于设置了过期时间的键。

8. **allkeys-lfu**：
   - 当内存使用达到上限时，删除使用频率最低的键。这个策略适用于所有键，无论它们是否设置了过期时间。

选择合适的内存淘汰策略取决于你的应用需求和数据访问模式。例如，如果你的应用中大部分键都有过期时间，并且你希望优先删除那些不常访问的数据，那么`volatile-lru`或`volatile-ttl`可能是合适的选择。如果你希望对所有键公平对待，那么`allkeys-lru`或`allkeys-random`可能更适合。

在实际部署时，建议根据应用的实际情况进行测试，以确定最佳的内存淘汰策略。

## Redis事务

[Redis事务](https://blog.csdn.net/weixin_43520450/article/details/107548277)

没有原子性 有持久性和一致性 至于隔离性, 都不存在多个事务的情况 毕竟单线程

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

Redis事务没有隔离级别，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

Redis事务的三个阶段

1. 开始事务
2. 命令入队
3. 执行事务

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行。

1. redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
2. 如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
3. 如果在一个事务中出现运行错误，那么正确的命令会被执行。

下面对这些原语进行更详细的解释：

1. **MULTI**：这个命令用于标记事务的开始。当执行MULTI命令后，Redis会进入事务模式，此时客户端发送的命令不会立即执行，而是被放入一个队列中。Redis会返回一个OK响应，表明事务已经开启。在MULTI命令之后，客户端可以继续发送多个命令，这些命令都会被暂存起来，直到EXEC命令被调用。

2. **EXEC**：当事务中的所有命令都通过MULTI命令被加入队列后，客户端可以调用EXEC命令来执行事务。EXEC命令会按顺序执行事务队列中的所有命令，并返回每个命令的执行结果。如果在执行事务的过程中发生错误，比如命令语法错误，那么Redis会停止执行后续的命令，并返回错误信息。如果事务执行过程中没有错误，那么所有命令都会按顺序执行。

3. **DISCARD**：如果在MULTI命令之后，事务中的某些命令不再需要执行，或者需要重新开始事务，可以使用DISCARD命令。DISCARD命令会清空事务队列，并退出事务模式，返回客户端到正常状态。

4. **WATCH**：WATCH命令用于监视一个或多个键，如果在事务执行之前这些键被其他客户端修改，那么事务将不会执行。WATCH命令可以在MULTI命令之前使用，它会持续监视直到EXEC命令被调用。如果在WATCH之后，被监视的键被修改，那么EXEC命令将失败，并返回一个错误，通知事务没有被执行。

需要注意的是，Redis的事务机制并不支持回滚（rollback）操作。如果事务中的某个命令执行失败，Redis会继续执行事务中的后续命令，而不是回滚到事务执行前的状态。这种设计使得Redis的事务处理更加简单和快速，但同时也意味着开发者需要确保事务中的命令能够正确执行，或者在设计应用逻辑时考虑到错误处理。

## 集群

[Redis-集群搭建](https://blog.csdn.net/weixin_44642403/article/details/118885921)
[Redis 集群的主从复制机制](https://blog.csdn.net/weixin_44642403/article/details/110692692)

Redis 集群是Redis提供的分布式数据存储解决方案，它允许将数据分布在多个Redis节点上，以实现数据的高可用性和水平扩展。一般来说，单 Redis 最大使用内存不超过 20 GB

以下是Redis集群的主要方式及其特点：

Redis 集群方式

1. **主从复制（Master-Slave Replication）**：
    - 这是最基本的集群方式，一个主节点（Master）可以有多个从节点（Slave）。
    - 主节点负责处理写操作，而从节点负责读操作。
    - 当主节点不可用时，可以手动或自动将一个从节点提升为新的主节点。

2. **哨兵系统（Sentinel）**：
    - 哨兵系统是Redis的高可用解决方案，它监控主从节点的健康状态。
    - 当主节点出现故障时，哨兵可以自动将一个从节点提升为新的主节点。
    - 哨兵还负责客户端的故障转移，提供服务发现功能。

3. **集群模式（Cluster Mode）**：
    - Redis集群模式是Redis 3.0引入的，它支持数据的自动分片和故障转移。
    - 集群由多个节点组成，每个节点都是独立的Redis实例。
    - 集群通过一致性哈希算法将数据分布在不同的节点上，实现数据的水平扩展。
    - 集群支持在线添加或移除节点，实现动态扩展。

### Redis 的主从复制集群模型

主从复制集群模型，是指将一台Redis服务器的数据，复制到其他的 Redis 服务器，前者称为主节点（master），后者成为从节点（slave），Master 负责写，Slave 负责读，以实现读写分离，因为 80% 情况下都是进行读操作，主从复制读写分离可以大大减轻服务器的压力，一般情况下都是一主二从。数据的复制是单向的，只能由主节点到从节点

在集群模式下，每个节点可以是主节点（master）或从节点（slave），并且每个主节点可以有多个从节点。主从复制的过程主要涉及以下几个步骤：

1. **建立连接**：
   - 当一个从节点启动时，它会尝试与配置中的主节点建立连接。
   - 从节点会向主节点发送一个 `SYNC` 命令。

2. **同步数据**：
   - 收到 `SYNC` 命令后，主节点会开始准备数据同步。
   - 主节点首先会创建一个快照（snapshot），将当前的数据集保存到磁盘上。
   - 然后，主节点会将快照文件发送给从节点。
   - 同时，主节点会继续处理客户端的命令请求，并将这些新的写命令记录到一个缓冲区中。

3. **接收和应用数据**：
   - 从节点接收主节点发送的快照文件，并在本地加载这个快照，从而实现数据的初始同步。
   - 从节点会继续接收主节点发送的写命令，并将这些命令应用到自己的数据集上，以保持与主节点的数据一致性。

4. **持续同步**：
   - 在初始同步完成后，从节点会进入在线状态，并开始接收主节点的复制流（replication stream）。
   - 主节点会将所有新的写命令通过复制流发送给从节点，从节点会持续地应用这些命令来更新自己的数据集。
   - 这个过程是持续的，以确保主从节点之间的数据保持实时同步。

5. **部分重同步**：
   - 如果在主从同步过程中，网络连接断开，Redis 支持部分重同步（partial resynchronization）。
   - 当网络恢复后，从节点会请求主节点发送断开连接期间丢失的数据，而不是重新进行完整的同步。
   - 主节点会根据从节点的复制偏移量（replication offset）和复制积压缓冲区（replication backlog）来发送缺失的数据。

### 哨兵模式

主从复制模式为 Redis 提供了数据备份和读写分离的能力，但它**并不提供自动故障转移的功能**。当主节点发生故障时，需要人工介入来处理故障切换，这可能会导致服务中断和数据丢失。为了提高Redis的高可用性和自动化管理能力，引入了哨兵（Sentinel）模式。

哨兵（Sentinel）节点在Redis的高可用架构中既不是主节点（master）也不是从节点（slave）。哨兵节点是独立于主从复制架构之外的特殊进程，它们的主要职责是监控Redis主从服务器的状态，并在主节点出现故障时执行自动故障转移。

Redis的主节点（master）和从节点（slave）不应该同时作为哨兵节点（Sentinel）运行。

主节点和从节点是Redis数据存储和复制的关键部分，它们负责处理客户端的读写请求和数据复制。如果将主节点或从节点同时配置为哨兵节点，这将违反哨兵设计的初衷，即独立监控和管理主从节点，可能导致职责冲突和系统不稳定。

哨兵节点应该单独部署，以确保它们可以专注于监控和管理任务，而不受主从节点的负载和状态影响。这样可以保证哨兵节点的性能和可靠性，从而在主节点出现故障时能够迅速、准确地执行故障转移。

哨兵节点的工作机制如下：

1. **独立进程**：每个哨兵节点都是一个独立的进程，它们之间通过Gossip协议进行通信，共享信息并协同工作。

2. **监控**：哨兵节点会监控所有的Redis主节点和从节点，检查它们是否正常运行。如果主节点不可达，哨兵会尝试与其他哨兵节点确认故障，并决定是否需要进行故障转移。

3. **故障转移**：在确认主节点故障后，哨兵会从现有的从节点中选择一个作为新的主节点，并更新所有从节点的配置，让它们指向新的主节点。同时，哨兵会通知客户端新的主节点地址。当故障的节点在之后正常以后，会重新加入集群作为从节点（slave）运行。

4. **配置管理**：哨兵节点负责管理整个Redis集群的配置信息，包括主节点和从节点的地址、端口等。在故障转移后，哨兵会更新这些配置信息。

5. **通知**：哨兵节点可以向管理员或应用程序发送关于Redis实例状态变化的通知，如故障转移的发生。

单哨兵存在一个问题，如果最高哨兵死了呢，那么就没人进行监控了，所以在生产机中通常会存在多个哨兵同时监控Redis，并且多个哨兵也相互监控，多个哨兵节点可以相互协作，共同决定何时进行故障转移，并确保整个过程的正确性和一致性。通过使用哨兵节点，Redis可以提供一个更加健壮和自动化的高可用性解决方案，而不需要人工干预。

在实际部署中，通常会建议至少部署三个哨兵节点，以确保高可用性和容错能力。这些哨兵节点会相互协作，通过投票机制来决定何时进行故障转移，并确保整个过程的一致性和正确性。通过这种方式，哨兵节点可以有效地提高Redis系统的稳定性和可用性。

#### 主节点的选举过程

在Redis的哨兵（Sentinel）系统中，主节点的选举过程是在发生故障转移时自动进行的。当哨兵系统检测到主节点不可用时，它会从现有的从节点中选举一个新的主节点。以下是选举新主节点的一般步骤：

1. **故障检测**：
   - 首先，哨兵系统会检测到主节点已经不可用。这通常是通过哨兵节点定期向主节点发送`PING`命令并等待响应来完成的。如果在指定时间内没有收到响应，哨兵会认为主节点已经下线。

2. **主观下线**：
   - 当哨兵节点检测到主节点不可达时，它会将该主节点标记为“主观下线”（Subjectively Down，简称`S_DOWN`）。

3. **客观下线**：
   - 如果多个哨兵节点独立地确认主节点不可达，那么主节点会被标记为“客观下线”（Objectively Down，简称`O_DOWN`）。这通常需要超过一定数量的哨兵节点同意主节点已经下线。

4. **选举领导者**：
   - 在主节点被标记为客观下线后，哨兵节点会进行领导者选举（Leader Election），以决定哪个哨兵节点将负责故障转移的协调工作。通常，拥有最高配置版本号的哨兵节点会成为领导者。

5. **选择新的主节点**：
   - 领导者哨兵会从所有存活的从节点中选择一个作为新的主节点。选择标准可能包括从节点的运行状态、复制偏移量、延迟时间等。通常，优先选择复制偏移量最大的从节点，因为它最有可能拥有最新的数据。

6. **提升新的主节点**：
   - 领导者哨兵会向选中的从节点发送`SLAVEOF NO ONE`命令，将其提升为新的主节点。

7. **配置新的主从关系**：
   - 新的主节点开始接受写操作，并将数据变更复制给其他从节点。同时，哨兵节点会更新其他从节点的配置，让它们指向新的主节点。

8. **通知客户端**：
   - 哨兵节点会通过发布/订阅机制通知客户端新的主节点信息，以便客户端可以更新其连接配置。

9. **故障转移完成**：
   - 一旦新的主节点开始接受写操作，并且所有从节点都已重新配置，故障转移过程就完成了。

这个过程是自动化的，不需要人工干预。哨兵系统通过选举新的主节点来确保Redis服务的高可用性和数据的持续可用性。在故障转移完成后，原来的主节点如果恢复，哨兵会将其降级为从节点，并重新加入到集群中。

### 故障转移是如何确保数据一致性的

故障转移过程中确保数据一致性的关键在于Redis的复制机制和哨兵（Sentinel）系统的协调。以下是故障转移过程中确保数据一致性的几个关键步骤：

1. **复制偏移量**：
   - Redis的复制机制使用复制偏移量来确保数据一致性。每个从节点都会记录它从主节点复制的数据量，这个值称为复制偏移量。当故障转移发生时，哨兵会优先选择复制偏移量最大的从节点作为新的主节点，因为这个从节点最有可能拥有最新的数据。

2. **复制积压缓冲区**：
   - 主节点会维护一个复制积压缓冲区（replication backlog），这个缓冲区记录了最近发送给从节点的数据。当从节点重新连接到主节点时，主节点会根据复制积压缓冲区中的数据来同步从节点缺失的数据。在故障转移期间，这个机制确保了即使在主节点故障后，从节点也能尽可能地同步最新的数据。

3. **哨兵的协调**：
   - 哨兵系统在故障转移过程中起到协调作用。它负责监控主从节点的状态，并在主节点故障时选择新的主节点。哨兵会确保新的主节点是数据最完整的从节点，从而最小化数据丢失的风险。

4. **故障转移的顺序性**：
   - 在故障转移过程中，哨兵会确保从节点在成为新的主节点之前，已经停止接受新的写操作。这有助于防止在故障转移期间发生数据不一致的情况。

5. **客户端通知**：
   - 哨兵系统会通过发布/订阅机制通知客户端新的主节点信息。客户端在得知新的主节点后，会更新其连接配置，确保后续的读写操作都指向新的主节点。这个过程有助于客户端避免读取到过时的数据。

6. **从节点的重新配置**：
   - 故障转移完成后，哨兵会更新所有从节点的配置，让它们指向新的主节点。这样，从节点可以继续从新的主节点复制数据，保持数据一致性。

通过这些机制，Redis的哨兵系统能够在主节点发生故障时，自动地进行故障转移，同时尽可能地保证数据的一致性。然而，需要注意的是，由于故障转移可能发生在主节点故障的瞬间，因此在极端情况下，仍然有可能发生少量数据丢失。因此，设计高可用的Redis系统时，应考虑数据备份和持久化策略，以进一步降低数据丢失的风险。

### 集群模式

[集群模式](https://blog.csdn.net/QHJJHQ/article/details/113685193)

Redis Cluster是Redis的分布式解决方案，在Redis 3.0版本正式推出的，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能，能有效解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，都可以采用Cluster架构达到负载均衡的目的。

Redis Cluster采用了一种去中心化的架构，其中所有的Redis节点都是相互连接的，并且通过一种称为PING-PONG机制的内部通信协议来检测节点的健康状态。以下是Redis Cluster的几个核心特点：

1. **无中心结构**：
    - Redis Cluster没有中心节点，所有的节点都是平等的。这意味着没有单点故障的风险，因为集群的管理功能是由所有节点共同承担的。

2. **PING-PONG机制**：
    - 集群中的每个节点都会定期向其他节点发送PING消息，以检测它们是否可达。如果一个节点在指定时间内没有收到另一个节点的PONG响应，它会认为该节点已经失效。

3. **二进制协议**：
    - Redis Cluster使用一种优化的二进制协议来减少数据传输量和提高通信效率。这种协议特别设计用于节点之间的通信，以减少带宽的使用和提高速度。

4. **节点失效检测**：
    - 集群通过一种基于多数投票的机制来检测节点的失效。只有当超过半数的节点认为某个节点失效时，该节点才会被标记为失效。这种机制有助于防止误判，确保集群的稳定性。

5. **客户端直连**：
    - 客户端可以直接连接到Redis Cluster中的任何节点。这意味着客户端不需要通过中间代理层来访问数据，从而减少了延迟和复杂性。

6. **客户端路由**：
    - 客户端不需要连接到集群中的所有节点。它只需要连接到集群中的一个节点，该节点会根据需要将客户端的请求路由到正确的节点。如果请求的节点不可用，客户端会收到一个重定向响应，指向正确的节点。

7. **支持多键操作**：
    - Redis Cluster支持跨多个节点的多键操作，但这些操作仅限于涉及相同哈希槽的键。对于涉及多个哈希槽的多键操作，需要客户端逻辑来处理。

Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽(slot),数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。每一个节点负责维护一部分槽以及槽所映射的键值数据。

在Redis Cluster中，整个数据库被划分为16384个槽（slot），这些槽被用来均匀地分布数据，以实现数据的水平扩展和负载均衡。以下是关于Redis Cluster分片机制的详细说明：

1. **槽（Slot）的概念**：
    - Redis Cluster将整个键空间划分为16384个槽，每个槽可以看作是一个独立的子数据库。每个键都映射到这16384个槽中的一个。

2. **键与槽的映射**：
    - 每个键通过一个哈希函数映射到一个槽。这个哈希函数基于键的名称计算得出，确保键均匀地分布在所有槽中。

3. **节点与槽的关系**：
    - 每个Redis Cluster节点可以处理0个或最多16384个槽。这意味着集群中的每个节点负责维护一部分槽以及这些槽所映射的键值数据。

4. **数据分布**：
    - 当一个键值对被写入集群时，集群会根据键的哈希值决定它应该属于哪个槽，然后将这个键值对存储在负责该槽的节点上。

5. **节点的扩展与收缩**：
    - 当需要扩展或收缩集群时，可以将槽从一个节点迁移到另一个节点。这个过程是渐进的，以减少对集群性能的影响。

6. **高可用性**：
    - 为了保证高可用性，每个槽通常由一个主节点和多个从节点负责。如果主节点发生故障，集群会自动将其中一个从节点提升为新的主节点。

7. **客户端路由**：
    - 客户端在连接到集群时，需要知道键对应的槽。客户端可以使用内置的命令来查询键对应的槽。一旦知道了槽，客户端就可以直接连接到负责该槽的节点进行操作。


Cluster 模式的优缺点

优点：

1.  无中心架构，数据按照slot分布在多个节点。
2.  集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。
3.  可线性扩展到1000多个节点，节点可动态添加或删除
4.  能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换

缺点

1. 客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”
2. 节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的
3. 数据通过异步复制，不保证数据的强一致性
4. slave充当“冷备”，不能缓解读压力
5. 批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好
6. key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能
7. 不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0

### Redis 集群数据丢失问题

Redis 集群在某些情况下可能会发生写操作丢失，这主要与它的数据复制和故障转移机制有关。以下是可能导致写操作丢失的几种情况：

1. **网络分区**：
    - 当网络分区发生时，部分节点可能无法与其他节点通信。如果主节点在分区中，它可能会继续接受写操作，但这些写操作可能无法被复制到其他节点。如果分区恢复后，这些未复制的数据可能会丢失。

2. **故障转移期间**：
    - 在故障转移期间，如果主节点突然宕机，而哨兵系统还没有来得及将一个从节点提升为新的主节点，那么在故障节点上的写操作可能会丢失。

3. **写操作未同步**：
    - Redis 集群使用异步复制，这意味着写操作在主节点上执行后，会异步地复制到从节点。如果主节点在复制完成之前宕机，那么在主节点上执行的写操作可能还没有被复制到从节点。

4. **客户端配置错误**：
    - 如果客户端配置错误，例如错误地将写操作发送到一个从节点，那么这些写操作可能不会被复制到其他节点，从而导致数据丢失。

5. **使用`WAIT`命令**：
    - 在某些情况下，客户端可能会使用`WAIT`命令来确保写操作被复制到指定数量的从节点。如果配置不当或在故障转移期间使用，可能会导致写操作丢失。

为了减少写操作丢失的风险，可以采取以下措施：

- **使用持久化**：启用RDB和AOF持久化，以确保即使在故障转移期间，数据也能被保存到磁盘上。
- **合理配置复制**：确保复制延迟最小化，并且从节点尽可能地与主节点保持同步。
- **网络分区策略**：设计网络分区的应对策略，例如使用哨兵系统来管理故障转移。
- **客户端一致性**：使用支持一致性哈希的客户端库，确保写操作被发送到正确的节点。

尽管如此，由于Redis集群的异步复制和故障转移机制，完全避免写操作丢失是非常困难的。因此，在设计系统时，需要考虑到这些因素，并采取适当的措施来最小化数据丢失的风险。

### 如何解决由于redis主从节点不同步导致的分布式锁失效问题

Redis的主从复制机制是异步的，这意味着主节点上的数据变更不会立即同步到从节点。这种设计允许主节点在处理大量写操作时保持高性能，但同时也导致了主从节点间数据不同步的可能性。由于 Redis 的主从复制机制本质上是异步的，因此在高并发和高负载的场景下，完全避免主从节点间的数据不同步是非常困难的。在设计系统时，需要考虑到这一点，并采取相应的策略来确保数据的一致性和可靠性。

Redis分布式锁失效的一个常见原因是由于主从节点不同步导致的。当客户端在从节点上获取锁后，如果主节点在锁未同步到从节点之前发生故障，那么从节点被提升为新的主节点后，之前获取的锁就会失效。为了解决这个问题，可以采取以下策略：

1. **使用Redlock算法**：
   - Redlock算法是由Redis的创造者提出的一种分布式锁算法，它通过在多个独立的Redis实例上获取锁来提高锁的可靠性。只有当客户端在大多数节点上成功获取锁时，才认为锁被成功获取。这样即使某个节点发生故障，锁仍然有效。

2. **设置锁的过期时间**：
   - 在获取锁时，为锁设置一个合理的过期时间（TTL）。这样即使锁没有被正确同步到从节点，锁也会在一定时间后自动过期，从而避免死锁。

3. **使用Lua脚本**：
   - 使用Lua脚本来确保锁的获取和释放操作的原子性。例如，在获取锁时，可以使用Lua脚本来检查锁是否存在，并设置锁的过期时间。这样可以确保即使在主从切换的情况下，锁的释放操作也能正确执行。

4. **避免使用过时的从节点**：
   - 在获取锁之前，检查从节点是否是最新的。可以通过比较从节点的复制偏移量和主节点的复制偏移量来判断。如果从节点的复制偏移量远小于主节点，那么这个从节点可能已经过时，不应该用于获取锁。

5. **使用哨兵系统**：
   - 利用Redis哨兵系统来监控主节点的状态。当主节点发生故障时，哨兵系统可以自动将从节点提升为新的主节点。这样可以确保锁的获取和释放操作仍然在新的主节点上执行。

6. **使用集群模式**：
   - 使用Redis集群模式代替主从复制模式。在集群模式下，每个节点都是独立的，不存在主从节点不同步的问题。这样可以提高分布式锁的可靠性。

7. **客户端逻辑**：
   - 在客户端实现逻辑来处理锁的失效情况。例如，当客户端尝试释放锁时，如果检测到锁已经失效，可以重新尝试获取锁。

通过上述策略，可以在一定程度上解决由于Redis主从节点不同步导致的分布式锁失效问题。然而，需要注意的是，分布式锁的实现和使用需要非常谨慎，因为锁的失效可能会导致数据不一致和竞态条件等问题。在设计分布式系统时，应根据业务需求和系统特点选择合适的锁实现策略。

使用 zookeeper ，红锁会引入更多得不偿失的问题，比如多次io操作，加锁失败处理，加锁过程中节点的原子性等

### Redis 集群方案什么情况下会导致整个集群不可用？

Redis集群方案虽然提供了高可用性和水平扩展性，但在某些情况下，整个集群可能会变得不可用。以下是一些可能导致Redis集群不可用的情况：

1. **网络分区**：
    - 当网络分区发生时，集群的不同部分可能无法相互通信。如果集群的多数节点（超过半数）无法形成一个连通的集群，那么整个集群可能会变得不可用。

2. **主节点故障**：
    - 如果集群中的大多数主节点同时发生故障，那么集群将无法继续提供写操作，因为至少需要一半以上的主节点来处理写请求。

3. **配置错误**：
    - 如果集群的配置错误，例如错误的槽分配、错误的节点地址或端口，可能导致客户端无法正确地与集群通信，从而影响集群的可用性。

4. **资源耗尽**：
    - 如果集群中的节点由于资源耗尽（如内存不足、CPU过载等）而无法处理请求，整个集群的性能可能会受到影响，甚至变得不可用。

5. **软件缺陷**：
    - Redis集群软件可能存在缺陷或bug，这些缺陷在特定条件下可能触发，导致集群不可用。

6. **数据丢失**：
    - 如果由于硬件故障、软件错误或其他原因导致数据丢失，且没有有效的备份和恢复机制，整个集群可能会变得不可用。

7. **客户端错误**：
    - 客户端错误的使用或配置可能导致对集群的不当操作，例如错误的重定向处理或错误的键操作，这可能影响集群的可用性。

8. **安全攻击**：
    - 如果集群遭受了如DDoS攻击等安全攻击，可能会导致集群服务不可用。

为了减少这些风险，可以采取以下措施：

- **使用哨兵系统**：哨兵系统可以监控主节点的健康状况，并在主节点故障时自动进行故障转移，从而提高集群的可用性。
- **合理配置**：确保集群配置正确，包括槽的分配、节点的地址和端口等。
- **资源监控**：监控集群节点的资源使用情况，及时处理资源耗尽的问题。
- **定期备份**：定期对数据进行备份，以便在数据丢失时能够恢复。
- **安全措施**：采取适当的安全措施，如限制访问、使用防火墙等，以防止安全攻击。

尽管采取了上述措施，由于Redis集群的复杂性和外部环境的不确定性，完全避免整个集群不可用的情况是非常困难的。因此，设计和部署Redis集群时，需要充分考虑这些潜在的风险，并制定相应的应对策略。


## Jedis 与 Redisson 对比有什么优缺点

Jedis和Redisson都是流行的Java客户端库，用于与Redis服务器进行交互。它们各自有不同的特点和用途，适用于不同的场景。以下是Jedis和Redisson的一些优缺点对比：

Jedis

**优点**：

1. **轻量级**：Jedis是一个轻量级的客户端库，它提供了基本的Redis操作，如字符串、列表、集合、有序集合和哈希等。
2. **易于使用**：Jedis的API设计简单直观，易于理解和使用，适合快速开发和小型项目。
3. **性能**：Jedis在执行基本的Redis操作时性能良好，特别是在单个连接上执行操作时。

**缺点**：

1. **连接管理**：Jedis不提供连接池管理，每次操作都需要创建和关闭连接，这可能导致资源浪费和性能问题。
2. **分布式锁支持有限**：虽然Jedis支持基本的锁操作，但在实现复杂的分布式锁和同步机制方面功能有限。
3. **缺乏高级特性**：Jedis不支持如发布/订阅、事务、管道等高级Redis特性。

Redisson

**优点**：

1. **连接池管理**：Redisson提供了连接池管理，可以有效地管理Redis连接，提高性能和资源利用率。
2. **分布式锁和同步机制**：Redisson提供了强大的分布式锁和同步机制，如可重入锁、读写锁、信号量等，适用于复杂的分布式系统。
3. **高级特性支持**：Redisson支持Redis的高级特性，如发布/订阅、事务、管道、BitSet、HyperLogLog等。
4. **易于集成**：Redisson易于集成到Spring框架中，提供了Spring集成模块。

**缺点**：

1. **重量级**：Redisson是一个重量级的客户端库，它提供了许多高级特性和功能，这可能导致其API比Jedis复杂。
2. **学习曲线**：由于提供了许多高级特性和功能，Redisson的学习曲线可能比Jedis陡峭，需要更多时间来掌握。
3. **性能开销**：虽然Redisson提供了许多高级特性，但这些特性可能会带来额外的性能开销。

## Redis 如何做内存优化

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一
个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的
所有信息存储到一张散列表里面.

## Redis 常见性能问题和解决方案

(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3...

## Pipeline 有什么好处，为什么要用 pipeline？

在Redis中，Pipeline（管道）是一种优化客户端与服务器之间通信的技术。它允许客户端将多个命令打包在一起发送给Redis服务器，而不需要等待每个命令的响应。服务器在接收到这些命令后，会依次执行它们，并将所有命令的响应一次性返回给客户端。这样可以显著减少网络往返次数（Round-Trip Time, RTT），提高通信效率。

Pipeline 的好处：

1. **减少网络延迟**：通过减少网络往返次数，Pipeline可以显著减少命令执行的总时间，特别是在网络延迟较高的情况下。

2. **提高吞吐量**：在执行大量命令时，使用Pipeline可以提高Redis服务器的吞吐量，因为多个命令可以并行处理。

3. **减少资源消耗**：对于客户端和服务器来说，减少网络往返次数意味着减少了资源消耗，如CPU和网络带宽。

为什么要用 Pipeline？

1. **性能优化**：在需要执行大量命令的场景下，使用Pipeline可以显著提高性能，减少执行时间。

2. **资源优化**：通过减少网络往返次数，可以降低对网络资源的消耗，提高系统的整体效率。

3. **提高效率**：在某些情况下，如批量数据处理或复杂的事务操作，使用Pipeline可以简化代码逻辑，提高开发效率。

使用注意事项：

- **命令顺序**：在Pipeline中，命令的执行顺序是按照发送顺序来的，但响应的顺序可能与发送顺序不同。客户端需要能够处理这种异步响应。

- **错误处理**：如果Pipeline中的某个命令执行失败，后续命令仍然会继续执行。客户端需要能够处理这种情况，并决定如何处理错误。

- **内存使用**：在使用Pipeline时，服务器会一次性返回所有命令的响应，这可能会导致客户端内存使用增加。需要确保客户端能够处理大量数据的接收。

- **事务性**：Pipeline不提供事务性保证。如果需要执行事务操作，应该使用MULTI/EXEC命令。
