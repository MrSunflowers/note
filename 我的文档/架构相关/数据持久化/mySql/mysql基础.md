# InnoDB 存储结构与表的垂直拆分

在 InnoDB 存储引擎中，存储的每条数据称为 row ，由多个 row 组成的称为页 page ，每个页的存储容量默认为 16KB，用于存储连续的行，存储页的结构称为区 extent ，一个区的默认大小为 1MB ，即一个区最多可以装载 64 个连续的页。

表空间是一个逻辑容器，包含多个段（Segment），每个段由一个或多个区（Extent）组成。

1. 行（Row）
- **定义**: 每一条记录称为一行（row），包含表中定义的所有列的数据。
- **存储**: 行数据在页中以紧凑的方式存储，包括实际的数据值和一些额外的元数据，如变长字段长度列表和 NULL 值列表等。

2. 页（Page）
- **定义**: 页是 InnoDB 存储引擎中数据存储的基本单位，多个行（rows）被组织在一个页中。
- **默认大小**: 每个页的默认大小为 16KB，这意味着一个页可以存储大约 8000 字节的数据，具体大小可能会因为行格式和存储方式的不同而略有变化。
- **存储结构**: 
  - **文件头（File Header）**: 包含页的通用信息，如校验和、页面类型等。
  - **页头（Page Header）**: 存储页的元数据，如记录数、空闲空间等。
  - **用户记录（User Records）**: 实际存储的行数据。
  - **空闲空间（Free Space）**: 页中尚未使用的空间，用于插入新记录。
  - **页目录（Page Directory）**: 包含页中记录的相对位置信息，用于快速查找记录。

3. 区（Extent）
- **定义**: 区是比页大一级的存储结构，用于管理连续的页。
- **默认大小**: 一个区的默认大小为 1MB，包含 64 个连续的页（每个页 16KB）。
- **作用**: 区用于提高数据存储的连续性和访问效率，减少磁盘随机访问的开销。

4. 表空间（Tablespace）
- **定义**: 表空间是一个逻辑容器，包含多个段（Segment），每个段由一个或多个区（Extent）组成。
- **结构**: 表空间是 InnoDB 存储引擎中最高级别的存储结构，负责管理所有数据、索引和日志信息。

在 InnoDB 1.0 后，在页存储中引入了数据压缩技术，使得一个页中可以存储更多行数据，但由此页带来一个问题，即数据有压缩就有解压缩，这意味着每次跨页查询时，数据库引擎需要花费额外的 CPU 资源来进行解压缩操作，所以在检索数据时，需要尽可能少的跨页查询，将大宽表拆分成小表就是为了在每个页中存储更多的行数据，减少跨页检索。

## 表的垂直拆分

假设现在有一张系统执行日志表，如果需要通过执行时间查询执行日志，这个时间字段又由于各种原因没有建立索引，那么本身一条数据占用很大空间，又需要全表扫描，可见其性能之慢，但如果将其拆分为两个小表，将检索信息等小字段存入一张小表，利用 InnoDB 的页存储特点，可以减少扫描页的数量，然后根据检索到的 ID 回查详情表，会快很多。

即垂直拆表需要满足两个条件

- 表数据量可能超过百万
- 表中含有非常大的字段

# 慢 SQL 日志查询

## MySQL 慢查询日志查询指南

MySQL 的慢查询日志（Slow Query Log）是一种用于记录执行时间超过设定阈值的 SQL 语句的日志功能。通过分析这些日志，可以帮助识别和优化数据库中的性能瓶颈。以下是关于如何配置、查看和分析 MySQL 慢查询日志的详细指南：

### 1. 开启慢查询日志

- **配置文件设置**：
  - 打开 MySQL 的配置文件（通常是 `my.cnf` 或 `my.ini`）。
  - 添加或修改以下参数：
    ```ini
    [mysqld]
    slow_query_log = 1
    slow_query_log_file = /var/log/mysql/slow-query.log
    long_query_time = 2
    ```
    - `slow_query_log`：启用（1）或禁用（0）慢查询日志。
    - `slow_query_log_file`：指定慢查询日志文件的路径。
    - `long_query_time`：设置慢查询的时间阈值（单位为秒），超过此时间的查询将被记录。

- **动态设置**：
  - 使用以下命令动态开启慢查询日志：
    ```sql
    SET GLOBAL slow_query_log = 'ON';
    SET GLOBAL long_query_time = 2;
    ```
    - 注意：动态设置在 MySQL 重启后会失效，需在配置文件中进行持久化。

### 2. 查看慢查询日志

- **日志文件**：
  - 慢查询日志会记录在指定的文件中（如 `/var/log/mysql/slow-query.log`）。可以使用文本编辑器或命令行工具（如 `tail`, `less`）查看日志内容。

- **日志格式**：
  - 日志中包含的信息包括：
    - 查询时间（Query_time）
    - 锁定时间（Lock_time）
    - 返回的行数（Rows_sent）
    - 扫描的行数（Rows_examined）
    - 具体的 SQL 语句。

### 3. 分析慢查询日志

- **使用内置工具**：
  - `mysqldumpslow`：这是一个 MySQL 自带的工具，可以对慢查询日志进行汇总和分析。例如：
    ```bash
    mysqldumpslow -s t -t 10 /var/log/mysql/slow-query.log
    ```
    - `-s t`：按查询时间排序。
    - `-t 10`：显示前 10 条记录。

- **使用第三方工具**：
  - `pt-query-digest`（Percona Toolkit 的一部分）：提供更详细的分析功能。
    ```bash
    pt-query-digest /var/log/mysql/slow-query.log --limit 10
    ```
    - 这将显示执行时间最长的前 10 条 SQL 语句及其统计信息。

### 4. 优化慢查询

- **添加索引**：
  - 对于频繁查询的列，添加适当的索引可以显著提高查询性能。
  - 示例：
    ```sql
    ALTER TABLE employees ADD INDEX idx_first_name (first_name);
    ```

- **减少查询范围**：
  - 仅选择需要的列，避免使用 `SELECT *`。

- **使用 EXPLAIN**：
  - 使用 `EXPLAIN` 分析查询计划，识别潜在的性能瓶颈。

- **优化表结构**：
  - 根据需要调整表结构，如使用更合适的数据类型或归档旧数据。


# mysql 集群方式

## 读写分离集群方式

主体结构：由主节点 master 与子节点 node 组成，子节点利用 MySQL 自带的主从同步机制，即binlog 日志同步。其中写入操作只在主节点进行，并同步给子节点，读取操作可在任一节点进行，这是 MySQL 自带的简单集群模式。

在应用中增加一层中间件，可以是 MyCat 或其他数据库分片中间件，主要作用是根据提交的 SQL 行为，如 insert，update，delete 语句将路由至主节点执行，select 查询则路由至从节点执行。

故障转移：利用 MHA 中间件实现，在主节点挂掉之后自动选举提升从节点为主节点。

适用于互联网等读多写少的场景。

## 数据分片集群模式

在数据量越来越大，单表数据常常过千万级别时，可采用数据分片集群模式，即分库分表。

分片中间件实现 SQL 路由，如 MyCat。

适用于十亿至几十亿数据量的数据存储，当数据超出几十亿的时候，就需要考虑采用非关系型数据库来处理。

分片算法：

基于范围的分片，如时间范围，优点是集群扩展简单，缺点是易造成流量倾斜
基于Hash算法分片，主要有Hash取模和一致性Hash算法，优点是数据分布均匀，缺点是集群难以扩展

## 利用 canal 中间件实现 MySQL ES 双写

原理：canal 伪装成一个 MySQL 从库节点，监听主库同步过来的 binglog 日志，根据不同的日志来触发执行一段对应的 Java 代码，来实现不同数据库间的数据同步。

一般可将数据变更消息发往 kafka 或其他 mq，等待消费即可。

# MySQL 高可用 MHA 架构方案

https://zhuanlan.zhihu.com/p/132508138

# join 关联相关

原则上在高性能应用中应明令禁止三表以上的 join 查询，需要 join 的字段数据类型必须绝对一致，且关联字段必须有索引。

原因：

- myCat 不支持两张表以上的关联查询
- MySQL 自身设计缺陷导致多表关联查询性能差，尤其在两张表以上的关联查询，sql 优化器会有意想不到的错误优化。

解决方案

- 分步查询
- 反范式表冗余设计
- 引入银行的 ETL 数据集市解决方案，ETL 即数据的导出，加工，导入，数据银行每天会有日终跑批，用于处理当天产生的数据，这种数据处理称为 T＋1 即第二天才可以看到第一天的数据，使用 ETL 技术可以产生各种中间数据，使用中间数据利用倒排技术筛选出需要的数据

# MySQL 索引选择性陷阱

在 MySQL 优化器优化查询语句时，如果索引命中的数据量过大，比如超过了全表的 80％ ，则 sql 优化器会放弃使用索引转而扫描全表，比如查询手机号码为 1 开头的，`select ＊ from table where mobel like '1%';` 因为大部分手机号码都是 1 开头的，导致索引最左匹配到大量数据，导致优化器放弃使用索引。

这种情况应增加其他强制匹配条件以缩小索引命中数据量或使用ES等查询框架检索














