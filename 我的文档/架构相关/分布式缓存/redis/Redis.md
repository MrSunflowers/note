# redis 存储规范

Redis key 

- key 的设计应不超过 44 字节，因为在 44 字节以下的 key 会使用占用空间更少的 embstr 编码。
- key 禁止使用特殊符号

Redis value

- value 不允许过大，Redis 宁可 key 多，也不允许单 key 对应的 value 值过大，由此可衍生出存储方案，大 value 值可以通过分段存储，然后在内存聚合的方式存储。
- 对于经常变动的实体类可采用 hash 表的形式存储，key 代表字段名，value 代表字段值
- 使用 JSON 序列化时，需格外注意数值类型字段的精度丢失问题。

# redis 安全防护

- 修改默认端口，并禁止外网访问，禁止 bind 0.0.0.0
- 增加客户端连接密码和主从同步密码，使用强密码
- 使用非 root 用户进行运维
- 利用 Linux 定时任务定期执行 save 命令备份 rdb 文件

# redis 内存管理

# Redis 内存管理

## 自身内存

Redis 的自身内存主要是指 Redis 服务器进程本身运行所需的内存。这部分内存包括 Redis 的代码、数据结构以及一些内部开销。以下是一些关键点：

- **Redis 实例内存**：Redis 服务器实例本身所占用的内存，包括主进程和子进程（如后台持久化进程）。
- **元数据**：Redis 存储的键值对、数据库结构、哈希表等元数据所需的内存。
- **内部开销**：如 Redis 的命令解析器、数据结构管理、连接管理等所需的内存。

**优化建议**：

- **精简配置**：减少不必要的配置项和功能模块，降低内存占用。
- **监控内存使用**：使用 `INFO memory` 命令实时监控 Redis 的内存使用情况。

## 缓冲内存

缓冲内存是 Redis 用于临时存储数据或命令的内存区域，主要用于提高性能和可靠性。以下是主要的缓冲内存类型：

### 客户端缓冲区

客户端缓冲区用于存储客户端发送的命令请求以及 Redis 返回给客户端的响应数据。每个客户端连接都有一个对应的缓冲区。

- **输入缓冲区（Input Buffer）**：用于存储客户端发送的命令请求。Redis 为每个客户端连接分配一个输入缓冲区，默认大小为 1MB。
- **输出缓冲区（Output Buffer）**：用于存储 Redis 返回给客户端的响应数据。Redis 为每个客户端连接分配一个输出缓冲区，根据客户端类型（如普通客户端、从节点客户端）不同，大小可能有所不同。

**内存管理**：

- **缓冲区大小限制**：Redis 对输入和输出缓冲区的大小有默认限制，超过限制的客户端连接可能会被关闭，以防止单个客户端占用过多内存。
- **监控与限制**：可以通过 `client list` 命令查看客户端缓冲区的使用情况，并通过配置参数（如 `client-output-buffer-limit`）进行限制。

**优化建议**：

- **合理配置缓冲区大小**：根据实际需求调整缓冲区大小，避免过大或过小。
- **监控客户端连接**：定期监控客户端连接数量和缓冲区使用情况，防止单个客户端占用过多资源。

### 复制缓冲区

复制缓冲区用于在主从复制过程中存储从节点尚未接收到的命令数据。当主节点执行写命令时，这些命令会被存储在复制缓冲区中，从节点会从缓冲区中读取并执行这些命令。

- **缓冲区大小**：复制缓冲区的大小可以通过 `repl-backlog-size` 配置参数进行设置。
- **内存占用**：复制缓冲区的内存占用与主节点和从节点之间的网络延迟和复制速度有关。网络延迟越高，复制缓冲区所需的内存越大。

**内存管理**：

- **缓冲区溢出**：如果复制缓冲区的大小不足以存储所有未同步的命令，可能会导致缓冲区溢出，从而触发全量同步（full resynchronization），增加网络带宽和内存的消耗。
- **监控与调整**：通过监控复制缓冲区的使用情况，调整 `repl-backlog-size` 参数，确保缓冲区大小足够，避免频繁的全量同步。

**优化建议**：

- **合理配置缓冲区大小**：根据网络延迟和复制速度调整缓冲区大小，避免缓冲区溢出。
- **优化网络环境**：减少主从节点之间的网络延迟，提高复制效率，降低缓冲区内存占用。

### AOF 缓冲区

AOF（Append-Only File）缓冲区用于存储即将写入 AOF 文件的命令数据。当 Redis 执行写命令时，这些命令会被追加到 AOF 缓冲区中，然后定期或根据配置条件刷新到 AOF 文件中。

- **缓冲区刷新策略**：AOF 缓冲区的刷新策略可以通过 `appendfsync` 配置参数进行设置，包括 `always`、`everysec` 和 `no`。
  - `always`：每个写命令都同步刷新到 AOF 文件，安全性最高，性能最低。
  - `everysec`：每秒刷新一次，安全性较高，性能较好。
  - `no`：由操作系统决定何时刷新，安全性较低，性能最高。
- **内存占用**：AOF 缓冲区的内存占用与写命令的频率和缓冲区刷新策略有关。刷新频率越低，缓冲区内存占用越高。

**内存管理**：

- **缓冲区大小**：AOF 缓冲区的大小可以通过 `auto-aof-rewrite-min-size` 和 `auto-aof-rewrite-percentage` 配置参数进行控制。
- **缓冲区溢出**：如果 AOF 缓冲区的大小超过 `auto-aof-rewrite-min-size` 和 `auto-aof-rewrite-percentage` 定义的阈值，Redis 会触发 AOF 重写（rewrite），生成一个新的 AOF 文件，以减少缓冲区内存占用。

**优化建议**：

- **合理配置刷新策略**：根据业务需求和性能要求选择合适的刷新策略，平衡安全性和性能。
- **监控 AOF 缓冲区**：定期监控 AOF 缓冲区的使用情况，调整相关配置参数，避免缓冲区溢出。

## 对象内存

对象内存是指 Redis 中存储的实际数据所消耗的内存。Redis 支持多种数据类型（如字符串、哈希、列表、集合、有序集合），每种数据类型都有不同的内存使用特点。以下是一些关键点：

### 数据类型与内存占用

- **字符串（String）**：
  - 存储简单的键值对。
  - 内存占用较低，适用于存储短字符串。
  - Redis 使用 SDS（Simple Dynamic String）结构存储字符串，具有动态扩展能力。
  
- **哈希（Hash）**：
  - 存储键值对的集合。
  - 内存占用与哈希表的负载因子和元素数量有关。
  - Redis 使用哈希表或压缩列表（ziplist）存储哈希数据，具体取决于哈希的大小和配置参数。
  
- **列表（List）**：
  - 存储字符串元素的列表。
  - 内存占用与列表的长度和元素大小有关。
  - Redis 使用双向链表或压缩列表存储列表数据。
  
- **集合（Set）**：
  - 存储不重复的字符串元素的集合。
  - 内存占用与集合的大小和元素数量有关。
  - Redis 使用哈希表或整数集合（intset）存储集合数据。
  
- **有序集合（Sorted Set）**：
  - 存储带有分数的字符串元素的集合，根据分数进行排序。
  - 内存占用与有序集合的大小、元素数量和分数的精度有关。
  - Redis 使用跳跃表（skiplist）或压缩列表存储有序集合数据。

### 内存优化建议

- **选择合适的数据类型**：根据实际需求选择最合适的数据类型，避免不必要的数据结构转换。例如，使用哈希表存储结构化数据，可以减少内存占用。
  
- **使用压缩列表（ziplist）**：
  - 压缩列表是一种内存高效的存储结构，适用于存储少量元素的数据类型（如哈希、列表）。
  - 通过配置参数（如 `hash-max-ziplist-entries`、`hash-max-ziplist-value`）可以控制 Redis 使用压缩列表存储哈希数据。
  
- **避免使用过大的键和值**：
  - 尽量使用较短的键和值，减少内存占用。
  - 对于较大的数据，可以考虑使用 Redis 的其他功能（如 Redis Streams）进行存储。
  
- **使用 Redis 的内存优化功能**：
  - **内存淘汰策略（Eviction Policy）**：配置合适的内存淘汰策略（如 `noeviction`、`allkeys-lru`），在内存不足时自动淘汰不常用的键值对。
  - **内存碎片整理（Memory Fragmentation）**：定期监控内存碎片率（`mem_fragmentation_ratio`），并进行碎片整理。

### 对象内存管理

- **内存分配与回收**：
  - Redis 使用自己的内存分配器（如 jemalloc）进行内存管理，提高内存使用效率。
  - 定期进行内存回收，避免内存泄漏和碎片化。
  
- **内存监控**：
  - 使用 `INFO memory` 命令监控 Redis 的内存使用情况，包括总内存使用量、峰值内存使用量、内存碎片率等。
  - 使用 Redis 的内存分析工具（如 `redis-cli --bigkeys`）查找占用内存较大的键值对。

Redis 的内存管理涉及多个方面，包括自身内存、缓冲内存和对象内存。合理配置和管理这些内存区域，可以显著提高 Redis 的性能和稳定性。以下是一些关键点：

- **监控与优化**：定期监控 Redis 的内存使用情况，根据实际需求进行优化。
- **合理配置缓冲区**：根据业务需求和性能要求配置客户端缓冲区、复制缓冲区和 AOF 缓冲区的大小，避免缓冲区溢出。
- **选择合适的数据类型**：根据数据特点选择最合适的数据类型，并使用内存优化功能（如压缩列表）降低内存占用。
- **内存淘汰策略**：配置合适的内存淘汰策略，在内存不足时自动淘汰不常用的键值对。

## `INFO memory` 输出字段详解

`INFO memory` 是 Redis 提供的一个命令，用于获取有关 Redis 实例内存使用情况的详细信息。通过分析 `INFO memory` 的输出，管理员和开发者可以深入了解 Redis 的内存使用情况，从而进行性能调优、内存优化以及故障排查。以下是对 `INFO memory` 命令输出的详细解释。

执行 `INFO memory` 命令后，Redis 会返回包含多个字段及其对应值的字符串。以下是各个字段的详细解释：

1. **used_memory**
- **描述**：Redis 分配器（allocator）分配的内存总量（以字节为单位）。
- **说明**：这是 Redis 当前使用的总内存，包括所有数据结构和内部开销，但不包括操作系统的内存碎片。

2. **used_memory_human**
- **描述**：`used_memory` 字段的易读格式，通常以 MB 或 GB 表示。
- **示例**：`used_memory_human:123.45M`

3. **used_memory_rss**
- **描述**：Redis 进程在操作系统中占用的常驻内存集（Resident Set Size，RSS），以字节为单位。
- **说明**：RSS 表示 Redis 进程实际占用的物理内存，包括内存碎片和被操作系统分配的其他内存区域。这个值通常大于 `used_memory`，因为它包含了内存碎片和其他开销。

4. **used_memory_rss_human**
- **描述**：`used_memory_rss` 字段的易读格式。
- **示例**：`used_memory_rss_human:130.00M`

5. **used_memory_peak**
- **描述**：Redis 进程达到的内存使用峰值（以字节为单位）。
- **说明**：这是 Redis 自启动以来使用的最大内存量，可以用于监控内存使用趋势。

6. **used_memory_peak_human**
- **描述**：`used_memory_peak` 字段的易读格式。
- **示例**：`used_memory_peak_human:150.00M`

7. **used_memory_lua**
- **描述**：Lua 脚本引擎使用的内存（以字节为单位）。
- **说明**：如果 Redis 中使用了 Lua 脚本，这个字段表示 Lua 引擎占用的内存。

8. **used_memory_lua_human**
- **描述**：`used_memory_lua` 字段的易读格式。
- **示例**：`used_memory_lua_human:512k`

9. **mem_fragmentation_ratio**
- **描述**：内存碎片率，计算公式为 `used_memory_rss / used_memory`。
- **说明**：这个比率表示 Redis 内存使用的碎片化程度。理想情况下，该值应接近 1.0，表示内存使用高效且碎片化程度低。值大于 1.0 表示存在内存碎片，值小于 1.0 可能表示操作系统对 Redis 进程进行了内存压缩。
  
  - **大于 1.0**：存在内存碎片，可能需要优化内存使用或重启 Redis。
  - **小于 1.0**：操作系统对 Redis 进程进行了内存压缩，可能影响性能。

10. **mem_allocator**
- **描述**：Redis 使用的内存分配器类型。
- **示例**：`mem_allocator:jemalloc-4.0.3`
- **说明**：常见的内存分配器包括 jemalloc、tcmalloc 和 glibc malloc。

11. **active_defrag_running**
- **描述**：表示是否正在进行主动内存碎片整理。
- **值**：
  - `1`：正在进行内存碎片整理。
  - `0`：未进行内存碎片整理。

12. **lazyfree_pending_objects**
- **描述**：等待异步释放的对象数量。
- **说明**：当使用 `UNLINK` 或其他异步删除命令时，Redis 会将对象放入一个待处理队列中，这个字段表示队列中对象的数量。

13. **lazyfree_objects**
- **描述**：已异步释放的对象总数。
- **说明**：表示自 Redis 启动以来，通过异步删除命令释放的对象总数。

14. **allocator_*（如 allocator_allocated, allocator_active, allocator_resident）**
- **描述**：内存分配器的详细统计信息。
- **说明**：
  - **allocator_allocated**：分配器分配的内存总量。
  - **allocator_active**：分配器活跃的内存总量。
  - **allocator_resident**：分配器常驻内存集（RSS）。
  
- **示例**：
  ```
  allocator_allocated: 100000000
  allocator_active: 110000000
  allocator_resident: 120000000
  ```

15. **其他字段**
- **说明**：根据 Redis 版本和编译选项的不同，`INFO memory` 可能还会包含其他字段，如 `maxmemory`、`maxmemory_policy` 等，用于显示内存限制和内存淘汰策略的相关信息。

以下是一个 `INFO memory` 命令的示例输出：

```
# Memory
used_memory:123456789
used_memory_human:117.74M
used_memory_rss:130000000
used_memory_rss_human:123.96M
used_memory_peak:150000000
used_memory_peak_human:142.94M
used_memory_lua:512000
used_memory_lua_human:500.00K
mem_fragmentation_ratio:1.05
mem_allocator:jemalloc-4.0.3
active_defrag_running:0
lazyfree_pending_objects:0
```

## 内存优化建议

根据 `INFO memory` 的输出，可以采取以下优化措施：

1. **监控内存使用**：
   - 定期检查 `used_memory` 和 `used_memory_rss`，确保内存使用在合理范围内。
   - 监控 `mem_fragmentation_ratio`，如果值过高（>1.5），考虑重启 Redis 或进行内存碎片整理。

2. **调整内存分配器**：
   - 根据 `mem_allocator` 字段，调整 Redis 的内存分配器配置，使用更高效的分配器（如 jemalloc）可以减少内存碎片。

3. **配置内存淘汰策略**：
   - 使用 `maxmemory` 和 `maxmemory_policy` 配置参数，设置合适的内存淘汰策略（如 `noeviction`、`allkeys-lru`），在内存不足时自动淘汰不常用的键值对。

4. **使用内存优化功能**：
   - 启用主动内存碎片整理（`activedefrag`），通过配置 `activedefrag_threshold` 和 `activedefrag_cycle_min` 等参数，优化内存碎片。

5. **监控 Lua 脚本内存使用**：
   - 如果使用 Lua 脚本，定期检查 `used_memory_lua`，确保 Lua 引擎不会占用过多内存。

## 内存管理配置

- maxmemory 一般设置为操作系统可用内存的 70％

虽然 70% 是一个常见的推荐值，但在实际应用中，应根据以下因素进行具体调整：

1. **系统总内存**：
   - **大内存服务器**：如果服务器的总内存很大（如 128GB 或以上），可以将 `maxmemory` 设置为更高的比例（如 80% 或 90%），因为操作系统和其他进程对内存的需求相对较小。
   
   - **小内存服务器**：对于内存较小的服务器（如 8GB 或以下），应更保守地设置 `maxmemory`，如 50% 或 60%，以确保操作系统和其他关键进程有足够的内存。

2. **Redis 的角色**：
   - **主节点 vs 从节点**：如果 Redis 实例是主节点（写入频繁），需要更多的内存来处理写操作和内存淘汰，可以设置较低的比例。
   
   - **从节点（只读）**：如果 Redis 实例是从节点（只读），内存需求相对较低，可以设置较高的比例。

3. **工作负载特点**：
   - **内存密集型应用**：如果应用对内存的需求较高（如大量数据存储、复杂的数据结构），应设置较低的比例。
   
   - **读写均衡或读多写少**：如果应用主要是读取数据，写入较少，可以设置较高的比例。

4. **内存淘汰策略**：
   - **不同的淘汰策略**：不同的内存淘汰策略（如 `noeviction`、`allkeys-lru`、`volatile-lru` 等）对内存的需求不同。应根据具体的策略调整 `maxmemory`。
   
   - **预留空间**：确保 `maxmemory` 设置合理，预留足够的空间用于内存淘汰，避免内存耗尽导致的性能问题。

以下是一个配置示例：

```conf
# 设置最大内存为操作系统可用内存的 70%
maxmemory 70%

# 设置内存淘汰策略为 allkeys-lru
maxmemory-policy allkeys-lru
```

或者，直接设置具体的内存值：

```conf
# 设置最大内存为 10GB
maxmemory 10gb

# 设置内存淘汰策略为 volatile-lru
maxmemory-policy volatile-lru
```

# 使用 redis cluster proxy 组件实现集群读写分离







