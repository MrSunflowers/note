# 一、多线程基础

## 1. 线程与进程

&emsp;&emsp;进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。

### 1.1 进程

&emsp;&emsp;进程是拥有资源和独立运行的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序，数据和进程控制块三部分组成

### 1.2 线程

&emsp;&emsp;线程可以理解为在进程中独立运行的子任务，是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。

### 1.3 进程与线程的区别

- 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
- 一个进程由一个或多个线程组成；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

### 1.4 并发与并行

- 并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
- 指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

&emsp;&emsp;并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。

&emsp;&emsp;当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态。

&emsp;&emsp;当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。

### 1.5 多线程编程

&emsp;&emsp;并不是所有的程序都必须采用多线程，也并不是采用多线程性能就会比单线程要好，采用多线程编程的好处如下：

1. 多线程彼此之间采用相同的地址空间，共享大部分的数据，这样和多进程相比，代价比较节俭，因为多进程的话，启动新的进程必须分配给它独立的地址空间，这样需要数据表来维护代码段，数据段和堆栈段等等。
2. 对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式较为费时，而且很不方便。而在多线程环境下，它们之间可以直接共享数据，比如最简单的方式就是共享全局变量。
3. 在多 cpu 的环境下，不同的线程可以运行在不同的 cpu 下，可以并行处理。

### 1.6 其他

&emsp;&emsp;Windows 与 Linux 对于进程和线程的实现和处理方式有所不同。

## 2 java 中创建线程的几中方法

### 2.1 继承 Thread 类

```java
public class FirstThreadTest extends Thread {
    int i = 0;
    //重写run方法，run方法的方法体就是线程执行体
    public void run() {
        for (; i < 100; i++) {
            System.out.println(getName() + "  " + i);
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "  : " + i);
            if (i == 50) {
                new FirstThreadTest().start();
                new FirstThreadTest().start();
            }
        }
    }
}
```

### 2.2 实现 Runnable 接口

```java
public class RunnableThreadTest implements Runnable{
        private int i;
        public void run()
        {
            for(i = 0;i <100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
        public static void main(String[] args)
        {
            for(int i = 0;i < 100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
                if(i==20)
                {
                    RunnableThreadTest rtt = new RunnableThreadTest();
                    new Thread(rtt,"新线程1").start();
                    new Thread(rtt,"新线程2").start();
                }
            }

        }
}
```

&emsp;&emsp;上述两种方法创建的线程在工作时的性质是一样的，没有本质的区别。

### 2.3 通过 Callable 和 Future 创建线程

```java
package com.nf147.Constroller;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {

    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }

}
```