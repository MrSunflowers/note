# 二、对象和变量的并发访问

## 1. synchronized

&emsp;&emsp;非线程安全带来的问题就是多个线程在对同一个对象中的实例变量进行并发访问时。产生脏读，也就是取到的数据其实是被更改过的。

&emsp;&emsp;方法内的变量是线程安全的，而实例变量非线程安全。synchronized 关键字取得的锁都是对象锁，而不是把一段代码或方法当做锁，想要达到同步效果的前提是多个线程访问的是同一个对象，如果多个线程访问多个对象，就会产生多个锁。

&emsp;&emsp;synchronized 关键字具有锁重入功能，也就是在使用时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的，也就是说，在一个 synchronized 方法/块内部调用**本类**其他 synchronized 方法/块时永远可以得到锁，如果不可重入就会造成死锁。可重入锁也支持在父子类继承的环境中，也就是说，在子类的同步方法中完全可以调用父类的同步方法。

&emsp;&emsp;当线程执行出现异常时，其所持有的锁会自动释放。

&emsp;&emsp;同步方法不具有继承性，也就是说子类的方法无法从父类方法继承 synchronized 关键字的作用。

&emsp;&emsp;使用 synchronized 同步块可以减少同步代码的数量来提升运行效率，在使用同步块时需要注意的是，当一个线程访问 object 的同步代码块时，其他线程对同一个 object 中其他同步块的访问将会被阻塞。synchronized(this)也是锁定的当前对象。

