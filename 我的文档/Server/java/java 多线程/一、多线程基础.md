# 一、多线程基础

## 线程与进程

&emsp;&emsp;进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。

### 进程

&emsp;&emsp;进程是拥有资源和独立运行的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序，数据和进程控制块三部分组成

### 线程

&emsp;&emsp;线程可以理解为在进程中独立运行的子任务，是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。

### 进程与线程的区别

- 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
- 一个进程由一个或多个线程组成；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

### 并发与并行

- 并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
- 指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

&emsp;&emsp;并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。

&emsp;&emsp;当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态。

&emsp;&emsp;当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。

### 多线程编程

&emsp;&emsp;并不是所有的程序都必须采用多线程，也并不是采用多线程性能就会比单线程要好，采用多线程编程的好处如下：

1. 多线程彼此之间采用相同的地址空间，共享大部分的数据，这样和多进程相比，代价比较节俭，因为多进程的话，启动新的进程必须分配给它独立的地址空间，这样需要数据表来维护代码段，数据段和堆栈段等等。
2. 对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式较为费时，而且很不方便。而在多线程环境下，它们之间可以直接共享数据，比如最简单的方式就是共享全局变量。
3. 在多 cpu 的环境下，不同的线程可以运行在不同的 cpu 下，可以并行处理。

### 其他

&emsp;&emsp;Windows 与 Linux 对于进程和线程的实现和处理方式有所不同。

##  java 中创建线程的几中方法

### 继承 Thread 类

```java
public class FirstThreadTest extends Thread {
    int i = 0;
    //重写run方法，run方法的方法体就是线程执行体
    public void run() {
        for (; i < 100; i++) {
            System.out.println(getName() + "  " + i);
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "  : " + i);
            if (i == 50) {
                new FirstThreadTest().start();
                new FirstThreadTest().start();
            }
        }
    }
}
```

### 实现 Runnable 接口

```java
public class RunnableThreadTest implements Runnable{
        private int i;
        public void run()
        {
            for(i = 0;i <100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
        public static void main(String[] args)
        {
            for(int i = 0;i < 100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
                if(i==20)
                {
                    RunnableThreadTest rtt = new RunnableThreadTest();
                    new Thread(rtt,"新线程1").start();
                    new Thread(rtt,"新线程2").start();
                }
            }

        }
}
```

&emsp;&emsp;上述两种方法创建的线程在工作时的性质是一样的，没有本质的区别。

###  通过 Callable 和 Future 创建线程

```java
package com.nf147.Constroller;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {

    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }

}
```

## 线程安全与 i--

&emsp;&emsp;对于线程安全来说，常常使用 synchronized 关键字来解决，但在 System.out.println 与 i-- 一起使用时可能会出现问题。

**System.out.println**

```java
public void println(String x) {
    synchronized (this) {
        print(x);
        newLine();
    }
}
```

&emsp;&emsp;可以看到 Java 提供的 println 方法内部是同步的。

```java
public class PrintAndNum implements Runnable{
    private int i = 5;
    @Override
    public void run() {
        System.out.println("i=" + i-- + " - " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        PrintAndNum printAndNum = new PrintAndNum();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
    }
}
```

```text
i=5 - Thread-0
i=2 - Thread-3
i=4 - Thread-1
i=2 - Thread-4
i=3 - Thread-2
```

&emsp;&emsp;在测试结果中还是会出现线程安全问题，原因是虽然 println 方法内部是同步的，但 i-- 操作却是在进入 println 方法之前发生的。

## 线程的停止

&emsp;&emsp;在 java 中停止线程并不能像使用 break 停止一个循环一样干脆。停止一个线程意味着在线程处理完任务之前停掉正在做的操作，也就是放弃当前的操作。虽然看起来简单，但是必须做好正确的防范措施，以便达到预期的效果。停止一个线程可以用 Thread.stop() ,但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且已经作废的方法。

在Java中有3种方法可以停止正在运行的线程:
- 使用退出标志使线程正常终止，也就是当run方法完成后线程终止；
- 使用 stop 方法强行终止线程，但是不推荐使用这个方法，因为 stop 和 suspend、resume 一样，都是过期作废的方法。
- 使用 interrupt 方法中断线程。

### interrupt 方法

&emsp;&emsp;interrupt 方法的使用并不像 break 语句那样，马上就停止循环。调用 interrupt 方法不会马上停止线程，只是在当前线程打了一个停止的标记，并不是真正的停止线程。

```java
public class InterruptTest extends Thread{

    @Override
    public void run() {
        for (int i = 0; i<5000; i++){
            System.out.println(i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptTest interruptTest = new InterruptTest();
        interruptTest.start();
        Thread.sleep(5);
        interruptTest.interrupt();
    }
}
```

### 判断线程是否停止

- interrupted()：测试当前线程是否已经中断。
- isInterrupted()：测试线程是否已经中断。

&emsp;&emsp;interrupted 方法用来测试当前线程是否已经中断，当前线程是指运行 interrupted 方法的线程，官方的解释是该方法还会清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false。

```java
public static void main(String[] args) throws InterruptedException {
    Thread.currentThread().interrupt(); // 中断当前线程
    System.out.println(Thread.interrupted()); //true
    System.out.println(Thread.interrupted()); //false
}
```

&emsp;&emsp;isInterrupted 方法用来测试线程 Thread 对象是否已经中断，但不会清除线程的中断状态。

```java
public static void main(String[] args) throws InterruptedException {
    Thread.currentThread().interrupt();
    System.out.println(Thread.currentThread().isInterrupted()); //true
    System.out.println(Thread.currentThread().isInterrupted()); //true
}
```

&emsp;&emsp;可以使用 interrupt 方法和 return 来控制线程的停止。

```java
public class InterruptTest extends Thread{

    @Override
    public void run() {
        for (int i = 0; i<5000; i++){
            System.out.println(i);
            if(Thread.currentThread().isInterrupted()){
                System.out.println("线程中断退出");
                return;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptTest interruptTest = new InterruptTest();
        interruptTest.start();
        Thread.sleep(5);
        interruptTest.interrupt();
    }
}
```

&emsp;&emsp;同时需要注意的是如果在 sleep 状态下停止线程，会抛出 InterruptedException 异常并清除停止状态值，使之变成 false，反之亦然。

### stop 方法

&emsp;&emsp;调用 stop 方法会抛出 java.lang.ThreadDeath 异常，但在通常情况下，此异常不需要显式捕捉。

&emsp;&emsp;stop 方法已被标记为弃用方法，因为如果强行让线程停止则可能导致一些清理性工作无法完成，另外一个情况就是使用 Thread.stop 停止线程会导致该线程解锁所有持有的锁，可能导致数据得不到同步处理，出现数据不一致的问题。

```java
public class StopDemo {

	public static void main(String[] args) {
		StopThread thread=new StopThread();
		thread.start();
		try {
			//休眠1秒，确保i变量自增成功
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			//一般会处理中断异常，这里作为例子就直接打印到控制台了
			e.printStackTrace();
		}
		//暂停线程
		thread.stop();
		while(thread.isAlive()){//确保线程已经终止
		
		}
		//输出结果
		thread.print();
	}
	
	private static class StopThread extends Thread{
	
		private int i=0;
	
		private int j=0;
	
		@Override
		public void run(){
			synchronized (this) {//增加同步锁，确保线程安全
				++i;
				try {
					//休眠10秒,模拟耗时操作
					Thread.sleep(10000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				++j;
			}
		}
		/**
		 * 打印i和j
		 */
		public void print(){
			System.out.println("i="+i+" j="+j);
		}
	}
}
```

&emsp;&emsp;StopThread 类正常运行的时候，最终调用 print() 方法输出的值应该为 i=1 j=1，但是由于调用了 stop() 方法强制终止了线程的运行，导致 i 已经自增了，但是 j 并未自增，破坏了这个类的线程安全。

## 线程暂停与恢复

&emsp;&emsp;线程的暂停意味着该线程还可以恢复运行，在 java 多线程中，可以使用 suspend() 方法暂停线程，使用 resume() 方法恢复线程的执行。

### suspend 和 resume 

- suspend() 方法的作用是将一个线程挂起（暂停）；
- resume() 方法的作用则是将一个挂起的线程重新开始并继续向下运行。

```java
package com.company.ThreadSuspend;

import java.text.SimpleDateFormat;

public class SuspendThread {

    public static void main(String[] args) {
        SimpleDateFormat f = new SimpleDateFormat("HH:mm:ss");
        
        try {
            MyThread2 t = new MyThread2();
            t.start();
            Thread.sleep(1000);
            
            //暂停线程
            t.suspend();
            System.out.println("暂停线程：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            Thread.sleep(5000);
            System.out.println("暂停线程5秒后：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            
            //继续线程
            t.resume();
            System.out.println("--恢复线程--");
            Thread.sleep(5000);
            System.out.println("--恢复线程5秒后--");
            
            //再次暂停线程
            t.suspend();
            System.out.println("再次暂停：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            Thread.sleep(5000);
            System.out.println("再次暂停5秒后：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
}

class MyThread2 extends Thread{
    private long num = 0;
    
    public void setNum(long num) {
        this.num = num;
    }
    
    public long getNum(){
        return num;
    }

    @Override
    public void run() {
        while(true){
            num++;
        }
    }
    
}

```

&emsp;&emsp;从例子中可以看出，线程确实被暂停了，而且还能恢复继续运行。

### 缺点

&emsp;&emsp;因为 suspend 方法不会释放锁，而如果调用了 suspend 方法的目标线程在挂起时对某一重要的系统资源持有锁，那么在目标线程重新开始之前其他任何线程都无法访问该资源。

&emsp;&emsp;使用 suspend 和 resume 方法也容易出现因为线程的暂停而导致数据不同步的问题。

```java
package com.company.ThreadSuspend;

public class TestObject {

    public static void main(String[] args) throws InterruptedException {
        final UserObject obj = new UserObject();
        Thread thread1 = new Thread() {
            public void run() {
                obj.setValue("lisi", "30");
            };
        };
        
        thread1.setName("thread1");
        thread1.start();
        thread1.sleep(500);
        
        Thread thread2 = new Thread(){
            public void run() {
                obj.printValue();
            };
        };
        
        thread2.start();
        
    }
    
    static class UserObject {
        private String name = "zhangsan";
        private String age = "18";
        
        public void setValue(String name, String age) {
            this.name = name;
            if(Thread.currentThread().getName().equals("thread1")){
                System.out.println("暂停 thread1");
                Thread.currentThread().suspend();
            }
            this.age = age;
        }
        
        private void printValue(){
            System.out.println(name + " : " + age);
        }
    }

}

暂停 thread1
lisi : 18
```

### yield

&emsp;&emsp; yiled() 方法的作用是：让当前处于运行状态的线程退回到可运行状态，让出抢占资源的机会。但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片。**Thread.yield() 只会释放当前cpu资源，如果该线程中持有锁的话，不会释放该持有的锁资源。**

&emsp;&emsp;sleep与yield方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程.而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。

### 线程优先级

Java 线程优先级使用 1 ~ 10 的整数表示：

- 最低优先级 1：Thread.MIN_PRIORITY
- 最高优先级 10：Thread.MAX_PRIORITY
- 普通优先级 5：Thread.NORM_PRIORITY

&emsp;&emsp;Java 默认的线程优先级是父线程的优先级，而非普通优先级 Thread.NORM_PRIORITY，因为主线程默认优先级是普通优先级 Thread.NORM_PRIORITY，所以如果不主动设置线程优先级，则新创建的线程的优先级就是普通优先级 Thread.NORM_PRIORITY。

&emsp;&emsp;高优先级的线程比低优先级的线程有更高的几率得到执行，实际上这和操作系统及虚拟机版本相关，有可能即使设置了线程的优先级也不会产生任何作用。

&emsp;&emsp;setPriority 方法只能更改本线程组及其子线程组（递归）的最大优先级，但不能影响已经创建的直接或间接属于该线程组的线程的优先级，也就是说，即使目前有一个子线程的优先级比新设定的线程组优先级大，也不会更改该子线程的优先级。只有当试图改变子线程的优先级或者创建新的子线程的时候，线程组的最大优先级才起作用。

# 二、对象和变量的并发访问

线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。

## synchronized

&emsp;&emsp;非线程安全带来的问题就是多个线程在对同一个对象中的实例变量进行并发访问时。产生脏读，也就是取到的数据其实是被更改过的。

&emsp;&emsp;**方法内的变量是线程安全的，而实例变量非线程安全。**synchronized 关键字取得的锁都是对象锁，而不是把一段代码或方法当做锁，想要达到同步效果的前提是多个线程访问的是同一个对象，如果多个线程访问多个对象，就会产生多个锁。

&emsp;&emsp;**synchronized 关键字具有锁重入功能**。也就是在使用时，当一个线程得到一个对象锁后，再次请求此对象的锁时是可以再次得到该对象的锁的，也就是说，在一个 synchronized 方法/块内部调用**本类**其他 synchronized 方法/块时永远可以得到锁，如果不可重入就会造成死锁。可重入锁也支持在父子类继承的环境中，在子类的同步方法中完全可以调用父类的同步方法。

&emsp;&emsp;当线程执行出现异常时，其所持有的锁会自动释放。

&emsp;&emsp;同步方法不具有继承性，也就是说**子类的方法无法从父类方法继承 synchronized 关键字的作用**。

&emsp;&emsp;使用 synchronized 同步块可以减少同步代码的数量来提升运行效率，在使用同步块时需要注意的是，当一个线程访问 object 的同步代码块时，其他线程对同一个 object 中其他同步块的访问将会被阻塞。synchronized(this)也是锁定的当前对象，这说明 synchronized 使用的对象监视器是一个。另外，synchronized 加在 static 方法上时是为当前的 *.java 文件所对应的 Class 类进行持锁，而加到非 static 方法上是为当前对象上锁。synchronized(class) 代码块的作用与 synchronized 加在 static 方法上的作用一样。

## String 常量池的特性

```java
public class main {
    public static void main(String[] args) {
        String a = "a";
        String b = "a";
        System.out.println(a == b);//true
    }
}
```

&emsp;&emsp;由于 String 常量池的存在会导致两个方法拥有同样的锁。

## 死锁的检测

&emsp;&emsp;可以使用 JDK 自带的工具来检测是否有死锁的现象，使用 cmd 进入 jdk 安装的 bin 目录，执行 jps 命令，得到运行的线程 id ，再执行 jstack 命令检测死锁现象。在程序设计时要避免互相持有对方锁的情况。

## 锁对象的改变

&emsp;&emsp;只要对象不变，即使对象的属性被改变，运行的结果还是同步的。

## volatile 

&emsp;&emsp;volatile 关键字的作用是**强制从公共堆栈中取得变量的值**，而不是从线程私有数据栈中取得变量的值以及**禁止指令重排序**，在 jvm 被设置为 server 模式运行时，为了提升运行效率，线程一直在线程私有堆栈中获取变量。多线程访问 volatile 时不会发生阻塞，而 synchronized 会出现阻塞，volatile 可以保证数据的可见性，但无法保证原子性，volatile 主要的使用场景是在多线程环境下，每个线程可以感知实例变量被更改了，并且可以获取最新的值使用。但是在对 volatile 实例变量修改时其实并不是一个原子操作，也就是非线程安全的。
1. 从内存中取出 i 值；

2. 计算 i 值；

3. 将 i 值写入内存中；

假如在步骤 2 计算 i 值时，其他线程也修改 i 值，那么此时就会出现脏读现象。

[Java并发编程之volatile可见及非原子特性](https://blog.csdn.net/weixin_44692700/article/details/121491956)

此时就需要使用原子类进行 i++ 操作，但

[原子类也并不完全安全](https://www.jianshu.com/p/f7dbb1e7b5c5)

# 三、线程间通信

&emsp;&emsp;线程之间可以相互通信和协作，线程通信主要可以分为三种方式，分别为共享内存、消息传递和管道流，每种方式可以有不同的方法来实现。

## 等待/通知机制（wait/notify）

[Java的等待-通知(wait-notify)机制](https://blog.csdn.net/y277an/article/details/98697454)














# 常见问题

1. start()与run()的区别，调用start()方法会创建一个新的子线程并启动，run()方法只是Thread的一个普通方法的调用。
2. Thread和Runnable的关系Runable接口并没有start方法，需要依赖Thread来启动，Thread是实现了Runnable接口的类，使得run支持多线程，因类的单一继承原则，推荐多使用Runnable
3. 如何给run()方法传参，实现的方式主要有三种：构造函数传参，成员变量传参，回调函数传参。
4. 如何处理线程的返回值，实现的方式有三种：主线程等待法，使用 Thread 类的join() 阻塞当前线程以等待子线程处理完毕，通过 Callable 接口实现：通过 FutureTask 或者线程池获取