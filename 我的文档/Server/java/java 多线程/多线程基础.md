[TOC]

# 多线程基础

## 线程与进程

进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。

### 进程

进程是拥有资源和独立运行的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序，数据和进程控制块三部分组成

### 线程

线程可以理解为在进程中独立运行的子任务，是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。

### 进程与线程的区别

- 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
- 一个进程由一个或多个线程组成；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

### 并发与并行

- 并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
- 指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。

当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态。

当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。

### 多线程编程

并不是所有的程序都必须采用多线程，也并不是采用多线程性能就会比单线程要好，采用多线程编程的好处如下：

1. 多线程彼此之间采用相同的地址空间，共享大部分的数据，这样和多进程相比，代价比较节俭，因为多进程的话，启动新的进程必须分配给它独立的地址空间，这样需要数据表来维护代码段，数据段和堆栈段等等。
2. 对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式较为费时，而且很不方便。而在多线程环境下，它们之间可以直接共享数据，比如最简单的方式就是共享全局变量。
3. 在多 cpu 的环境下，不同的线程可以运行在不同的 cpu 下，可以并行处理。

### 其他

Windows 与 Linux 对于进程和线程的实现和处理方式有所不同。

##  java 中创建线程的几中方法

### 继承 Thread 类

```java
public class FirstThreadTest extends Thread {
    int i = 0;
    //重写run方法，run方法的方法体就是线程执行体
    public void run() {
        for (; i < 100; i++) {
            System.out.println(getName() + "  " + i);
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "  : " + i);
            if (i == 50) {
                new FirstThreadTest().start();
                new FirstThreadTest().start();
            }
        }
    }
}
```

### 实现 Runnable 接口

```java
public class RunnableThreadTest implements Runnable{
        private int i;
        public void run()
        {
            for(i = 0;i <100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
        public static void main(String[] args)
        {
            for(int i = 0;i < 100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
                if(i==20)
                {
                    RunnableThreadTest rtt = new RunnableThreadTest();
                    new Thread(rtt,"新线程1").start();
                    new Thread(rtt,"新线程2").start();
                }
            }

        }
}
```

上述两种方法创建的线程在工作时的性质是一样的，没有本质的区别。

###  通过 Callable 和 Future 创建线程

```java
package com.nf147.Constroller;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {

    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }

}
```

## 线程的停止

在 java 中停止线程并不能像使用 break 停止一个循环一样干脆。停止一个线程意味着在线程处理完任务之前停掉正在做的操作，也就是放弃当前的操作。虽然看起来简单，但是必须做好正确的防范措施，以便达到预期的效果。停止一个线程可以用 Thread.stop() ,但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且已经作废的方法。

在Java中有3种方法可以停止正在运行的线程:
- 使用退出标志使线程正常终止，也就是当run方法完成后线程终止；
- 使用 stop 方法强行终止线程，但是不推荐使用这个方法，因为 stop 和 suspend、resume 一样，都是过期作废的方法。
- 使用 interrupt 方法中断线程。

### interrupt 方法

interrupt 方法的使用并不像 break 语句那样，马上就停止循环。调用 interrupt 方法不会马上停止线程，只是在当前线程打了一个停止的标记，并不是真正的停止线程。

```java
public class InterruptTest extends Thread{

    @Override
    public void run() {
        for (int i = 0; i<5000; i++){
            System.out.println(i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptTest interruptTest = new InterruptTest();
        interruptTest.start();
        Thread.sleep(5);
        interruptTest.interrupt();
    }
}
```

### 判断线程是否停止

- interrupted()：测试当前线程是否已经中断。
- isInterrupted()：测试线程是否已经中断。

interrupted 方法用来测试当前线程是否已经中断，当前线程是指运行 interrupted 方法的线程，官方的解释是该方法还会清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false。

```java
public static void main(String[] args) throws InterruptedException {
    Thread.currentThread().interrupt(); // 中断当前线程
    System.out.println(Thread.interrupted()); //true
    System.out.println(Thread.interrupted()); //false
}
```

isInterrupted 方法用来测试线程 Thread 对象是否已经中断，但不会清除线程的中断状态。

```java
public static void main(String[] args) throws InterruptedException {
    Thread.currentThread().interrupt();
    System.out.println(Thread.currentThread().isInterrupted()); //true
    System.out.println(Thread.currentThread().isInterrupted()); //true
}
```

可以使用 interrupt 方法和 return 来控制线程的停止。

```java
public class InterruptTest extends Thread{

    @Override
    public void run() {
        for (int i = 0; i<5000; i++){
            System.out.println(i);
            if(Thread.currentThread().isInterrupted()){
                System.out.println("线程中断退出");
                return;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptTest interruptTest = new InterruptTest();
        interruptTest.start();
        Thread.sleep(5);
        interruptTest.interrupt();
    }
}
```

同时需要注意的是如果在 sleep 状态下停止线程，会抛出 InterruptedException 异常并清除停止状态值，使之变成 false，反之亦然。

### stop 方法

调用 stop 方法会抛出 java.lang.ThreadDeath 异常，但在通常情况下，此异常不需要显式捕捉。

stop 方法已被标记为弃用方法，因为如果强行让线程停止则可能导致一些清理性工作无法完成，另外一个情况就是使用 Thread.stop 停止线程会导致该线程解锁所有持有的锁，可能导致数据得不到同步处理，出现数据不一致的问题。

```java
public class StopDemo {

	public static void main(String[] args) {
		StopThread thread=new StopThread();
		thread.start();
		try {
			//休眠1秒，确保i变量自增成功
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			//一般会处理中断异常，这里作为例子就直接打印到控制台了
			e.printStackTrace();
		}
		//暂停线程
		thread.stop();
		while(thread.isAlive()){//确保线程已经终止
		
		}
		//输出结果
		thread.print();
	}
	
	private static class StopThread extends Thread{
	
		private int i=0;
	
		private int j=0;
	
		@Override
		public void run(){
			synchronized (this) {//增加同步锁，确保线程安全
				++i;
				try {
					//休眠10秒,模拟耗时操作
					Thread.sleep(10000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				++j;
			}
		}
		/**
		 * 打印i和j
		 */
		public void print(){
			System.out.println("i="+i+" j="+j);
		}
	}
}
```

StopThread 类正常运行的时候，最终调用 print() 方法输出的值应该为 i=1 j=1，但是由于调用了 stop() 方法强制终止了线程的运行，导致 i 已经自增了，但是 j 并未自增，破坏了这个类的线程安全。

## 线程暂停与恢复

线程的暂停意味着该线程还可以恢复运行，在 java 多线程中，可以使用 suspend() 方法暂停线程，使用 resume() 方法恢复线程的执行。

### suspend 和 resume 

- suspend() 方法的作用是将一个线程挂起（暂停）；
- resume() 方法的作用则是将一个挂起的线程重新开始并继续向下运行。

```java
package com.company.ThreadSuspend;

import java.text.SimpleDateFormat;

public class SuspendThread {

    public static void main(String[] args) {
        SimpleDateFormat f = new SimpleDateFormat("HH:mm:ss");
        
        try {
            MyThread2 t = new MyThread2();
            t.start();
            Thread.sleep(1000);
            
            //暂停线程
            t.suspend();
            System.out.println("暂停线程：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            Thread.sleep(5000);
            System.out.println("暂停线程5秒后：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            
            //继续线程
            t.resume();
            System.out.println("--恢复线程--");
            Thread.sleep(5000);
            System.out.println("--恢复线程5秒后--");
            
            //再次暂停线程
            t.suspend();
            System.out.println("再次暂停：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            Thread.sleep(5000);
            System.out.println("再次暂停5秒后：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
}

class MyThread2 extends Thread{
    private long num = 0;
    
    public void setNum(long num) {
        this.num = num;
    }
    
    public long getNum(){
        return num;
    }

    @Override
    public void run() {
        while(true){
            num++;
        }
    }
    
}

```

从例子中可以看出，线程确实被暂停了，而且还能恢复继续运行。

#### 缺点

因为 suspend 方法不会释放锁，而如果调用了 suspend 方法的目标线程在挂起时对某一重要的系统资源持有锁，那么在目标线程重新开始之前其他任何线程都无法访问该资源。

使用 suspend 和 resume 方法也容易出现因为线程的暂停而导致数据不同步的问题。

```java
package com.company.ThreadSuspend;

public class TestObject {

    public static void main(String[] args) throws InterruptedException {
        final UserObject obj = new UserObject();
        Thread thread1 = new Thread() {
            public void run() {
                obj.setValue("lisi", "30");
            };
        };
        
        thread1.setName("thread1");
        thread1.start();
        thread1.sleep(500);
        
        Thread thread2 = new Thread(){
            public void run() {
                obj.printValue();
            };
        };
        
        thread2.start();
        
    }
    
    static class UserObject {
        private String name = "zhangsan";
        private String age = "18";
        
        public void setValue(String name, String age) {
            this.name = name;
            if(Thread.currentThread().getName().equals("thread1")){
                System.out.println("暂停 thread1");
                Thread.currentThread().suspend();
            }
            this.age = age;
        }
        
        private void printValue(){
            System.out.println(name + " : " + age);
        }
    }

}

暂停 thread1
lisi : 18
```

### yield

 yiled() 方法的作用是：让当前处于运行状态的线程退回到可运行状态，让出抢占资源的机会。但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片。**Thread.yield() 只会释放当前cpu资源，如果该线程中持有锁的话，不会释放该持有的锁资源。**

sleep与yield方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程.而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。

### 线程优先级

Java 线程优先级使用 1 ~ 10 的整数表示：

- 最低优先级 1：Thread.MIN_PRIORITY
- 最高优先级 10：Thread.MAX_PRIORITY
- 普通优先级 5：Thread.NORM_PRIORITY

Java 默认的线程优先级是父线程的优先级，而非普通优先级 Thread.NORM_PRIORITY，因为主线程默认优先级是普通优先级 Thread.NORM_PRIORITY，所以如果不主动设置线程优先级，则新创建的线程的优先级就是普通优先级 Thread.NORM_PRIORITY。

高优先级的线程比低优先级的线程有更高的几率得到执行，实际上这和操作系统及虚拟机版本相关，有可能即使设置了线程的优先级也不会产生任何作用。

setPriority 方法只能更改本线程组及其子线程组（递归）的最大优先级，但不能影响已经创建的直接或间接属于该线程组的线程的优先级，也就是说，即使目前有一个子线程的优先级比新设定的线程组优先级大，也不会更改该子线程的优先级。只有当试图改变子线程的优先级或者创建新的子线程的时候，线程组的最大优先级才起作用。

# 线程池

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务

示例

```java
public class ThreadTest {

    public static void main(String[] args) throws InterruptedException, IOException {
        //核心线程数
        int corePoolSize = 2;
        //最大线程数
        int maximumPoolSize = 4;
        //最小空闲时间10s
        long keepAliveTime = 10;
        //时间单位秒
        TimeUnit unit = TimeUnit.SECONDS;
        //等待队列
        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);
        //线程工厂
        ThreadFactory threadFactory = new NameTreadFactory();
        //拒绝处理策略
        RejectedExecutionHandler handler = new MyIgnorePolicy();
        //创建线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,
                workQueue, threadFactory, handler);
        //// 预启动所有核心线程
        //executor.prestartAllCoreThreads();
        
        for (int i = 1; i <= 10; i++) {

            MyTask task = new MyTask(String.valueOf(i));
            //执行线程
            executor.execute(task);
            Thread.sleep(2000);
        }

        System.in.read();//阻塞主线程
    }

    /**
     * 自定义的 TreadFactory
     */
    static class NameTreadFactory implements ThreadFactory {
        //使用原子类计数
        private final AtomicInteger mThreadNum = new AtomicInteger(1);
        //创建线程的具体逻辑
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, "my-thread-" + mThreadNum.getAndIncrement());
            System.out.println(t.getName() + " has been created");
            return t;
        }
    }
    /**
     * 自定义的处理策略
     */
    public static class MyIgnorePolicy implements RejectedExecutionHandler {

        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            doLog(r, e);
        }

        private void doLog(Runnable r, ThreadPoolExecutor e) {
            // 可做日志记录等
            System.err.println( r.toString() + " rejected");
//          System.out.println("completedTaskCount: " + e.getCompletedTaskCount());
        }
    }

    static class MyTask implements Runnable {
        private final String name;

        public MyTask(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + " : " + this + " is running!");
                Thread.sleep(40000); //让任务执行慢点
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        public String getName() {
            return name;
        }

        @Override
        public String toString() {
            return "MyTask [name=" + name + "]";
        }
    }
}

//-----------结果-------------
my-thread-1 has been created
my-thread-1 : MyTask [name=1] is running!
my-thread-2 has been created
my-thread-2 : MyTask [name=2] is running!
my-thread-3 has been created
my-thread-3 : MyTask [name=5] is running!
my-thread-4 has been created
my-thread-4 : MyTask [name=6] is running!
MyTask [name=7] rejected
MyTask [name=8] rejected
MyTask [name=9] rejected
MyTask [name=10] rejected
my-thread-1 : MyTask [name=3] is running!
my-thread-2 : MyTask [name=4] is running!
```

## 线程池构造器参数

ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。

下面解释下一下构造器中各个参数的含义：

- corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
- maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
- keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
- unit：参数keepAliveTime的时间单位
- workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响
- threadFactory：线程工厂，主要用来创建线程；
- handler：表示当拒绝处理任务时的策略

## 线程池状态

在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：

```java
volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
```

runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；

下面的几个static final变量表示runState可能的几个取值。

- 当创建线程池后，初始时，线程池处于RUNNING状态；
- 如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；
- 如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；
- 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。

## 任务执行过程

- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会先尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

## 线程池中的线程初始化

默认情况下，创建线程池之后，线程池中是**没有线程**的，需要提交任务之后才会创建线程。

在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：

- prestartCoreThread()：初始化一个核心线程；
- prestartAllCoreThreads()：初始化所有核心线程

## 任务缓存队列及排队策略

在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。

workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：

- ArrayBlockingQueue：基于数组的先进先出队列，此创建时必须指定大小；
- LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；
- synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。

### synchronousQueue

`SynchronousQueue` 是 Java 中 `java.util.concurrent` 包提供的一个特殊的阻塞队列，它不存储任何元素。它在内部实现上没有容量的概念，也就是说，它不维护任何存储空间来存储元素。`SynchronousQueue` 的主要作用是作为线程之间传递数据的通道，它保证了在生产者和消费者之间传递数据时的同步性。

特点

1. **容量为零**：`SynchronousQueue` 没有内部容量，不能存储任何元素。这意味着，当一个线程尝试向队列中插入一个元素时，它必须等待另一个线程来取走这个元素；反之亦然。

2. **同步性**：`SynchronousQueue` 保证了在生产者和消费者之间传递数据时的同步性。当一个线程尝试向队列中插入一个元素时，它会阻塞直到另一个线程来取走这个元素；同样，当一个线程尝试从队列中取出一个元素时，它也会阻塞直到有元素被插入。

3. **公平性**：`SynchronousQueue` 可以通过构造函数参数来选择是否需要公平性。公平性意味着线程按照它们请求访问队列的顺序来获得访问权。如果选择公平性，那么等待时间最长的线程将优先获得访问权。

4. **无界**：虽然 `SynchronousQueue` 没有容量限制，但它并不是无界队列。它不存储元素，所以不会因为队列满而拒绝插入操作。

使用场景

`SynchronousQueue` 适用于以下场景：

- **生产者-消费者模式**：当生产者和消费者数量大致相等时，可以使用 `SynchronousQueue` 来确保生产者和消费者之间的直接传递，提高效率。
- **线程池中的任务传递**：在使用 `Executors.newCachedThreadPool()` 创建的线程池中，`SynchronousQueue` 被用作任务队列。这种线程池会根据需要创建新线程，但不会保留空闲线程，而是使用 `SynchronousQueue` 来传递任务给线程。
- **交换数据**：在需要在两个线程之间交换数据的场景中，`SynchronousQueue` 可以作为中间媒介，确保数据的同步交换。

示例代码

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class SynchronousQueueExample {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个SynchronousQueue
        SynchronousQueue<Integer> queue = new SynchronousQueue<>();

        // 创建一个线程池
        ExecutorService executor = Executors.newCachedThreadPool();

        // 生产者线程
        executor.execute(() -> {
            try {
                // 生产者向队列中插入元素
                queue.put(1);
                System.out.println("Producer put 1");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 消费者线程
        executor.execute(() -> {
            try {
                // 消费者从队列中取出元素
                Integer value = queue.take();
                System.out.println("Consumer took " + value);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 关闭线程池
        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);
    }
}
```

在这个例子中，我们创建了一个 `SynchronousQueue` 实例，并启动了两个线程：一个生产者线程和一个消费者线程。生产者线程向队列中插入一个元素，而消费者线程从队列中取出这个元素。由于 `SynchronousQueue` 的特性，这两个操作是同步的，生产者线程会阻塞直到消费者线程取走元素，反之亦然。

`SynchronousQueue` 是一个非常特殊的队列，它在并发编程中扮演着重要的角色，特别是在需要确保线程间直接传递数据的场景中。

## 任务拒绝策略

当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：

```
ThreadPoolExecutor.AbortPolicy:默认策略，丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列中最旧的任务，然后重新尝试执行当前任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
```
## 线程池的关闭

ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：

- shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
- shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

## 线程池容量的动态调整

ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()

- setCorePoolSize：设置核心池大小
- setMaximumPoolSize：设置线程池最大能创建的线程数目大小

当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。

## 内置线程池

在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：

```java
Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
```

下面是这三个静态方法的具体实现

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```
从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。

- newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；
- newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；
- newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。

### newScheduledThreadPool

`Executors.newScheduledThreadPool(int corePoolSize)` 是 Java 中 `java.util.concurrent.Executors` 类提供的一个工厂方法，用于创建一个可调度的线程池。这个线程池允许你安排任务在指定的延迟后执行，或者定期执行。

参数

- `corePoolSize`：线程池中核心线程的数量。这些线程将一直存在，即使它们处于空闲状态。

特点

1. **延迟执行**：你可以安排任务在指定的延迟后执行。这意味着任务将在延迟时间结束后立即执行。

2. **周期性执行**：你可以安排任务周期性地执行。这可以是固定延迟（任务执行之间的时间间隔是固定的）或固定速率（任务执行的频率是固定的）。

3. **线程池管理**：`ScheduledThreadPoolExecutor`（`newScheduledThreadPool` 返回的类型）管理着一个线程池，这些线程负责执行调度的任务。如果需要，它可以创建新的线程来执行任务。

4. **任务调度**：`ScheduledThreadPoolExecutor` 使用一个延迟队列（`DelayedWorkQueue`）来管理任务。这个队列按照任务的执行时间排序，确保最早需要执行的任务排在队列的最前面。

使用场景

`ScheduledThreadPoolExecutor` 适用于以下场景：

- **定时任务**：需要在特定时间执行的任务，例如定时发送邮件、清理缓存等。
- **周期性任务**：需要周期性执行的任务，例如定期更新数据、执行健康检查等。
- **后台任务**：需要在后台执行的任务，但需要控制执行的时间。

示例代码

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPoolExample {
    public static void main(String[] args) {
        // 创建一个ScheduledThreadPoolExecutor，核心线程数为2
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

        // 安排一个任务在10秒后执行
        scheduler.schedule(() -> {
            System.out.println("Task executed after 10 seconds");
        }, 10, TimeUnit.SECONDS);

        // 安排一个任务每5秒执行一次，从现在开始
        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("Task executed every 5 seconds");
        }, 0, 5, TimeUnit.SECONDS);

        // 安排一个任务在10秒后开始执行，然后每隔5秒执行一次
        scheduler.scheduleWithFixedDelay(() -> {
            System.out.println("Task executed with 5 seconds delay");
        }, 10, 5, TimeUnit.SECONDS);

        // 关闭线程池
        scheduler.shutdown();
    }
}
```

在这个例子中，我们创建了一个 `ScheduledThreadPoolExecutor` 实例，并安排了三个任务：

1. 第一个任务在10秒后执行一次。
2. 第二个任务从现在开始，每5秒执行一次。
3. 第三个任务在10秒后开始执行，然后每隔5秒执行一次，但每次执行之间有5秒的延迟。

`ScheduledThreadPoolExecutor` 提供了灵活的任务调度机制，使得定时和周期性任务的执行变得简单。在使用时，需要注意关闭线程池以释放资源，如示例中的 `shutdown()` 方法所示。

## 如何合理配置线程池大小

一般需要根据任务的类型来配置线程池大小：

如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 CPU核心数+1


如果是IO密集型任务，参考值可以设置为2*CPU核心数


# 对象和变量的并发访问

线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。

## synchronized

非线程安全带来的问题就是多个线程在对同一个对象中的实例变量进行并发访问时。产生脏读，也就是取到的数据其实是被更改过的。

**方法内的变量是线程安全的，而实例变量非线程安全**。synchronized 关键字取得的锁都是对象锁，属于独占式的悲观锁，而不是把一段代码或方法当做锁，想要达到同步效果的前提是多个线程访问的是同一个对象，如果多个线程访问多个对象，就会产生多个锁。

**synchronized 关键字具有锁重入功能**。也就是在使用时，当一个线程得到一个对象锁后，再次请求此对象的锁时是可以再次得到该对象的锁的，也就是说，在一个 synchronized 方法/块内部调用**本类**其他 synchronized 方法/块时永远可以得到锁，如果不可重入就会造成死锁。可重入锁也支持在父子类继承的环境中，在子类的同步方法中完全可以调用父类的同步方法。

当线程执行出现异常时，其所持有的锁会自动释放。

同步方法不具有继承性，也就是说**子类覆盖的方法无法从父类方法继承 synchronized 关键字的作用**。

使用 synchronized 同步块可以减少同步代码的数量来提升运行效率，在使用同步块时需要注意的是，当一个线程访问 object 的同步代码块时，其他线程对同一个 object 中其他同步块的访问将会被阻塞。synchronized(this)也是锁定的当前对象，这说明 synchronized 使用的对象监视器是一个。另外，synchronized 加在 static 方法上时是为当前的 *.java 文件所对应的 Class 类进行持锁，而加到非 static 方法上是为当前对象上锁。synchronized(class) 代码块的作用与 synchronized 加在 static 方法上的作用一样。

### 锁的类型

在Java中，锁可以分为两种类型：

1. **对象锁**：用于同步实例方法和同步代码块。每个对象都有一个与之关联的锁，当一个线程进入 `synchronized` 代码块时，它会获取该对象的锁。如果另一个线程尝试进入同一个对象的 `synchronized` 代码块，它将被阻塞，直到第一个线程释放锁。

2. **类锁**：用于同步静态方法和静态同步代码块。类锁是与类的Class对象关联的，而不是与类的实例关联。当一个线程进入静态 `synchronized` 代码块时，它会获取该类的类锁。如果另一个线程尝试进入同一个类的静态 `synchronized` 代码块，它将被阻塞，直到第一个线程释放锁。

### 锁的队列

当多个线程尝试获取同一个对象的锁时，它们会被放入一个等待队列中。这个队列是按照线程请求锁的顺序排列的，遵循先进先出（FIFO）的原则。当锁被释放时，等待队列中的第一个线程将被唤醒，并尝试获取锁。

### 锁的公平性

Java的锁默认是非公平的，这意味着线程获取锁的顺序并不一定与它们请求锁的顺序相同。然而，从Java 1.6开始，可以通过设置锁的属性来实现公平锁。公平锁确保线程按照它们请求锁的顺序来获取锁，从而避免饥饿现象。

### 示例

```java
public class SynchronizedExample {
    public synchronized void synchronizedMethod() {
        // 同步方法
    }

    public void someMethod() {
        synchronized (this) {
            // 同步代码块
        }
    }
}
```

在上面的示例中，`synchronizedMethod` 是一个同步方法，它使用对象锁。当一个线程调用这个方法时，它会获取 `SynchronizedExample` 对象的锁。如果另一个线程尝试调用这个方法，它将被阻塞，直到第一个线程完成方法执行并释放锁。

`someMethod` 方法中的代码块使用 `synchronized` 关键字和 `this` 关键字作为锁对象。这意味着它与 `synchronizedMethod` 使用相同的锁。如果一个线程在 `someMethod` 中的同步代码块中，另一个线程尝试调用 `synchronizedMethod` 或 `someMethod`，它将被阻塞。

### 锁对象的改变

只要对象不变，即使对象的属性被改变，运行的结果还是同步的。

### Synchronized 核心组件

`synchronized` 的核心组件包括监视器（Monitor）和锁（Lock）。

### 监视器（Monitor）

监视器是 Java 中实现同步的基础概念，它是一种同步机制，用于控制对对象的并发访问。每个对象都有一个与之关联的监视器，监视器负责管理线程对对象的访问。

监视器包含以下三个主要部分：

1. **锁**：监视器锁是监视器的核心，用于控制对对象的访问。当一个线程进入 `synchronized` 代码块或方法时，它会尝试获取对象的监视器锁。如果锁已被其他线程持有，该线程将被阻塞，直到锁被释放。

2. **等待集**：等待集是监视器中的一个队列，用于存储等待获取锁的线程。当线程调用 `Object.wait()` 方法时，它会释放锁并进入等待集。线程可以被其他线程通过 `Object.notify()` 或 `Object.notifyAll()` 方法唤醒。

3. **条件变量**：条件变量是监视器中的一个机制，允许线程在满足特定条件之前等待。每个条件变量关联一个等待集，线程可以调用 `Object.wait()` 方法进入等待集，直到其他线程调用 `Object.notify()` 或 `Object.notifyAll()` 方法唤醒它们。

### 锁（Lock）

在 Java 中，锁是监视器的实现细节。当线程尝试进入 `synchronized` 代码块或方法时，它会尝试获取对象的锁。锁可以是以下两种类型之一：

#### 偏向锁

**偏向锁（Biased Locking）**：偏向锁是 Java 6 引入的一种优化，它为锁的持有者提供了一种优化。如果一个线程在一段时间内频繁地访问同一个对象，那么这个线程可以偏向于这个对象，从而减少锁的获取和释放开销。

偏向锁（Biased Locking）是Java虚拟机（JVM）为了提高单线程执行同步代码块的性能而引入的一种锁优化机制，目的是减少线程在获取和释放锁时的开销，特别是在锁竞争不激烈的情况下。

**实现原理**

1. **偏向状态**：当一个线程首次访问同步代码块时，JVM会将对象头中的锁标记设置为偏向模式，并记录下该线程的ID。此时，对象处于偏向状态，表示该对象偏向于第一个访问它的线程。

2. **锁偏向**：当同一个线程再次访问同一个对象的同步代码块时，JVM会检查对象头中的锁标记是否为偏向状态，并且线程ID是否与当前线程ID匹配。如果匹配，该线程将无需进行任何同步操作，直接进入同步代码块执行，从而减少了锁的获取和释放的开销。

3. **撤销偏向**：如果在偏向状态下，有其他线程尝试访问该对象的同步代码块，JVM会撤销偏向状态，并将锁升级为轻量级锁或重量级锁。撤销偏向通常发生在以下几种情况：
   - 另一个线程尝试获取该对象的锁。
   - 调用对象的 `hashCode()` 方法。
   - 调用 `wait()` 或 `notify()` 方法。
   - 调用 `System.identityHashCode()` 方法。

4. **锁升级**：偏向锁的撤销可能会导致锁升级。如果撤销偏向后，锁升级为轻量级锁，JVM会尝试使用自旋锁（Spin Lock）来减少线程上下文切换的开销。如果自旋失败，锁会进一步升级为重量级锁，此时会使用操作系统的互斥量（Mutex）来实现同步。

**偏向锁的启用与禁用**

- **启用**：在Java 6及以后的版本中，默认情况下偏向锁是启用的。可以通过JVM参数 `-XX:+UseBiasedLocking` 来显式启用或禁用偏向锁。
- **禁用**：在某些情况下，如果锁竞争非常激烈，偏向锁可能会带来额外的开销。此时，可以通过JVM参数 `-XX:-UseBiasedLocking` 来禁用偏向锁。

偏向锁通过记录线程ID来减少锁的获取和释放开销，适用于锁竞争不激烈的情况。在实际应用中，如果锁竞争频繁，JVM会自动撤销偏向锁，以避免性能损失。开发者可以根据应用的实际情况来调整JVM参数，以优化锁的性能。在Java 9及以后的版本中，偏向锁的实现细节有所变化，但基本原理保持不变。

#### 轻量级锁

**轻量级锁（Lightweight Locking）**：轻量级锁是偏向锁的进一步优化。当线程尝试获取锁时，如果锁未被其他线程持有，那么线程可以快速地获取锁，而不需要进行复杂的同步操作。

轻量级锁（Lightweight Locking）是Java虚拟机（JVM）为了减少线程在获取和释放锁时的开销而引入的一种锁优化机制。轻量级锁主要针对的是那些在多线程环境下，锁竞争不激烈，但又不满足偏向锁条件的情况。轻量级锁的实现原理主要基于自旋锁（Spin Lock）的概念。

**实现原理**

1. **锁记录**：当线程尝试获取轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录（Lock Record），用于存储锁对象的Mark Word的拷贝。

2. **CAS操作**：线程使用CAS（Compare-And-Swap）操作尝试将对象头中的Mark Word更新为指向当前线程栈帧中锁记录的指针。如果成功，表示线程成功获取了轻量级锁，可以进入同步代码块执行。

3. **自旋等待**：如果CAS操作失败，说明有其他线程已经持有该锁，当前线程将进入自旋状态（Spin），不断尝试获取锁。自旋是一种忙等待，线程在原地循环等待，直到锁被释放。

4. **锁升级**：如果自旋等待的时间过长（超过一定的自旋次数），JVM会将轻量级锁升级为重量级锁。重量级锁使用操作系统的互斥量（Mutex）来实现，这会导致线程从用户态切换到内核态，增加了上下文切换的开销。

5. **锁释放**：当线程执行完同步代码块后，会使用CAS操作将对象头的Mark Word恢复为原来的值，并将锁释放。如果在自旋过程中有其他线程尝试获取锁，那么这些线程将有机会在锁释放后获取到轻量级锁。

适用场景

轻量级锁适用于那些锁竞争不激烈，且线程持有锁的时间较短的场景。在这种情况下，自旋等待可以避免线程上下文切换的开销，从而提高性能。

注意事项

- **自旋开销**：自旋等待虽然避免了线程上下文切换的开销，但如果自旋等待的时间过长，反而会增加CPU的使用率，影响其他线程的执行。
- **锁升级**：如果锁竞争激烈，轻量级锁会升级为重量级锁，这会增加线程上下文切换的开销。因此，轻量级锁适用于锁竞争不激烈的场景。
- **锁粒度**：轻量级锁适用于锁粒度较小的场景，如果同步代码块较大，线程持有锁的时间较长，那么自旋等待可能会导致CPU资源的浪费。

轻量级锁是JVM为了提高多线程环境下锁的性能而引入的一种优化机制。通过减少线程上下文切换的开销，轻量级锁在适当的场景下可以显著提高程序的性能。然而，开发者需要根据实际的并发情况和锁的使用模式来选择合适的锁策略。在Java中，锁的优化是自动进行的，开发者通常不需要直接管理这些细节。

#### 重量级锁

**重量级锁（Heavyweight Locking）**：当线程竞争激烈时，锁会升级为重量级锁。重量级锁使用操作系统的互斥量（mutex）来实现，这会导致线程在用户态和内核态之间切换，增加开销。

**实现原理**

**互斥量（Mutex）**

重量级锁使用操作系统提供的互斥量来实现线程间的同步。互斥量是一种同步机制，它允许线程在访问共享资源时进行互斥访问。当一个线程获取了互斥量后，其他试图获取该互斥量的线程将被阻塞，直到互斥量被释放。

**线程阻塞与唤醒**

当线程尝试获取一个已经被其他线程持有的重量级锁时，该线程会被阻塞。在阻塞状态下，线程不会占用CPU资源，而是进入等待状态。当持有锁的线程释放锁时，操作系统会唤醒一个或多个等待该锁的线程，这些线程将重新进入竞争状态，尝试获取锁。

**线程上下文切换**

重量级锁的使用涉及到线程的上下文切换。当线程被阻塞时，操作系统需要保存当前线程的执行上下文（包括CPU寄存器的状态、程序计数器等），并将控制权交给其他线程。当线程被唤醒时，操作系统需要恢复被唤醒线程的上下文，并将控制权交还给它。这个过程称为上下文切换，它会带来一定的性能开销。

**锁的获取与释放**

重量级锁的获取和释放过程涉及系统调用，这通常比轻量级锁的自旋等待和CAS操作要慢。在重量级锁的实现中，JVM会调用操作系统的API来获取和释放锁，这通常涉及到用户态和内核态之间的切换，增加了开销。

**锁的升级**

在Java中，锁的升级是一个渐进的过程。当一个锁从轻量级锁升级为重量级锁时，JVM会将锁对象的Mark Word中的锁标志位从轻量级锁的标识改为重量级锁的标识，并将锁对象的指针指向一个重量级锁的结构体。这个结构体包含了等待队列、持有锁的线程等信息。在Java中，锁的升级是自动进行的，目的是为了提高并发性能。而锁的降级则不是直接支持的，因为一旦线程获取了重量级锁，它必须显式地释放该锁。在重量级锁被释放后，其他线程才有机会获取该锁。在Java中，没有机制允许一个线程在持有重量级锁的情况下，将其降级为轻量级锁或无锁状态。

### 自旋锁

上文多次提到自旋锁，自旋锁（Spin Lock）是一种简单的同步机制，它允许线程在等待获取锁时进行忙等待（busy-waiting），而不是阻塞（blocking）。自旋锁的实现原理基于原子操作，通常使用CAS（Compare-And-Swap）指令来实现。

**实现原理**

1. **原子操作**：自旋锁的核心是原子操作，即在多线程环境下，一个操作一旦开始，就不会被其他线程打断。在Java中，`AtomicInteger`类的`getAndIncrement()`方法就是一个原子操作的例子，它使用了CAS指令。

2. **CAS操作**：CAS操作是一种无锁的同步机制，它包含三个参数：内存位置（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相等，则将内存位置的值更新为新值，并返回true；否则，不进行任何操作，并返回false。CAS操作是自旋锁实现的关键，因为它允许线程在不阻塞的情况下尝试获取锁。

3. **自旋等待**：当一个线程尝试获取自旋锁时，它会不断执行CAS操作，检查锁是否可用。如果锁被占用，线程会继续尝试，直到锁被释放。这个过程称为自旋等待。

4. **锁释放**：当持有锁的线程完成其工作并释放锁时，它会将锁的状态设置为可用。其他等待的线程在自旋过程中会检测到锁状态的变化，并尝试获取锁。

**优点**

- **减少上下文切换**：自旋锁避免了线程阻塞和唤醒的开销，因为线程在等待时不会放弃CPU，而是继续执行，直到锁可用。

- **适用于短时间持有锁**：如果锁的持有时间很短，自旋锁可以提供比传统阻塞锁更好的性能，因为上下文切换的开销可能大于自旋等待的开销。

**缺点**

- **CPU资源消耗**：如果锁的持有时间较长，自旋锁会导致CPU资源的浪费，因为线程会持续占用CPU进行无用的自旋。

- **不公平性**：自旋锁可能导致不公平的锁获取，因为先到达的线程可能在自旋等待，而后来的线程可能在锁释放时立即获取到锁。

- **死锁风险**：如果多个线程在自旋等待时，它们都尝试获取多个锁，可能会导致死锁。

**使用场景**

自旋锁适用于以下场景：

- **锁的持有时间非常短**：如果锁的持有时间非常短，自旋锁可以提供较好的性能。

- **单核处理器**：在单核处理器上，自旋锁可以避免线程上下文切换的开销。

- **实时系统**：在实时系统中，自旋锁可以提供确定性的响应时间。

在Java中，`java.util.concurrent`包中的`ReentrantLock`类提供了可选择的自旋锁机制。通过设置`tryLock()`方法的超时参数，可以实现自旋等待一段时间，如果在这段时间内无法获取锁，则放弃自旋，转而阻塞等待。

#### 在多核处理器上的表现

在多核处理器上，自旋锁的表现取决于多个因素，包括锁的使用频率、锁的持有时间、处理器核心的数量以及线程的调度策略。自旋锁在多核处理器上的表现通常比单核处理器上更为复杂，但也有其优势和潜在的性能提升。

**优势**

1. **减少上下文切换**：在多核处理器上，自旋锁可以减少线程上下文切换的开销。因为线程在等待锁时不会放弃CPU，而是继续执行，直到锁可用。这样，当锁最终被释放时，等待的线程可以立即开始执行，而不需要经历从就绪状态到运行状态的上下文切换。

2. **并发性**：多核处理器可以同时执行多个线程，因此，即使一个线程在自旋等待锁，其他线程仍然可以在其他核心上执行。这可以提高整体的并发性能。

**潜在问题**

1. **CPU资源消耗**：如果锁的持有时间较长，自旋锁会导致CPU资源的浪费，因为线程会持续占用CPU进行无用的自旋等待。在多核处理器上，这可能导致CPU资源的不公平分配，因为自旋的线程可能会占用过多的CPU时间。

2. **缓存一致性开销**：在多核处理器上，每个核心都有自己的缓存。当一个线程修改了共享数据时，需要通过缓存一致性协议（如MESI协议）来确保其他核心上的缓存行失效，以保持数据的一致性。自旋锁可能导致频繁的缓存行失效，增加缓存一致性开销。

3. **线程调度**：在多核处理器上，线程调度策略对自旋锁的性能有很大影响。如果操作系统调度策略不合理，可能会导致某些核心上的线程长时间自旋等待，而其他核心上的线程却无法充分利用。

**总结**

在多核处理器上，自旋锁可以提供较好的性能，特别是在锁的持有时间较短的情况下。然而，如果锁的持有时间较长，或者自旋等待的线程数量过多，自旋锁可能会导致CPU资源的浪费和缓存一致性开销的增加。

### 锁的内部状态和线程在获取锁时可能经历的几个阶段

这些概念与Java的内置锁机制（监视器锁）有关，它们是Java虚拟机（JVM）在内部实现的，用于管理线程对对象监视器（锁）的访问

1. **Wait Set**:
   - 当线程调用 `Object.wait()` 方法时，它会释放锁，并进入等待集（Wait Set）。等待集中的线程等待被其他线程通过 `Object.notify()` 或 `Object.notifyAll()` 方法唤醒。一旦被唤醒，线程将重新进入竞争队列（Contention List）以尝试重新获取锁。

2. **Contention List**:
   - 竞争队列是所有请求锁的线程的集合。当线程尝试获取一个锁时，如果锁已被其他线程持有，该线程将被放入竞争队列中等待。竞争队列中的线程将等待锁的释放。

3. **Entry List**:
   - Entry List 是竞争队列中的一个子集，包含那些已经准备好竞争锁的线程。当锁被释放时，Entry List 中的线程将被允许竞争锁。Entry List 有时也被称为“阻塞队列”或“等待队列”。

4. **OnDeck**:
   - OnDeck 线程是竞争队列中下一个准备获取锁的线程。当锁被释放时，OnDeck 线程将被允许尝试获取锁。在某些实现中，OnDeck 线程可能被赋予一些优先级，以提高获取锁的效率。

5. **Owner**:
   - Owner 线程是当前持有锁的线程。Owner 线程可以执行 `synchronized` 代码块或方法。当 Owner 线程完成其工作并释放锁时，锁将变为可用状态。

6. **!Owner**:
   - 当 Owner 线程释放锁时，它就不再是 Owner 线程了。此时，锁变为可用状态，其他线程可以尝试获取它。

## ReentrantLock

- 使用 lock() 加锁，使用 unLock() 释放锁
- 使用对象监视器 Condition 的await()/signalAll()来实现 wait()/notify()效果
- Condition 可以将线程分组,并选择性通知,粒度更细,这也是和 synchronized 的区别之一

生产者与消费者程序示例:

```java
public class Fo {

    private final List<Integer> list = new ArrayList<>(10);
    private final ReentrantLock lock = new ReentrantLock();
    //创建两个对象监视器,分别用于通知生产者和消费者
    private final Condition InCondition = lock.newCondition();
    private final Condition OutCondition = lock.newCondition();
    public static final int maxSize = 10;

    public Condition getInCondition() {
        return InCondition;
    }

    public Condition getOutCondition() {
        return OutCondition;
    }

    public ReentrantLock getLock() {
        return lock;
    }

    public Integer getFoSize(){
        return list.size();
    }

    public void putFo(){
        list.add(1);
    }

    public void gutFo(){
        list.remove(0);
    }

}
```

```java
public class In implements Runnable {

    private final Fo fo;

    public In(Fo fo) {
        this.fo = fo;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(4000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            doIn();
        }
    }

    private void doIn() {
        try {
            //加锁
            fo.getLock().lock();
            if (fo.getFoSize() >= Fo.maxSize) {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  已满等待");
                //作为生产者等待
                fo.getInCondition().await();
            } else {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  可以生产");
                fo.putFo();
                //唤醒所有消费者
                fo.getOutCondition().signalAll();
                System.out.println(Thread.currentThread().getName() + "生产后当前数量：" + fo.getFoSize());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            //释放锁
            fo.getLock().unlock();
        }
    }

}
```

```java
public class Out implements Runnable {

    private final Fo fo;

    public Out(Fo fo) {
        this.fo = fo;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(4000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            doOut();
        }
    }

    private void doOut() {
        try {
            //加锁
            fo.getLock().lock();
            if (fo.getFoSize() > 0) {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  可以拿取");
                fo.gutFo();
                //唤醒所有生产者
                fo.getInCondition().signalAll();
                System.out.println(Thread.currentThread().getName() + "拿取后当前数量：" + fo.getFoSize());
            } else {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  无货等待");
                //作为消费者等待
                fo.getOutCondition().await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            //释放锁
            fo.getLock().unlock();
        }
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Fo fo = new Fo();
        new Thread(new In(fo)).start();
        new Thread(new In(fo)).start();
        new Thread(new In(fo)).start();

        new Thread(new Out(fo)).start();
    }
}
```

### 公平锁与非公平锁

锁Lock分为公平锁与非公平锁,公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的,即先来先得FIFO先进先出顺序,而非公平锁就是一种获取锁的强占机制,是随机获得锁的

### ReentrantLock 的常用方法

- lock.getHoldCount() 查询当前线程持有此锁的个数,也就是调用lock()方法的次数,比如重入锁就是2
- lock.getQueueLength() 返回**正等待**获取此锁的线程估计个数
- lock.getWaitQueueLength(Condition condition) 返回等待此锁给定相关条件 condition 的估计线程数,比如5个线程都执行了同一个 condition 的 await 方法,则返回5
- lock.hasQueuedThreads() 查询是否有线程正等待获取此锁
- lock.hasQueuedThread(Thread thread) 查询指定线程是否正在等待获取此锁
- lock.hasWaiters(Condition condition) 查询是否有线程正等待与此锁定有关的 condition 条件
- lock.isFair() 查询是否为公平锁
- lock.isHeldByCurrentThread() 查询当前线程是否持有此锁
- lock.isLocked() 查询此锁定是否被任意线程持有
- lock.lockInterruptibly() 如果当前线程未被中断,则获取锁定,如果已被中断抛出异常
- lock.tryLock() 尝试获取锁,在锁未被别人获取时才会获取该锁
- lock.tryLock(long timeout, TimeUnit unit) 如果锁在给定时间内未被其他线程获取且当前线程未被中断,则获取该锁
- Condition.awaitUninterruptibly() 线程在调用condition.await()后处于await状态，此时调用thread.interrupt()会可能报错,但是使用condition.awaitUninterruptibly()后，调用thread.interrupt()则不会报错
- Condition.awaitUntil(Date deadline) 此方法可以证明线程在等待时间达到前，可以被其他线程提前唤醒

### 读写锁

ReentrantLock是完全排他锁,即同一时间只能有一个线程在执行,JDK中还提供了一种读写锁,来优化运行效率
ReentrantReadWriteLock 读写锁有两个锁,一个是读锁,也称为共享锁,另一个是写锁,也称为排他锁,读读锁之间不互斥,读写锁互斥,写写锁互斥,在没有线程进行写入操作时,进行读取的多个线程都可以获取读锁,而进行写入操作的线程只有获取写锁后才能进行写入操作,即多个线程可以同时读取,但同一时刻只允许一个线程进行写入

- lock.writeLock().lock() 写锁
- lock.readLock().lock() 读锁

## 死锁的检测

可以使用 JDK 自带的工具来检测是否有死锁的现象，使用 cmd 进入 jdk 安装的 bin 目录，执行 jps 命令，得到运行的线程 id ，再执行 jstack 命令检测死锁现象。在程序设计时要避免互相持有对方锁的情况。

# 线程间通信

线程之间可以相互通信和协作，线程通信主要可以分为三种方式，分别为共享内存、消息传递和管道流，每种方式可以有不同的方法来实现。

## 等待/通知机制（wait/notify）

[Java的等待-通知(wait-notify)机制](https://blog.csdn.net/y277an/article/details/98697454)

- wait/notify 方法必须在 synchronized 同步块中调用
- 必须是当前锁的对象调用
- 调用wait方法后线程进入等待状态同时释放锁，并使当前线程从运行状态退出进入等待队列
- 调用notify方法后不会释放锁
- 调用notify会随机唤醒一个等待当前锁的线程，使其退出等待队列进入可运行状态
- 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞挂起的线程，一个线程被唤醒后才会进入就绪队列，被wait后进入阻塞队列。
- 处于wait状态的线程调用interrupt方法会出现异常。
- wait(long)方法等待一段时间后自动唤醒，也可以在等待时间内被其他线程唤醒。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/spring/202203231020627.png)

## 通过管道进行线程间的通信

在java中提供了各种各样的输入输出流用于数据操作，其中管道流是一种特殊的流，可以用于在不同的线程之间传送数据。

管道流一共有四种：

- PipedReader
- PipedWriter
- PipedOutputStream
- PipedInputStream

示例程序：

```java
public class Thread1 implements Runnable{

    private final PipedReader reader;

    public Thread1(PipedReader reader) {
        this.reader = reader;
    }

    @Override
    public void run() {
        char[] chars = new char[20];
        int readLength = 0;
        try {
            //由于开始并没有数据被写入，线程在此阻塞，直到有数据写入，才继续向下运行
            readLength = reader.read(chars);
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(String.valueOf(chars,0,readLength));
    }
}
```

```java
public class Thread2 implements Runnable{

    private final PipedWriter writer;

    public Thread2(PipedWriter writer) {
        this.writer = writer;
    }

    @Override
    public void run() {
        try {
            writer.write("传递给Thread1的数据");
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Main {
    private static final PipedReader reader = new PipedReader();
    private static final PipedWriter writer = new PipedWriter();

    public static void main(String[] args) {

        try {
            //通过下面两种方法使两个流之间产生连接
            //writer.connect(reader);
            reader.connect(writer);
            new Thread(new Thread1(reader)).start();
            Thread.sleep(2000);
            new Thread(new Thread2(writer)).start();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

}
```

## join

在很多情况下，主线程创建子线程，如果子线程中要进行大量的耗时运算，主线程往往早于子线程结束，此时，如果子线程想等待子线程执行完成后再结束，比如主线程需要获取子线程处理的结果，此时可以使用join方法。

```java
public class SubThread implements Runnable{
    @Override
    public void run() {
        int secValue = (int) (Math.random()*10000);
        System.out.println("子线程需要处理时间："+secValue);
        try {
            Thread.sleep(secValue);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("子线程处理完成");
    }
}
```

```java
public class MainThread implements Runnable{
    @Override
    public void run() {
        Thread subThread = new Thread(new SubThread());
        System.out.println("主线程开始");
        subThread.start();
        System.out.println("主线程等待子线程处理");
        try {
            subThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程结束");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        new Thread(new MainThread()).start();
    }
}
```

- 方法join的作用是使**当前线程**无限期阻塞，等待join**所属**线程执行run方法中的任务
- join方法具有使线程排队运行的作用，类似于同步运行，于synchronized关键字的区别是，join在内部使用wait方法进行等待，而synchronized关键字使用对象锁原理同步
- join方法遇到interrupt会出现异常。
- join(long)其中long为等待时间，join(long)与sleep(long)的区别与wait()与sleep(long)的区别相同，join(long)会释放锁，sleep不会

## ThreadLocal

ThreadLocal主要用来存储每个线程自己的值。

- 第一次获取值为null；
- 每个线程拥有自己独立的值，互不影响；
- 底层容器使用 ThreadLocalMap 实现，每个线程中都有自己的一个 ThreadLocalMap
- ThreadLocalMap 又使用 ThreadLocal 实例作为其 key，这样就实现了横向与纵向的双重隔离
- remove 方法是删除特定的 ThreadLocal，建议在 ThreadLocal 使用完后一定要执行此方法。
- 调用remove()方法最佳时机是线程运行结束之前的finally代码块中调用，这样能完全避免操作不当导致的内存泄漏，这种主动清理的方式比惰性删除有效。

[ThreadLocal详解](https://blog.csdn.net/wangnanwlw/article/details/108866086)

## InheritableThreadLocal

- InheritableThreadLocal 类可以在子线程中取得父线程继承下来的值。
- 如果子线程在取得值的同时，主线程将 InheritableThreadLocal 中的值进行更改，那么子线程取到的值还是旧值

## volatile 

volatile 关键字的作用是**强制从公共堆栈中取得变量的值**，而不是从线程私有数据栈中取得变量的值以及**禁止指令重排序**，在 jvm 被设置为 server 模式运行时，为了提升运行效率，线程一直在线程私有堆栈中获取变量。多线程访问 volatile 时不会发生阻塞，而 synchronized 会出现阻塞，volatile 可以保证数据的可见性，但无法保证原子性，volatile 主要的使用场景是在多线程环境下，每个线程可以感知实例变量被更改了，并且可以获取最新的值使用。但是在对 volatile 实例变量修改时其实并不是一个原子操作，也就是非线程安全的。
1. 从内存中取出 i 值；

2. 计算 i 值；

3. 将 i 值写入内存中；

假如在步骤 2 计算 i 值时，其他线程也修改 i 值，那么此时就会出现脏读现象。

[Java并发编程之volatile可见及非原子特性](https://blog.csdn.net/weixin_44692700/article/details/121491956)

此时就需要使用原子类进行 i++ 操作，但

[原子类也并不完全安全](https://www.jianshu.com/p/f7dbb1e7b5c5)

# 线程安全

## 线程安全与 i--

对于线程安全来说，常常使用 synchronized 关键字来解决，但在 System.out.println 与 i-- 一起使用时可能会出现问题。

**System.out.println**

```java
public void println(String x) {
    synchronized (this) {
        print(x);
        newLine();
    }
}
```

可以看到 Java 提供的 println 方法内部是同步的。

```java
public class PrintAndNum implements Runnable{
    private int i = 5;
    @Override
    public void run() {
        System.out.println("i=" + i-- + " - " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        PrintAndNum printAndNum = new PrintAndNum();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
    }
}
```

```text
i=5 - Thread-0
i=2 - Thread-3
i=4 - Thread-1
i=2 - Thread-4
i=3 - Thread-2
```

在测试结果中还是会出现线程安全问题，原因是虽然 println 方法内部是同步的，但 i-- 操作却是在进入 println 方法之前发生的。

## String 常量池的特性

```java
public class main {
    public static void main(String[] args) {
        String a = "a";
        String b = "a";
        System.out.println(a == b);//true
    }
}
```

由于 String 常量池的存在会导致两个方法拥有同样的锁。

# 定时器

在 JDK 中 Timer 类主要负责计划任务功能

```java
public class Demo1 {
    private static final Timer timer = new Timer(false
            /*是否使定时器作为守护线程启动,
            守护线程在程序运行结束后快速结束,
            定时任务也不再运行*/);
     static class MyTimer extends TimerTask{
        @Override
        public void run() {
            System.out.println(new Date().toLocaleString());
			
        }
    }

    public static void main(String[] args) throws ParseException {
        MyTimer myTimer = new MyTimer();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date parse = sdf.parse("2022-03-29 09:53:00");
		//在指定时间执行
        timer.schedule(myTimer,parse);
		//在指定时间之后,每隔3s执行一次
        //timer.schedule(myTimer,parse,3000);
		//在当前时间5后,每隔3s执行一次
        //timer.schedule(myTimer,5000,3000);
    }
}
```

- 执行时间晚于当前时间:在未来执行
- 执行时间早于当前时间:立即执行
- TimerTask以队列方式顺序执行,前面任务执行时间长会影响后面任务启动时间
- schedule方法scheduleAtFixedRate方法都是顺序执行,所以没有线程安全问题
- schedule与scheduleAtFixedRate方法的区别只在任务没有延时的情况
  - schedule:如果任务没有延时,则下一次任务的开始时间参考上一次任务的开始时间计算
  - scheduleAtFixedRate:如果任务没有延时,则下一次任务的开始时间参考上一次任务的结束时间计算
  - 在延时执行的情况下,两个方法没有区别,都是参考上一次任务的结束时间计算
  - schedule方法不具有追赶执行机制,而scheduleAtFixedRate具有追赶执行机制,错过的任务会补充性执行

# java 8 CompletableFuture 异步编排

https://juejin.cn/post/6970558076642394142

# 常见问题

1. start()与run()的区别，调用start()方法会创建一个新的子线程并启动，run()方法只是Thread的一个普通方法的调用。
2. Thread和Runnable的关系Runable接口并没有start方法，需要依赖Thread来启动，Thread是实现了Runnable接口的类，使得run支持多线程，因类的单一继承原则，推荐多使用Runnable
3. 如何给run()方法传参，实现的方式主要有三种：构造函数传参，成员变量传参，回调函数传参。
4. 如何处理线程的返回值，实现的方式有三种：主线程等待法，使用 Thread 类的join() 阻塞当前线程以等待子线程处理完毕，通过 Callable 接口实现：通过 FutureTask 或者线程池获取

# 利用原子类实现CAS递增

```java
package com.company;

import java.util.concurrent.atomic.AtomicInteger;

public class Main {

    private final AtomicInteger atomicInteger = new AtomicInteger(0);

    public static void main(String[] args) {
        Main main = new Main();
        int andIncrement = main.getAndIncrement();
        System.out.println(andIncrement);
    }

    public final int getAndIncrement() {
        int current;
        int next;
        do {
            current = atomicInteger.get();
            next = current >= Integer.MAX_VALUE ? 0 : current + 1;
            // CAS 操作，操作不成功则重复
        } while (!atomicInteger.compareAndSet(current, next));
        return next;
    }
}

```

