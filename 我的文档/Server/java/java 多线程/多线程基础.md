[TOC]

# 多线程基础

## 线程与进程

进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。

### 进程

进程是拥有资源和独立运行的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序，数据和进程控制块三部分组成

### 线程

线程可以理解为在进程中独立运行的子任务，是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。

### 进程与线程的区别

- 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
- 一个进程由一个或多个线程组成；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

### 并发与并行

- 并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
- 指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。

当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态。

当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。

### 多线程编程

并不是所有的程序都必须采用多线程，也并不是采用多线程性能就会比单线程要好，采用多线程编程的好处如下：

1. 多线程彼此之间采用相同的地址空间，共享大部分的数据，这样和多进程相比，代价比较节俭，因为多进程的话，启动新的进程必须分配给它独立的地址空间，这样需要数据表来维护代码段，数据段和堆栈段等等。
2. 对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式较为费时，而且很不方便。而在多线程环境下，它们之间可以直接共享数据，比如最简单的方式就是共享全局变量。
3. 在多 cpu 的环境下，不同的线程可以运行在不同的 cpu 下，可以并行处理。

### 其他

Windows 与 Linux 对于进程和线程的实现和处理方式有所不同。

### 守护线程

在Java中，线程分为两种类型：守护线程（Daemon Thread）和用户线程（User Thread）。它们的主要区别在于它们的生命周期和对Java虚拟机（JVM）的影响。

**用户线程（User Thread）**

- **生命周期**：用户线程是Java程序的主线程，或者由用户创建并启动的线程。这些线程在JVM中运行，直到它们完成自己的任务或被显式地终止。
- **对JVM的影响**：JVM会等待所有用户线程完成执行后才会退出。这意味着，如果JVM中只有守护线程在运行，JVM将立即退出，而不会等待守护线程完成。
- **用途**：用户线程通常用于执行应用程序的主要任务，如处理用户请求、执行业务逻辑等。

**守护线程（Daemon Thread）**

- **生命周期**：守护线程是为其他线程提供服务的线程，如垃圾回收线程、后台监控线程等。守护线程在JVM中运行，但它们的生命周期依赖于用户线程。当所有用户线程都结束时，守护线程也会被JVM终止。
- **对JVM的影响**：守护线程不会阻止JVM的退出。如果JVM中没有用户线程在运行，即使还有守护线程在运行，JVM也会退出。
- **用途**：守护线程通常用于执行后台任务，如垃圾回收、日志记录、监控等。

**如何设置守护线程**

在Java中，可以使用`Thread`类的`setDaemon(true)`方法将一个线程设置为守护线程。必须在调用`start()`方法之前设置守护线程状态，否则会抛出`IllegalThreadStateException`异常。

```java
Thread daemonThread = new Thread(() -> {
    // 执行后台任务
});
daemonThread.setDaemon(true); // 设置为守护线程
daemonThread.start(); // 启动线程
```

**注意事项**

- 守护线程不应该执行任何重要的任务，因为它们可能会在任何时刻被JVM终止。
- 守护线程不应该依赖于用户线程的执行结果，因为它们可能在用户线程完成之前就被终止。
- 守护线程的使用应该谨慎，因为它们的生命周期与用户线程紧密相关。

在实际应用中，守护线程通常用于执行那些不需要等待完成的后台任务，而用户线程则用于执行应用程序的主要逻辑。理解这两种线程的区别对于设计和实现多线程应用程序非常重要。

当执行Thread Dump（线程转储）时，会打印出当前JVM中所有线程的状态信息。在这些信息中，如果一个线程被标记为“daemon”，则表示该线程是一个守护线程。守护线程在JVM中运行，但它们的生命周期依赖于用户线程。当所有用户线程都结束时，守护线程也会被JVM终止。

守护线程包括但不限于以下几种：

1. **服务守护进程**：这些线程为应用程序提供后台服务，如日志记录、监控等。

2. **编译守护进程**：在某些Java环境中，编译守护进程用于动态编译Java代码。

3. **监听 Ctrl+Break 的守护进程**：在Windows平台上，某些Java应用程序可能会使用守护线程来监听Ctrl+Break事件，以便在需要时执行特定操作。

4. **Finalizer 守护进程**：这是Java垃圾回收机制的一部分，用于执行对象的`finalize()`方法。

5. **引用处理守护进程**：在Java中，引用对象（如软引用、弱引用等）的处理通常由守护线程完成。

6. **GC 守护进程**：垃圾回收（Garbage Collection）线程，负责回收不再使用的对象。

##  java 中创建线程的几中方法

### 继承 Thread 类

```java
public class FirstThreadTest extends Thread {
    int i = 0;
    //重写run方法，run方法的方法体就是线程执行体
    public void run() {
        for (; i < 100; i++) {
            System.out.println(getName() + "  " + i);
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "  : " + i);
            if (i == 50) {
                new FirstThreadTest().start();
                new FirstThreadTest().start();
            }
        }
    }
}
```

### 实现 Runnable 接口

```java
public class RunnableThreadTest implements Runnable{
        private int i;
        public void run()
        {
            for(i = 0;i <100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
        public static void main(String[] args)
        {
            for(int i = 0;i < 100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
                if(i==20)
                {
                    RunnableThreadTest rtt = new RunnableThreadTest();
                    new Thread(rtt,"新线程1").start();
                    new Thread(rtt,"新线程2").start();
                }
            }

        }
}
```

上述两种方法创建的线程在工作时的性质是一样的，没有本质的区别。

###  通过 Callable 和 Future 创建线程

```java
package com.nf147.Constroller;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {

    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }

}
```

## 线程的停止

在 java 中停止线程并不能像使用 break 停止一个循环一样干脆。停止一个线程意味着在线程处理完任务之前停掉正在做的操作，也就是放弃当前的操作。虽然看起来简单，但是必须做好正确的防范措施，以便达到预期的效果。停止一个线程可以用 Thread.stop() ,但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且已经作废的方法。

在Java中有3种方法可以停止正在运行的线程:
- 使用退出标志使线程正常终止，也就是当run方法完成后线程终止；
- 使用 stop 方法强行终止线程，但是不推荐使用这个方法，因为 stop 和 suspend、resume 一样，都是过期作废的方法。
- 使用 interrupt 方法中断线程。

### interrupt 方法

interrupt 方法的使用并不像 break 语句那样，马上就停止循环。调用 interrupt 方法不会马上停止线程，只是在当前线程打了一个停止的标记，并不是真正的停止线程。

```java
public class InterruptTest extends Thread{

    @Override
    public void run() {
        for (int i = 0; i<5000; i++){
            System.out.println(i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptTest interruptTest = new InterruptTest();
        interruptTest.start();
        Thread.sleep(5);
        interruptTest.interrupt();
    }
}
```

### 判断线程是否停止

- interrupted()：测试当前线程是否已经中断。
- isInterrupted()：测试线程是否已经中断。

interrupted 方法用来测试当前线程是否已经中断，当前线程是指运行 interrupted 方法的线程，官方的解释是该方法还会清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false。

```java
public static void main(String[] args) throws InterruptedException {
    Thread.currentThread().interrupt(); // 中断当前线程
    System.out.println(Thread.interrupted()); //true
    System.out.println(Thread.interrupted()); //false
}
```

isInterrupted 方法用来测试线程 Thread 对象是否已经中断，但不会清除线程的中断状态。

```java
public static void main(String[] args) throws InterruptedException {
    Thread.currentThread().interrupt();
    System.out.println(Thread.currentThread().isInterrupted()); //true
    System.out.println(Thread.currentThread().isInterrupted()); //true
}
```

可以使用 interrupt 方法和 return 来控制线程的停止。

```java
public class InterruptTest extends Thread{

    @Override
    public void run() {
        for (int i = 0; i<5000; i++){
            System.out.println(i);
            if(Thread.currentThread().isInterrupted()){
                System.out.println("线程中断退出");
                return;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptTest interruptTest = new InterruptTest();
        interruptTest.start();
        Thread.sleep(5);
        interruptTest.interrupt();
    }
}
```

同时需要注意的是如果在 sleep 状态下停止线程，会抛出 InterruptedException 异常并清除停止状态值，使之变成 false，反之亦然。

### stop 方法

调用 stop 方法会抛出 java.lang.ThreadDeath 异常，但在通常情况下，此异常不需要显式捕捉。

stop 方法已被标记为弃用方法，因为如果强行让线程停止则可能导致一些清理性工作无法完成，另外一个情况就是使用 Thread.stop 停止线程会导致该线程解锁所有持有的锁，可能导致数据得不到同步处理，出现数据不一致的问题。

```java
public class StopDemo {

	public static void main(String[] args) {
		StopThread thread=new StopThread();
		thread.start();
		try {
			//休眠1秒，确保i变量自增成功
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			//一般会处理中断异常，这里作为例子就直接打印到控制台了
			e.printStackTrace();
		}
		//暂停线程
		thread.stop();
		while(thread.isAlive()){//确保线程已经终止
		
		}
		//输出结果
		thread.print();
	}
	
	private static class StopThread extends Thread{
	
		private int i=0;
	
		private int j=0;
	
		@Override
		public void run(){
			synchronized (this) {//增加同步锁，确保线程安全
				++i;
				try {
					//休眠10秒,模拟耗时操作
					Thread.sleep(10000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				++j;
			}
		}
		/**
		 * 打印i和j
		 */
		public void print(){
			System.out.println("i="+i+" j="+j);
		}
	}
}
```

StopThread 类正常运行的时候，最终调用 print() 方法输出的值应该为 i=1 j=1，但是由于调用了 stop() 方法强制终止了线程的运行，导致 i 已经自增了，但是 j 并未自增，破坏了这个类的线程安全。

## 线程暂停与恢复

线程的暂停意味着该线程还可以恢复运行，在 java 多线程中，可以使用 suspend() 方法暂停线程，使用 resume() 方法恢复线程的执行。

### suspend 和 resume 

- suspend() 方法的作用是将一个线程挂起（暂停）；
- resume() 方法的作用则是将一个挂起的线程重新开始并继续向下运行。

```java
package com.company.ThreadSuspend;

import java.text.SimpleDateFormat;

public class SuspendThread {

    public static void main(String[] args) {
        SimpleDateFormat f = new SimpleDateFormat("HH:mm:ss");
        
        try {
            MyThread2 t = new MyThread2();
            t.start();
            Thread.sleep(1000);
            
            //暂停线程
            t.suspend();
            System.out.println("暂停线程：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            Thread.sleep(5000);
            System.out.println("暂停线程5秒后：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            
            //继续线程
            t.resume();
            System.out.println("--恢复线程--");
            Thread.sleep(5000);
            System.out.println("--恢复线程5秒后--");
            
            //再次暂停线程
            t.suspend();
            System.out.println("再次暂停：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            Thread.sleep(5000);
            System.out.println("再次暂停5秒后：" + 
                            f.format(System.currentTimeMillis()) + 
                            ", num = " + t.getNum());
            
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
}

class MyThread2 extends Thread{
    private long num = 0;
    
    public void setNum(long num) {
        this.num = num;
    }
    
    public long getNum(){
        return num;
    }

    @Override
    public void run() {
        while(true){
            num++;
        }
    }
    
}

```

从例子中可以看出，线程确实被暂停了，而且还能恢复继续运行。

#### 缺点

因为 suspend 方法不会释放锁，而如果调用了 suspend 方法的目标线程在挂起时对某一重要的系统资源持有锁，那么在目标线程重新开始之前其他任何线程都无法访问该资源。

使用 suspend 和 resume 方法也容易出现因为线程的暂停而导致数据不同步的问题。

```java
package com.company.ThreadSuspend;

public class TestObject {

    public static void main(String[] args) throws InterruptedException {
        final UserObject obj = new UserObject();
        Thread thread1 = new Thread() {
            public void run() {
                obj.setValue("lisi", "30");
            };
        };
        
        thread1.setName("thread1");
        thread1.start();
        thread1.sleep(500);
        
        Thread thread2 = new Thread(){
            public void run() {
                obj.printValue();
            };
        };
        
        thread2.start();
        
    }
    
    static class UserObject {
        private String name = "zhangsan";
        private String age = "18";
        
        public void setValue(String name, String age) {
            this.name = name;
            if(Thread.currentThread().getName().equals("thread1")){
                System.out.println("暂停 thread1");
                Thread.currentThread().suspend();
            }
            this.age = age;
        }
        
        private void printValue(){
            System.out.println(name + " : " + age);
        }
    }

}

暂停 thread1
lisi : 18
```

### yield

 yiled() 方法的作用是：让当前处于运行状态的线程退回到可运行状态，让出抢占资源的机会。但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片。**Thread.yield() 只会释放当前cpu资源，如果该线程中持有锁的话，不会释放该持有的锁资源。**

sleep与yield方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程.而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。

### 线程优先级

Java 线程优先级使用 1 ~ 10 的整数表示：

- 最低优先级 1：Thread.MIN_PRIORITY
- 最高优先级 10：Thread.MAX_PRIORITY
- 普通优先级 5：Thread.NORM_PRIORITY

Java 默认的线程优先级是父线程的优先级，而非普通优先级 Thread.NORM_PRIORITY，因为主线程默认优先级是普通优先级 Thread.NORM_PRIORITY，所以如果不主动设置线程优先级，则新创建的线程的优先级就是普通优先级 Thread.NORM_PRIORITY。

高优先级的线程比低优先级的线程有更高的几率得到执行，实际上这和操作系统及虚拟机版本相关，有可能即使设置了线程的优先级也不会产生任何作用。

setPriority 方法只能更改本线程组及其子线程组（递归）的最大优先级，但不能影响已经创建的直接或间接属于该线程组的线程的优先级，也就是说，即使目前有一个子线程的优先级比新设定的线程组优先级大，也不会更改该子线程的优先级。只有当试图改变子线程的优先级或者创建新的子线程的时候，线程组的最大优先级才起作用。

# 线程池

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务

示例

```java
public class ThreadTest {

    public static void main(String[] args) throws InterruptedException, IOException {
        //核心线程数
        int corePoolSize = 2;
        //最大线程数
        int maximumPoolSize = 4;
        //最小空闲时间10s
        long keepAliveTime = 10;
        //时间单位秒
        TimeUnit unit = TimeUnit.SECONDS;
        //等待队列
        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);
        //线程工厂
        ThreadFactory threadFactory = new NameTreadFactory();
        //拒绝处理策略
        RejectedExecutionHandler handler = new MyIgnorePolicy();
        //创建线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,
                workQueue, threadFactory, handler);
        //// 预启动所有核心线程
        //executor.prestartAllCoreThreads();
        
        for (int i = 1; i <= 10; i++) {

            MyTask task = new MyTask(String.valueOf(i));
            //执行线程
            executor.execute(task);
            Thread.sleep(2000);
        }

        System.in.read();//阻塞主线程
    }

    /**
     * 自定义的 TreadFactory
     */
    static class NameTreadFactory implements ThreadFactory {
        //使用原子类计数
        private final AtomicInteger mThreadNum = new AtomicInteger(1);
        //创建线程的具体逻辑
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, "my-thread-" + mThreadNum.getAndIncrement());
            System.out.println(t.getName() + " has been created");
            return t;
        }
    }
    /**
     * 自定义的处理策略
     */
    public static class MyIgnorePolicy implements RejectedExecutionHandler {

        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            doLog(r, e);
        }

        private void doLog(Runnable r, ThreadPoolExecutor e) {
            // 可做日志记录等
            System.err.println( r.toString() + " rejected");
//          System.out.println("completedTaskCount: " + e.getCompletedTaskCount());
        }
    }

    static class MyTask implements Runnable {
        private final String name;

        public MyTask(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + " : " + this + " is running!");
                Thread.sleep(40000); //让任务执行慢点
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        public String getName() {
            return name;
        }

        @Override
        public String toString() {
            return "MyTask [name=" + name + "]";
        }
    }
}

//-----------结果-------------
my-thread-1 has been created
my-thread-1 : MyTask [name=1] is running!
my-thread-2 has been created
my-thread-2 : MyTask [name=2] is running!
my-thread-3 has been created
my-thread-3 : MyTask [name=5] is running!
my-thread-4 has been created
my-thread-4 : MyTask [name=6] is running!
MyTask [name=7] rejected
MyTask [name=8] rejected
MyTask [name=9] rejected
MyTask [name=10] rejected
my-thread-1 : MyTask [name=3] is running!
my-thread-2 : MyTask [name=4] is running!
```

## 线程池构造器参数

ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。

下面解释下一下构造器中各个参数的含义：

- corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
- maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
- keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
- unit：参数keepAliveTime的时间单位
- workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响
- threadFactory：线程工厂，主要用来创建线程；
- handler：表示当拒绝处理任务时的策略

## 线程池状态

在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：

```java
volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
```

runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；

下面的几个static final变量表示runState可能的几个取值。

- 当创建线程池后，初始时，线程池处于RUNNING状态；
- 如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；
- 如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；
- 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。

## 任务执行过程

- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会先尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

## 线程池中的线程初始化

默认情况下，创建线程池之后，线程池中是**没有线程**的，需要提交任务之后才会创建线程。

在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：

- prestartCoreThread()：初始化一个核心线程；
- prestartAllCoreThreads()：初始化所有核心线程

## 任务缓存队列及排队策略

在Java的线程池中，工作队列（也称为任务队列）用于存储那些等待执行的任务。当线程池中的线程执行完当前任务后，会从工作队列中取出下一个任务来执行。工作队列是线程池管理任务的核心组件之一。

### 工作队列与普通队列的主要区别

工作队列（Work Queue）与普通队列的主要区别在于它们的使用场景和目的。工作队列是线程池中用于存储待执行任务的队列，而普通队列则是在其他场景中用于存储数据的队列。以下是它们之间的一些关键区别：

1. **目的不同**：
   - **工作队列**：工作队列是线程池中用于存储待执行任务的队列，它与线程池的线程管理紧密相关。工作队列的主要目的是在任务提交时，如果线程池中的线程都在忙碌，那么任务会被放入工作队列中等待执行。工作队列是线程池实现任务调度和负载均衡的关键组件。
   - **普通队列**：普通队列是用于存储数据的队列，它可以用于任何需要先进先出（FIFO）数据结构的场景。普通队列可以用于缓存数据、实现生产者-消费者模式等。

2. **线程池集成**：
   - **工作队列**：工作队列是线程池的一部分，它与线程池的生命周期紧密相关。当线程池被关闭时，工作队列中的任务通常也会被丢弃。
   - **普通队列**：普通队列可以独立于线程池存在，它不依赖于任何特定的线程池实现。普通队列可以被多个线程共享，用于不同的目的。

3. **阻塞行为**：
   - **工作队列**：**工作队列通常具有阻塞行为**。例如，当工作队列满时，提交任务的线程可能会被阻塞，直到队列中有空间。同样，当工作队列为空时，获取任务的线程可能会被阻塞，直到有任务被提交。
   - **普通队列**：普通队列的行为取决于其实现。一些队列（如`BlockingQueue`接口的实现）具有阻塞行为，而其他队列（如`LinkedList`或`ArrayList`）则没有阻塞行为。

4. **线程安全**：
   - **工作队列**：工作队列通常需要是线程安全的，因为它们会被多个线程同时访问。Java的线程池通常使用`BlockingQueue`接口的实现作为工作队列，这些实现是线程安全的。
   - **普通队列**：普通队列可能不是线程安全的，除非它们被设计为线程安全。在多线程环境中，如果需要线程安全的队列，可以使用`Collections.synchronizedList`包装普通队列，或者使用`ConcurrentLinkedQueue`等线程安全的队列实现。

5. **任务处理**：
   - **工作队列**：工作队列中的任务通常由线程池中的线程执行。线程池会从工作队列中取出任务并执行它们。
   - **普通队列**：普通队列中的数据通常由生产者和消费者处理。生产者将数据放入队列，消费者从队列中取出数据。

总结来说，工作队列是线程池中用于管理任务调度的特殊队列，它与线程池的线程管理紧密集成，具有阻塞行为和线程安全特性。而普通队列则是一个通用的数据结构，用于存储数据，可以用于多种场景，不一定与线程池相关联。在设计并发程序时，选择合适的队列类型对于保证程序的正确性和性能至关重要。

### 工作队列的分类

Java线程池中的工作队列主要有以下几种类型：

1. **无界队列**：如`LinkedBlockingQueue`，这种队列没有容量限制，理论上可以无限存储任务。如果线程池的线程数有限，可能会导致任务堆积，最终耗尽内存。基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE

2. **有界队列**：如`ArrayBlockingQueue`，这种队列有固定的容量限制。当队列满时，**提交任务的线程会阻塞**，直到队列中有空位。基于数组的先进先出队列，此创建时必须指定大小。

3. **同步队列**：如`SynchronousQueue`，这种队列不存储任务，它不会保存提交的任务，提交的任务必须**立即执行**，否则提交任务的线程会阻塞，直到有线程来取走任务。

4. **优先队列**：如`PriorityBlockingQueue`，这种队列按照任务的优先级来存储任务，优先级高的任务会优先执行。

在`ThreadPoolExecutor`中，你可以通过构造函数或`setQueue()`方法来指定工作队列的类型。例如：

```java
// 使用无界队列
ExecutorService executorService = new ThreadPoolExecutor(
    1, // 核心线程数
    1, // 最大线程数
    0L, // 线程空闲存活时间
    TimeUnit.MILLISECONDS, // 时间单位
    new LinkedBlockingQueue<Runnable>() // 无界队列
);

// 使用有界队列
ExecutorService executorService = new ThreadPoolExecutor(
    1, // 核心线程数
    1, // 最大线程数
    0L, // 线程空闲存活时间
    TimeUnit.MILLISECONDS, // 时间单位
    new ArrayBlockingQueue<Runnable>(10) // 有界队列，容量为10
);
```

在实际应用中，选择合适的工作队列类型对于线程池的性能和稳定性至关重要。通常，需要根据任务的特性、系统资源和业务需求来决定使用哪种类型的队列。例如，如果任务处理时间短且任务量大，使用有界队列可以防止内存溢出；如果任务处理时间长且任务量不大，使用无界队列可以避免线程频繁阻塞。

在Java 8及以后的版本中，`Executors`类提供了几个工厂方法来创建预定义配置的线程池，这些线程池内部使用了不同的工作队列：

- `Executors.newFixedThreadPool(int nThreads)`：使用固定大小的线程池和无界队列。
- `Executors.newSingleThreadExecutor()`：使用单个后台线程和无界队列。
- `Executors.newCachedThreadPool()`：使用可伸缩的线程池和同步队列。

#### Java 中的阻塞队列

1. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。
2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。
3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。
4. DelayQueue：使用优先级队列实现的无界阻塞队列。
5. SynchronousQueue：不存储元素的阻塞队列。
6. LinkedTransferQueue：由链表结构组成的无界阻塞队列。
7. LinkedBlockingDeque：由链表结构组成的双向阻塞队列

#### ArrayBlockingQueue

用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。 默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。

#### LinkedBlockingQueue

基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）

#### DelayQueue

`DelayQueue`是Java并发包（`java.util.concurrent`）中的一种阻塞队列，它实现了`BlockingQueue`接口。`DelayQueue`专门用于存放实现了`Delayed`接口的对象，其中的元素只有在延迟期满时才能从队列中取走。这种队列是无界的，但只有在延迟期满时才能从中获取元素，因此对内存的使用是有限的。

**主要特点**：

1. **延迟元素**：`DelayQueue`中的元素必须实现`Delayed`接口，该接口要求实现两个方法：`getDelay(TimeUnit unit)`和`compareTo(Delayed other)`。`getDelay`方法返回元素的剩余延迟时间，而`compareTo`方法用于比较两个元素的延迟时间。

2. **阻塞获取**：当尝试从`DelayQueue`中获取元素时，如果队列中没有元素或者所有元素的延迟时间都未到期，则调用线程将被阻塞，直到有元素的延迟时间到期。

3. **无界队列**：`DelayQueue`没有固定大小的限制，它会根据需要动态地扩展。

4. **线程安全**：`DelayQueue`是线程安全的，内部使用了锁机制来保证线程安全。

**使用场景**：

`DelayQueue`适用于以下场景：

- **定时任务**：用于实现定时任务调度，如定时发送邮件、执行定时清理等。
- **缓存过期**：用于缓存项的过期管理，当缓存项过期时自动从缓存中移除。
- **事件调度**：用于管理事件的调度，如在特定时间后触发事件。

**示例代码**：

```java
import java.util.concurrent.*;

class DelayedTask implements Delayed {
    private final long delayTime;
    private final long expire;
    private final String name;

    public DelayedTask(String name, long delayTime) {
        this.name = name;
        this.delayTime = delayTime;
        this.expire = System.currentTimeMillis() + delayTime;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return unit.convert(expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }

    @Override
    public int compareTo(Delayed o) {
        if (this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS)) {
            return -1;
        }
        if (this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)) {
            return 1;
        }
        return 0;
    }

    @Override
    public String toString() {
        return name + " " + expire;
    }
}

public class DelayQueueExample {
    public static void main(String[] args) {
        DelayQueue<DelayedTask> queue = new DelayQueue<>();

        // 添加延迟任务到队列
        queue.put(new DelayedTask("Task 1", 1000));
        queue.put(new DelayedTask("Task 2", 2000));
        queue.put(new DelayedTask("Task 3", 3000));

        // 从队列中获取并执行任务
        while (!queue.isEmpty()) {
            try {
                DelayedTask task = queue.take();
                System.out.println(task);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

在这个例子中，我们定义了一个`DelayedTask`类，它实现了`Delayed`接口。然后创建了一个`DelayQueue`实例，并向其中添加了几个延迟任务。通过调用`take()`方法，我们从队列中获取并执行了到期的任务。

`DelayQueue`是Java并发工具箱中一个非常有用的组件，它允许开发者轻松地实现延迟执行和定时任务调度的功能。

我们可以将 DelayQueue 运用在以下应用场景： 

1. **缓存系统的设计**：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。
2. **定时任务调度** ：使用 DelayQueue 保存当天将会执行的任务和执行时间 ，一 旦 从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的

#### synchronousQueue

`SynchronousQueue` 是 Java 中 `java.util.concurrent` 包提供的一个特殊的阻塞队列，它不存储任何元素。它在内部实现上没有容量的概念，也就是说，它不维护任何存储空间来存储元素。`SynchronousQueue` 的主要作用是作为线程之间传递数据的通道，它保证了在生产者和消费者之间传递数据时的同步性。

特点

1. **容量为零**：`SynchronousQueue` 没有内部容量，不能存储任何元素。这意味着，当一个线程尝试向队列中插入一个元素时，它必须等待另一个线程来取走这个元素；反之亦然。

2. **同步性**：`SynchronousQueue` 保证了在生产者和消费者之间传递数据时的同步性。当一个线程尝试向队列中插入一个元素时，它会阻塞直到另一个线程来取走这个元素；同样，当一个线程尝试从队列中取出一个元素时，它也会阻塞直到有元素被插入。

3. **公平性**：`SynchronousQueue` 可以通过构造函数参数来选择是否需要公平性。公平性意味着线程按照它们请求访问队列的顺序来获得访问权。如果选择公平性，那么等待时间最长的线程将优先获得访问权。

4. **无界**：虽然 `SynchronousQueue` 没有容量限制，但它并不是无界队列。它不存储元素，所以不会因为队列满而拒绝插入操作。

使用场景

`SynchronousQueue` 适用于以下场景：

- **生产者-消费者模式**：当生产者和消费者数量大致相等时，可以使用 `SynchronousQueue` 来确保生产者和消费者之间的直接传递，提高效率。
- **线程池中的任务传递**：在使用 `Executors.newCachedThreadPool()` 创建的线程池中，`SynchronousQueue` 被用作任务队列。这种线程池会根据需要创建新线程，但不会保留空闲线程，而是使用 `SynchronousQueue` 来传递任务给线程。
- **交换数据**：在需要在两个线程之间交换数据的场景中，`SynchronousQueue` 可以作为中间媒介，确保数据的同步交换。

示例代码

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class SynchronousQueueExample {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个SynchronousQueue
        SynchronousQueue<Integer> queue = new SynchronousQueue<>();

        // 创建一个线程池
        ExecutorService executor = Executors.newCachedThreadPool();

        // 生产者线程
        executor.execute(() -> {
            try {
                // 生产者向队列中插入元素
                queue.put(1);
                System.out.println("Producer put 1");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 消费者线程
        executor.execute(() -> {
            try {
                // 消费者从队列中取出元素
                Integer value = queue.take();
                System.out.println("Consumer took " + value);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 关闭线程池
        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);
    }
}
```

在这个例子中，我们创建了一个 `SynchronousQueue` 实例，并启动了两个线程：一个生产者线程和一个消费者线程。生产者线程向队列中插入一个元素，而消费者线程从队列中取出这个元素。由于 `SynchronousQueue` 的特性，这两个操作是同步的，生产者线程会阻塞直到消费者线程取走元素，反之亦然。

`SynchronousQueue` 是一个非常特殊的队列，它在并发编程中扮演着重要的角色，特别是在需要确保线程间直接传递数据的场景中。非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和 ArrayBlockingQueue。 

#### PriorityBlockingQueue

`PriorityBlockingQueue`是Java中`java.util.concurrent`包提供的一个线程安全的优先级队列实现。它继承自`AbstractQueue`类，并实现了`BlockingQueue`接口。`PriorityBlockingQueue`允许你按照元素的自然顺序（即元素的自然排序）或通过提供的`Comparator`（比较器）来插入和检索元素。

`PriorityBlockingQueue`的特点包括：

1. **无界队列**：`PriorityBlockingQueue`没有固定大小的限制，它会根据需要动态地增长，以容纳更多的元素。

2. **线程安全**：由于实现了`BlockingQueue`接口，`PriorityBlockingQueue`是线程安全的。这意味着多个线程可以同时安全地向队列中添加元素，或者从队列中移除元素。

3. **优先级排序**：`PriorityBlockingQueue`会根据元素的自然顺序或通过`Comparator`来维护元素的顺序。这意味着当你从队列中取出元素时，总是会得到当前队列中优先级最高的元素。

4. **阻塞特性**：`PriorityBlockingQueue`实现了`BlockingQueue`接口，因此它具有阻塞特性。当尝试从空队列中获取元素时，调用线程会被阻塞，直到队列中有元素可用。同样，当尝试向满队列中添加元素时，调用线程也会被阻塞，直到队列中有空间。

5. **无锁实现**：`PriorityBlockingQueue`使用了一种基于堆的数据结构来实现优先级队列，它通过无锁算法来保证线程安全，而不是使用传统的锁机制。

6. **不支持null元素**：`PriorityBlockingQueue`不允许插入`null`元素。尝试插入`null`会抛出`NullPointerException`。

7. **迭代器不保证顺序**：虽然`PriorityBlockingQueue`内部维护了元素的顺序，但其迭代器并不保证按照优先级顺序遍历元素。如果需要按照优先级顺序遍历元素，应该使用`poll()`方法。

8. **性能**：`PriorityBlockingQueue`在插入和删除元素时通常具有较好的性能，尤其是当元素数量较少时。但是，当元素数量非常大时，性能可能会受到影响，因为堆的调整操作需要时间。

`PriorityBlockingQueue`的使用场景包括：

- 任务调度：在需要根据任务优先级来调度任务的场景中，可以使用`PriorityBlockingQueue`来存储任务，然后根据任务的优先级顺序来执行它们。
- 事件处理：在需要根据事件的紧急程度来处理事件的系统中，可以使用`PriorityBlockingQueue`来存储事件，然后按照事件的优先级来处理它们。

下面是一个简单的`PriorityBlockingQueue`使用示例：

```java
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class PriorityBlockingQueueExample {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new PriorityBlockingQueue<>();

        // 添加元素
        queue.add(10);
        queue.add(1);
        queue.add(5);

        // 获取并移除元素
        try {
            System.out.println(queue.take()); // 输出: 1
            System.out.println(queue.take()); // 输出: 5
            System.out.println(queue.take()); // 输出: 10
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

在这个例子中，我们创建了一个`PriorityBlockingQueue`，并向其中添加了三个整数。由于`PriorityBlockingQueue`是按照自然顺序排序的，所以当我们使用`take()`方法从队列中移除元素时，会按照升序（1, 5, 10）获取元素。

#### LinkedTransferQueue

`LinkedTransferQueue`是Java并发包（`java.util.concurrent`）中的一种无界阻塞队列，它结合了`LinkedBlockingQueue`的无界性和`SynchronousQueue`的直接传递（transfer）特性。`LinkedTransferQueue`提供了一种高效的方式来在生产者和消费者之间传递数据，它支持多种操作，包括插入、移除、检查元素等。

**主要特点**：

1. **无界队列**：`LinkedTransferQueue`是一个无界队列，这意味着它不会因为队列满而阻塞生产者线程，生产者可以无限地向队列中添加元素。

2. **直接传递**：`LinkedTransferQueue`支持直接传递操作，即生产者可以将元素直接传递给消费者，而不需要将元素放入队列中。这种操作在消费者准备好接收元素时非常高效。

3. **阻塞操作**：除了直接传递操作外，`LinkedTransferQueue`还支持阻塞操作，如`take()`和`poll(long timeout, TimeUnit unit)`，这些操作允许消费者在队列为空时等待元素的出现。

4. **线程安全**：`LinkedTransferQueue`是线程安全的，它内部使用了锁机制来保证线程安全。

**使用场景**：

`LinkedTransferQueue`适用于以下场景：

- **生产者-消费者模式**：在生产者和消费者之间传递数据，特别是当消费者可以立即处理生产者生成的数据时。
- **任务执行**：用于任务的传递和执行，特别是当任务需要立即执行时。
- **缓存管理**：用于缓存数据的传递，特别是当缓存数据需要立即被消费时。

**示例代码**：

```java
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TimeUnit;

public class LinkedTransferQueueExample {
    public static void main(String[] args) {
        LinkedTransferQueue<String> queue = new LinkedTransferQueue<>();

        // 生产者线程
        new Thread(() -> {
            try {
                queue.transfer("Hello, World!");
                System.out.println("生产者传递了一个元素");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // 消费者线程
        new Thread(() -> {
            try {
                String message = queue.take();
                System.out.println("消费者接收到了元素：" + message);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

在这个例子中，我们创建了一个`LinkedTransferQueue`实例，并启动了两个线程：一个生产者线程和一个消费者线程。生产者线程使用`transfer()`方法将一个字符串传递给消费者线程，消费者线程使用`take()`方法接收这个字符串。

`LinkedTransferQueue`提供了一种灵活的方式来在生产者和消费者之间传递数据，它结合了无界队列的灵活性和直接传递操作的高效性。这种队列特别适合于生产者和消费者之间需要快速传递数据的场景。

LinkedTransferQueue 多了 tryTransfer 和 transfer 方法

`LinkedTransferQueue`提供了`transfer`和`tryTransfer`方法，这些方法是`LinkedTransferQueue`特有的，它们提供了比其他阻塞队列更灵活的元素传递机制。

**transfer(E e)**

`transfer(E e)`方法尝试将元素`e`传递给消费者。如果队列中存在等待的消费者（即消费者调用了`take()`或`poll(long timeout, TimeUnit unit)`方法），那么`transfer`方法会立即把元素`e`传递给消费者，并且方法会返回。如果队列中没有消费者在等待，那么`transfer`方法会将元素`e`添加到队列的尾部，**并且当前线程会阻塞，直到有消费者消费了这个元素**。

**tryTransfer(E e)**

`tryTransfer(E e)`方法尝试将元素`e`传递给消费者。如果队列中存在等待的消费者，那么`tryTransfer`方法会立即把元素`e`传递给消费者，并返回`true`。如果队列中没有消费者在等待，那么`tryTransfer`方法会立即返回`false`，**不会阻塞当前线程**。

**tryTransfer(E e, long timeout, TimeUnit unit)**

`tryTransfer(E e, long timeout, TimeUnit unit)`方法尝试将元素`e`传递给消费者，但带有超时限制。如果队列中存在等待的消费者，那么`tryTransfer`方法会立即把元素`e`传递给消费者，并返回`true`。如果队列中没有消费者在等待，那么`tryTransfer`方法会等待指定的超时时间。如果在超时时间内有消费者消费了元素`e`，则返回`true`；如果超时时间到了元素`e`还没有被消费，则返回`false`。

**使用场景**

`LinkedTransferQueue`的这些方法特别适合于生产者和消费者之间需要快速同步的场景。例如，当生产者知道消费者正在等待接收数据时，可以使用`transfer`方法立即传递数据，从而避免了生产者线程的阻塞。而`tryTransfer`方法则适合于生产者需要检查消费者是否准备好接收数据的情况，如果消费者未准备好，生产者可以继续执行其他任务，而不是阻塞等待。

**示例代码**

```java
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TimeUnit;

public class LinkedTransferQueueExample {
    public static void main(String[] args) {
        LinkedTransferQueue<String> queue = new LinkedTransferQueue<>();

        // 生产者线程
        new Thread(() -> {
            try {
                // 尝试立即传递元素
                if (queue.tryTransfer("Hello")) {
                    System.out.println("生产者立即传递了元素");
                } else {
                    // 如果没有消费者等待，可以执行其他任务
                    System.out.println("没有消费者等待，生产者继续其他任务");
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // 消费者线程
        new Thread(() -> {
            try {
                // 消费者等待接收元素
                String message = queue.take();
                System.out.println("消费者接收到了元素：" + message);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

在这个例子中，生产者线程尝试使用`tryTransfer`方法传递一个字符串给消费者线程。如果消费者线程正在等待接收元素，那么生产者线程会立即传递元素并打印消息；如果消费者线程没有在等待，生产者线程会继续执行其他任务。这种机制使得生产者和消费者之间的交互更加高效和灵活。

#### LinkedBlockingDeque

`LinkedBlockingDeque`是Java并发包（`java.util.concurrent`）中的一种双端队列（deque），它实现了`BlockingDeque`接口。`LinkedBlockingDeque`是基于链表实现的，因此它支持在队列的两端进行高效的插入和移除操作。与`LinkedBlockingQueue`类似，`LinkedBlockingDeque`也是无界的，但提供了更多的操作方法，允许在队列的两端进行元素的添加、移除和检查。

**主要特点**：

1. **无界队列**：`LinkedBlockingDeque`是一个无界的双端队列，这意味着它不会因为队列满而阻塞生产者线程，生产者可以无限地向队列中添加元素。

2. **双端操作**：`LinkedBlockingDeque`支持在队列的两端进行操作，包括添加、移除和检查元素。这使得它非常适合于需要在两端进行操作的场景，如生产者-消费者模式、任务执行等。

3. **线程安全**：`LinkedBlockingDeque`是线程安全的，内部使用了锁机制来保证线程安全。

4. **阻塞操作**：`LinkedBlockingDeque`支持阻塞操作，如`takeFirst()`、`takeLast()`、`putFirst()`和`putLast()`等，这些操作允许消费者在队列为空时等待元素的出现，或者生产者在队列满时等待空间的出现。

**使用场景**：

`LinkedBlockingDeque`适用于以下场景：

- **生产者-消费者模式**：在生产者和消费者之间传递数据，特别是当生产者和消费者需要在队列的两端进行操作时。
- **任务执行**：用于任务的传递和执行，特别是当任务需要在队列的两端进行管理时。
- **缓存管理**：用于缓存数据的传递，特别是当缓存数据需要在队列的两端进行管理时。

**示例代码**：

```java
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.TimeUnit;

public class LinkedBlockingDequeExample {
    public static void main(String[] args) {
        LinkedBlockingDeque<String> deque = new LinkedBlockingDeque<>();

        // 生产者线程
        new Thread(() -> {
            try {
                deque.putFirst("Element 1");
                deque.putLast("Element 2");
                System.out.println("生产者添加了元素");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // 消费者线程
        new Thread(() -> {
            try {
                String first = deque.takeFirst();
                String last = deque.takeLast();
                System.out.println("消费者消费了元素：" + first + " 和 " + last);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

在这个例子中，我们创建了一个`LinkedBlockingDeque`实例，并启动了两个线程：一个生产者线程和一个消费者线程。生产者线程使用`putFirst()`和`putLast()`方法在队列的两端添加元素，消费者线程使用`takeFirst()`和`takeLast()`方法在队列的两端移除元素。

`LinkedBlockingDeque`提供了一种灵活的方式来在生产者和消费者之间传递数据，它支持在队列的两端进行操作，这使得它非常适合于需要在两端进行数据交换的场景。

**双向队列的特点**：

- **两端操作**：`LinkedBlockingDeque`提供了在队列两端插入和移除元素的方法，如`addFirst()`, `addLast()`, `offerFirst()`, `offerLast()`, `peekFirst()`, `peekLast()`, `pollFirst()`, `pollLast()`等。
- **减少竞争**：由于提供了两端操作，当多个线程同时向队列中添加元素时，可以分别在队列的两端进行操作，从而减少了线程间的竞争。
- **容量设置**：在初始化`LinkedBlockingDeque`时，可以指定队列的容量，以防止队列过度膨胀，这有助于控制内存使用。
- **工作窃取模式**：`LinkedBlockingDeque`可以用于实现“工作窃取”模式，这是一种任务分配策略，其中每个线程都有自己的任务队列。当一个线程完成自己的任务后，它可以尝试从其他线程的任务队列中“窃取”任务来执行，从而提高资源利用率。

**方法说明**：

- **addFirst(E e)** 和 **addLast(E e)**：将元素添加到队列的头部或尾部。如果队列已满，`addFirst`会抛出`IllegalStateException`异常，而`addLast`会阻塞直到队列有空间。
- **offerFirst(E e)** 和 **offerLast(E e)**：尝试将元素添加到队列的头部或尾部，如果队列已满，不会阻塞，而是返回`false`。
- **peekFirst()** 和 **peekLast()**：返回队列头部或尾部的元素，但不移除它。如果队列为空，返回`null`。
- **pollFirst()** 和 **pollLast()**：返回并移除队列头部或尾部的元素，如果队列为空，返回`null`。
- **takeFirst()** 和 **takeLast()**：返回并移除队列头部或尾部的元素，如果队列为空，当前线程会阻塞直到有元素可用。

**示例代码**：

```java
import java.util.concurrent.LinkedBlockingDeque;

public class LinkedBlockingDequeExample {
    public static void main(String[] args) {
        LinkedBlockingDeque<String> deque = new LinkedBlockingDeque<>(10); // 设置容量为10

        // 添加元素到队列尾部
        deque.addLast("Element 1");
        deque.offerLast("Element 2");

        // 从队列头部获取元素
        String firstElement = deque.peekFirst();
        System.out.println("First element: " + firstElement);

        // 从队列尾部获取并移除元素
        String lastElement = deque.pollLast();
        System.out.println("Last element: " + lastElement);

        // 尝试添加元素到队列头部，如果队列已满则返回false
        boolean added = deque.offerFirst("Element 3");
        System.out.println("Element 3 added: " + added);

        // 尝试从队列头部获取并移除元素，如果队列为空则阻塞
        String headElement = deque.takeFirst();
        System.out.println("Head element: " + headElement);
    }
}
```

在上述代码中，我们创建了一个容量为10的`LinkedBlockingDeque`，演示了如何在队列的两端添加和移除元素，以及如何使用阻塞和非阻塞的方法。

`LinkedBlockingDeque`是并发编程中非常有用的工具，它提供了灵活的队列操作方式，适用于需要在多线程环境中高效管理任务的场景。

## 任务拒绝策略

在Java中，线程池的`ThreadPoolExecutor`类提供了几种内置的任务拒绝策略，当线程池无法接受新任务时，会根据配置的拒绝策略来处理这些任务。这些策略定义了当工作队列已满且线程池中的线程数达到最大值时，如何处理新提交的任务。

以下是`ThreadPoolExecutor`类中定义的几种内置拒绝策略：

1. **AbortPolicy**（默认策略）：
   - 当任务被拒绝时，会抛出一个`RejectedExecutionException`异常。这是默认的拒绝策略，它会直接拒绝新任务的提交，并抛出异常。

2. **CallerRunsPolicy**：
   - 当任务被拒绝时，该策略不会抛出异常，而是将任务回退给调用者线程执行。这意味着调用者线程将直接执行该任务，而不是在工作线程中执行。这可以防止任务丢失，但可能会导致调用者线程执行任务的性能下降。

3. **DiscardPolicy**：
   - 当任务被拒绝时，该策略会静默地丢弃被拒绝的任务，不会抛出异常，也不会执行任何操作。这意味着被拒绝的任务将被忽略，不会被处理。

4. **DiscardOldestPolicy**：
   - 当任务被拒绝时，该策略会丢弃工作队列中最旧的任务（即最早进入队列的任务），然后尝试重新提交被拒绝的任务。如果工作队列是无界的，这个策略的行为与`DiscardPolicy`相同。

除了这些内置策略外，你也可以通过实现`RejectedExecutionHandler`接口来自定义拒绝策略。自定义拒绝策略允许你根据应用程序的具体需求来决定如何处理被拒绝的任务。

下面是一个自定义拒绝策略的简单示例：

```java
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;

public class CustomRejectHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 自定义拒绝策略的逻辑
        System.out.println("Task " + r.toString() + " is rejected");
        // 可以在这里记录日志、发送通知等
    }
}
```

在创建`ThreadPoolExecutor`实例时，你可以通过`setRejectedExecutionHandler`方法来设置自定义的拒绝策略：

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize, 
    maximumPoolSize, 
    keepAliveTime, 
    TimeUnit.SECONDS, 
    workQueue, 
    new CustomRejectHandler() // 设置自定义拒绝策略
);
```

选择合适的拒绝策略对于确保应用程序的稳定性和可靠性至关重要。在设计线程池时，应该根据应用程序的业务逻辑和性能要求来选择或实现合适的拒绝策略。

## 线程池的关闭

ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：

- shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
- shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

## 线程池容量的动态调整

ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()

- setCorePoolSize：设置核心池大小
- setMaximumPoolSize：设置线程池最大能创建的线程数目大小

当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。

## 内置线程池

在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：

```java
Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
```

下面是这三个静态方法的具体实现

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```
从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。

- newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；
- newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；
- newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。

### newScheduledThreadPool

`Executors.newScheduledThreadPool(int corePoolSize)` 是 Java 中 `java.util.concurrent.Executors` 类提供的一个工厂方法，用于创建一个可调度的线程池。这个线程池允许你安排任务在指定的延迟后执行，或者定期执行。

参数

- `corePoolSize`：线程池中核心线程的数量。这些线程将一直存在，即使它们处于空闲状态。

特点

1. **延迟执行**：你可以安排任务在指定的延迟后执行。这意味着任务将在延迟时间结束后立即执行。

2. **周期性执行**：你可以安排任务周期性地执行。这可以是固定延迟（任务执行之间的时间间隔是固定的）或固定速率（任务执行的频率是固定的）。

3. **线程池管理**：`ScheduledThreadPoolExecutor`（`newScheduledThreadPool` 返回的类型）管理着一个线程池，这些线程负责执行调度的任务。如果需要，它可以创建新的线程来执行任务。

4. **任务调度**：`ScheduledThreadPoolExecutor` 使用一个延迟队列（`DelayedWorkQueue`）来管理任务。这个队列按照任务的执行时间排序，确保最早需要执行的任务排在队列的最前面。

使用场景

`ScheduledThreadPoolExecutor` 适用于以下场景：

- **定时任务**：需要在特定时间执行的任务，例如定时发送邮件、清理缓存等。
- **周期性任务**：需要周期性执行的任务，例如定期更新数据、执行健康检查等。
- **后台任务**：需要在后台执行的任务，但需要控制执行的时间。

示例代码

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPoolExample {
    public static void main(String[] args) {
        // 创建一个ScheduledThreadPoolExecutor，核心线程数为2
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

        // 安排一个任务在10秒后执行
        scheduler.schedule(() -> {
            System.out.println("Task executed after 10 seconds");
        }, 10, TimeUnit.SECONDS);

        // 安排一个任务每5秒执行一次，从现在开始
        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("Task executed every 5 seconds");
        }, 0, 5, TimeUnit.SECONDS);

        // 安排一个任务在10秒后开始执行，然后每隔5秒执行一次
        scheduler.scheduleWithFixedDelay(() -> {
            System.out.println("Task executed with 5 seconds delay");
        }, 10, 5, TimeUnit.SECONDS);

        // 关闭线程池
        scheduler.shutdown();
    }
}
```

在这个例子中，我们创建了一个 `ScheduledThreadPoolExecutor` 实例，并安排了三个任务：

1. 第一个任务在10秒后执行一次。
2. 第二个任务从现在开始，每5秒执行一次。
3. 第三个任务在10秒后开始执行，然后每隔5秒执行一次，但每次执行之间有5秒的延迟。

`ScheduledThreadPoolExecutor` 提供了灵活的任务调度机制，使得定时和周期性任务的执行变得简单。在使用时，需要注意关闭线程池以释放资源，如示例中的 `shutdown()` 方法所示。

## 如何合理配置线程池大小

一般需要根据任务的类型来配置线程池大小：

如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 CPU核心数+1


如果是IO密集型任务，参考值可以设置为2*CPU核心数


# 对象和变量的并发访问

线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。

## synchronized

非线程安全带来的问题就是多个线程在对同一个对象中的实例变量进行并发访问时。产生脏读，也就是取到的数据其实是被更改过的。

**方法内的变量是线程安全的，而实例变量非线程安全**。synchronized 它可以把任意一个**非 NULL** 的对象当作锁。synchronized 关键字取得的锁都是对象锁，属于独占式的悲观锁，而不是把一段代码或方法当做锁，想要达到同步效果的前提是多个线程访问的是同一个对象，如果多个线程访问多个对象，就会产生多个锁。

**synchronized 关键字具有锁重入功能**。也就是在使用时，当一个线程得到一个对象锁后，再次请求此对象的锁时是可以再次得到该对象的锁的，也就是说，在一个 synchronized 方法/块内部调用**本类**其他 synchronized 方法/块时永远可以得到锁，如果不可重入就会造成死锁。可重入锁也支持在父子类继承的环境中，在子类的同步方法中完全可以调用父类的同步方法。

当线程执行出现异常时，其所持有的锁会自动释放。

同步方法不具有继承性，也就是说**子类覆盖的方法无法从父类方法继承 synchronized 关键字的作用**。

使用 synchronized 同步块可以减少同步代码的数量来提升运行效率，在使用同步块时需要注意的是，当一个线程访问 object 的同步代码块时，其他线程对同一个 object 中其他同步块的访问将会被阻塞。synchronized(this)也是锁定的当前对象，这说明 synchronized 使用的对象监视器是一个。另外，synchronized 加在 static 方法上时是为当前的 *.java 文件所对应的 Class 类进行持锁，而加到非 static 方法上是为当前对象上锁。synchronized(class) 代码块的作用与 synchronized 加在 static 方法上的作用一样。

### 锁的类型

在Java中，锁可以分为两种类型：

1. **对象锁**：用于同步实例方法和同步代码块。每个对象都有一个与之关联的锁，当一个线程进入 `synchronized` 代码块时，它会获取该对象的锁。如果另一个线程尝试进入同一个对象的 `synchronized` 代码块，它将被阻塞，直到第一个线程释放锁。

2. **类锁**：用于同步静态方法和静态同步代码块。类锁是与类的Class对象关联的，而不是与类的实例关联。当一个线程进入静态 `synchronized` 代码块时，它会获取该类的类锁。如果另一个线程尝试进入同一个类的静态 `synchronized` 代码块，它将被阻塞，直到第一个线程释放锁。

### 锁的队列

当多个线程尝试获取同一个对象的锁时，它们会被放入一个等待队列中。这个队列是按照线程请求锁的顺序排列的，遵循先进先出（FIFO）的原则。当锁被释放时，等待队列中的第一个线程将被唤醒，并尝试获取锁。

### 锁的公平性

Java的锁默认是非公平的，这意味着线程获取锁的顺序并不一定与它们请求锁的顺序相同。然而，从Java 1.6开始，可以通过设置锁的属性来实现公平锁。公平锁确保线程按照它们请求锁的顺序来获取锁，从而避免饥饿现象。

### 示例

```java
public class SynchronizedExample {
    public synchronized void synchronizedMethod() {
        // 同步方法
    }

    public void someMethod() {
        synchronized (this) {
            // 同步代码块
        }
    }
}
```

在上面的示例中，`synchronizedMethod` 是一个同步方法，它使用对象锁。当一个线程调用这个方法时，它会获取 `SynchronizedExample` 对象的锁。如果另一个线程尝试调用这个方法，它将被阻塞，直到第一个线程完成方法执行并释放锁。

`someMethod` 方法中的代码块使用 `synchronized` 关键字和 `this` 关键字作为锁对象。这意味着它与 `synchronizedMethod` 使用相同的锁。如果一个线程在 `someMethod` 中的同步代码块中，另一个线程尝试调用 `synchronizedMethod` 或 `someMethod`，它将被阻塞。

### 锁对象的改变

只要对象不变，即使对象的属性被改变，运行的结果还是同步的。

### Synchronized 核心组件

`synchronized` 的核心组件包括监视器（Monitor）和锁（Lock）。

### 监视器（Monitor）

监视器是 Java 中实现同步的基础概念，它是一种同步机制，用于控制对对象的并发访问。每个对象都有一个与之关联的监视器，监视器负责管理线程对对象的访问。

监视器包含以下三个主要部分：

1. **锁**：监视器锁是监视器的核心，用于控制对对象的访问。当一个线程进入 `synchronized` 代码块或方法时，它会尝试获取对象的监视器锁。如果锁已被其他线程持有，该线程将被阻塞，直到锁被释放。

2. **等待集**：等待集是监视器中的一个队列，用于存储等待获取锁的线程。当线程调用 `Object.wait()` 方法时，它会释放锁并进入等待集。线程可以被其他线程通过 `Object.notify()` 或 `Object.notifyAll()` 方法唤醒。

3. **条件变量**：条件变量是监视器中的一个机制，允许线程在满足特定条件之前等待。每个条件变量关联一个等待集，线程可以调用 `Object.wait()` 方法进入等待集，直到其他线程调用 `Object.notify()` 或 `Object.notifyAll()` 方法唤醒它们。

### 锁（Lock）

在 Java 中，锁是监视器的实现细节。当线程尝试进入 `synchronized` 代码块或方法时，它会尝试获取对象的锁。锁可以是以下两种类型之一：

#### 偏向锁

**偏向锁（Biased Locking）**：偏向锁是 Java 6 引入的一种优化，它为锁的持有者提供了一种优化。如果一个线程在一段时间内频繁地访问同一个对象，那么这个线程可以偏向于这个对象，从而减少锁的获取和释放开销。

**实现原理**

1. **偏向状态**：当一个线程首次访问同步代码块时，JVM会将对象头中的锁标记设置为偏向模式，并记录下该线程的ID。此时，对象处于偏向状态，表示该对象偏向于第一个访问它的线程。

2. **锁偏向**：当同一个线程再次访问同一个对象的同步代码块时，JVM会检查对象头中的锁标记是否为偏向状态，并且线程ID是否与当前线程ID匹配。如果匹配，该线程将无需进行任何同步操作，直接进入同步代码块执行，从而减少了锁的获取和释放的开销。

3. **撤销偏向**：如果在偏向状态下，有其他线程尝试访问该对象的同步代码块，JVM会撤销偏向状态，并将锁升级为轻量级锁或重量级锁。撤销偏向通常发生在以下几种情况：
   - 另一个线程尝试获取该对象的锁。
   - 调用对象的 `hashCode()` 方法。
   - 调用 `wait()` 或 `notify()` 方法。
   - 调用 `System.identityHashCode()` 方法。

4. **锁升级**：偏向锁的撤销可能会导致锁升级。如果撤销偏向后，锁升级为轻量级锁，JVM会尝试使用自旋锁（Spin Lock）来减少线程上下文切换的开销。如果自旋失败，锁会进一步升级为重量级锁，此时会使用操作系统的互斥量（Mutex）来实现同步。

**偏向锁的启用与禁用**

- **启用**：在Java 6及以后的版本中，默认情况下偏向锁是启用的。可以通过JVM参数 `-XX:+UseBiasedLocking` 来显式启用或禁用偏向锁。
- **禁用**：在某些情况下，如果锁竞争非常激烈，偏向锁可能会带来额外的开销。此时，可以通过JVM参数 `-XX:-UseBiasedLocking` 来禁用偏向锁。

偏向锁通过记录线程ID来减少锁的获取和释放开销，适用于锁竞争不激烈的情况。在实际应用中，如果锁竞争频繁，JVM会自动撤销偏向锁，以避免性能损失。开发者可以根据应用的实际情况来调整JVM参数，以优化锁的性能。在Java 9及以后的版本中，偏向锁的实现细节有所变化，但基本原理保持不变。

#### 轻量级锁

**轻量级锁（Lightweight Locking）**：轻量级锁是偏向锁的进一步优化。当线程尝试获取锁时，如果锁未被其他线程持有，那么线程可以快速地获取锁，而不需要进行复杂的同步操作。

轻量级锁主要针对的是那些在多线程环境下，锁竞争不激烈，但又不满足偏向锁条件的情况。轻量级锁的实现原理主要基于自旋锁（Spin Lock）的概念。

**实现原理**

1. **锁记录**：当线程尝试获取轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录（Lock Record），用于存储锁对象的Mark Word的拷贝。

2. **CAS操作**：线程使用CAS（Compare-And-Swap）操作尝试将对象头中的Mark Word更新为指向当前线程栈帧中锁记录的指针。如果成功，表示线程成功获取了轻量级锁，可以进入同步代码块执行。

3. **自旋等待**：如果CAS操作失败，说明有其他线程已经持有该锁，当前线程将进入自旋状态（Spin），不断尝试获取锁。自旋是一种忙等待，线程在原地循环等待，直到锁被释放。

4. **锁升级**：如果自旋等待的时间过长（超过一定的自旋次数），JVM会将轻量级锁升级为重量级锁。重量级锁使用操作系统的互斥量（Mutex）来实现，这会导致线程从用户态切换到内核态，增加了上下文切换的开销。

5. **锁释放**：当线程执行完同步代码块后，会使用CAS操作将对象头的Mark Word恢复为原来的值，并将锁释放。如果在自旋过程中有其他线程尝试获取锁，那么这些线程将有机会在锁释放后获取到轻量级锁。

适用场景

轻量级锁适用于那些锁竞争不激烈，且线程持有锁的时间较短的场景。在这种情况下，自旋等待可以避免线程上下文切换的开销，从而提高性能。

注意事项

- **自旋开销**：自旋等待虽然避免了线程上下文切换的开销，但如果自旋等待的时间过长，反而会增加CPU的使用率，影响其他线程的执行。
- **锁升级**：如果锁竞争激烈，轻量级锁会升级为重量级锁，这会增加线程上下文切换的开销。因此，轻量级锁适用于锁竞争不激烈的场景。
- **锁粒度**：轻量级锁适用于锁粒度较小的场景，如果同步代码块较大，线程持有锁的时间较长，那么自旋等待可能会导致CPU资源的浪费。

轻量级锁是JVM为了提高多线程环境下锁的性能而引入的一种优化机制。通过减少线程上下文切换的开销，轻量级锁在适当的场景下可以显著提高程序的性能。然而，开发者需要根据实际的并发情况和锁的使用模式来选择合适的锁策略。在Java中，锁的优化是自动进行的，开发者通常不需要直接管理这些细节。

#### 重量级锁

**重量级锁（Heavyweight Locking）**：当线程竞争激烈时，锁会升级为重量级锁。重量级锁使用操作系统的互斥量（mutex）来实现，这会导致线程在用户态和内核态之间切换，增加开销。

**实现原理**

**互斥量（Mutex）**

重量级锁使用操作系统提供的互斥量来实现线程间的同步。互斥量是一种同步机制，它允许线程在访问共享资源时进行互斥访问。当一个线程获取了互斥量后，其他试图获取该互斥量的线程将被阻塞，直到互斥量被释放。

**线程阻塞与唤醒**

当线程尝试获取一个已经被其他线程持有的重量级锁时，该线程会被阻塞。在阻塞状态下，线程不会占用CPU资源，而是进入等待状态。当持有锁的线程释放锁时，操作系统会唤醒一个或多个等待该锁的线程，这些线程将重新进入竞争状态，尝试获取锁。

**线程上下文切换**

重量级锁的使用涉及到线程的上下文切换。当线程被阻塞时，操作系统需要保存当前线程的执行上下文（包括CPU寄存器的状态、程序计数器等），并将控制权交给其他线程。当线程被唤醒时，操作系统需要恢复被唤醒线程的上下文，并将控制权交还给它。这个过程称为上下文切换，它会带来一定的性能开销。

**锁的获取与释放**

重量级锁的获取和释放过程涉及系统调用，这通常比轻量级锁的自旋等待和CAS操作要慢。在重量级锁的实现中，JVM会调用操作系统的API来获取和释放锁，这通常涉及到用户态和内核态之间的切换，增加了开销。

**锁的升降级**

在Java中，锁的升级是一个渐进的过程。当一个锁从轻量级锁升级为重量级锁时，JVM会将锁对象的Mark Word中的锁标志位从轻量级锁的标识改为重量级锁的标识，并将锁对象的指针指向一个重量级锁的结构体。这个结构体包含了等待队列、持有锁的线程等信息。

在Java中，锁的升级是自动进行的，目的是为了提高并发性能。而锁的降级则不是直接支持的，因为一旦线程获取了重量级锁，它必须显式地释放该锁。在重量级锁被释放后，其他线程才有机会获取该锁。没有机制允许一个线程在持有重量级锁的情况下，将其降级为轻量级锁或无锁状态。

### 自旋锁

上文多次提到自旋锁，自旋锁（Spin Lock）是一种简单的同步机制，它允许线程在等待获取锁时进行忙等待（busy-waiting），而不是阻塞（blocking）。自旋锁的实现原理基于原子操作，通常使用CAS（Compare-And-Swap）指令来实现。CAS操作通常是由CPU指令直接支持的，在现代处理器中，如x86架构的处理器，提供了专门的指令来实现CAS操作，例如CMPXCHG（Compare and Exchange）指令。

在Java中，自旋锁并不是JVM提供的标准锁机制，但开发者可以使用CAS操作来实现自旋锁。例如，使用AtomicInteger类的getAndIncrement方法，该方法内部使用了CAS操作来实现原子性的自增操作，可以用来构建自旋锁。

**实现原理**

1. **原子操作**：自旋锁的核心是原子操作，即在多线程环境下，一个操作一旦开始，就不会被其他线程打断。在Java中，`AtomicInteger`类的`getAndIncrement()`方法就是一个原子操作的例子，它使用了CAS指令。

2. **CAS操作**：CAS操作是一种无锁的同步机制，它包含三个参数：内存位置（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相等，则将内存位置的值更新为新值，并返回true；否则，不进行任何操作，并返回false。CAS操作是自旋锁实现的关键，因为它允许线程在不阻塞的情况下尝试获取锁。

3. **自旋等待**：当一个线程尝试获取自旋锁时，它会不断执行CAS操作，检查锁是否可用。如果锁被占用，线程会继续尝试，直到锁被释放。这个过程称为自旋等待。

4. **锁释放**：当持有锁的线程完成其工作并释放锁时，它会将锁的状态设置为可用。其他等待的线程在自旋过程中会检测到锁状态的变化，并尝试获取锁。

**优点**

- **减少上下文切换**：自旋锁避免了线程阻塞和唤醒的开销，因为线程在等待时不会放弃CPU，而是继续执行，直到锁可用。

- **适用于短时间持有锁**：如果锁的持有时间很短，自旋锁可以提供比传统阻塞锁更好的性能，因为上下文切换的开销可能大于自旋等待的开销。

**缺点**

- **CPU资源消耗**：如果锁的持有时间较长，自旋锁会导致CPU资源的浪费，因为线程会持续占用CPU进行无用的自旋。

- **不公平性**：自旋锁可能导致不公平的锁获取，因为先到达的线程可能在自旋等待，而后来的线程可能在锁释放时立即获取到锁。

- **死锁风险**：如果多个线程在自旋等待时，它们都尝试获取多个锁，可能会导致死锁。

**使用场景**

自旋锁适用于以下场景：

- **锁的持有时间非常短**：如果锁的持有时间非常短，自旋锁可以提供较好的性能。

- **单核处理器**：在单核处理器上，自旋锁可以避免线程上下文切换的开销。

- **实时系统**：在实时系统中，自旋锁可以提供确定性的响应时间。

在Java中，`java.util.concurrent`包中的`ReentrantLock`类提供了可选择的自旋锁机制。通过设置`tryLock()`方法的超时参数，可以实现自旋等待一段时间，如果在这段时间内无法获取锁，则放弃自旋，转而阻塞等待。

#### 适应性自旋锁

在JDK 1.5版本中，自旋锁的自旋次数是固定的，这可能导致在某些情况下自旋时间过长，影响系统性能。为了优化这一问题，JDK 1.6引入了适应性自旋锁（Adaptive Spinning），它根据锁的争用情况动态调整自旋次数。，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM 还针对当前 CPU 的负荷情况做了较多的优化，

适应性自旋锁的工作原理如下：

1. **自旋次数的动态调整**：自旋锁会根据前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定下一次自旋的次数。如果锁很快被释放，那么自旋次数可以增加；如果锁长时间未被释放，自旋次数会减少。

2. **CPU负载感知**：JVM会监控当前CPU的负载情况。如果平均负载小于CPU核心数，说明CPU资源较为充足，可以继续自旋；如果超过CPU核心数的一半，说明CPU资源紧张，自旋的线程会直接阻塞。

3. **锁状态变化**：如果自旋的线程发现锁的拥有者发生了变化，它会减少自旋次数或直接进入阻塞状态，以避免无效的自旋。

4. **CPU节电模式**：如果CPU处于节电模式，自旋锁会停止自旋，以节省能源。

5. **存储延迟考虑**：自旋时间的最坏情况是CPU的存储延迟，即CPU写入数据后，其他CPU得知这个数据的时间差。自旋锁会考虑这个延迟来决定自旋的次数。

6. **线程优先级**：自旋锁在自旋时会适当放弃线程优先级之间的差异，以避免高优先级线程长时间占用CPU资源。

适应性自旋锁通过这些机制，使得自旋锁在不同情况下能够更加智能地调整自旋行为，从而在保证性能的同时减少资源浪费。这种自适应的策略使得自旋锁更加灵活和高效，尤其适用于多核处理器和高并发场景。

在JDK 1.6及之前版本中，自旋锁的开启和自旋次数的设置是通过JVM参数来控制的。具体来说，`-XX:+UseSpinning`参数用于开启自旋锁，而`-XX:PreBlockSpin`参数用于设置自旋次数。例如，`-XX:PreBlockSpin=10`表示自旋次数为10次。

然而，从JDK 1.7开始，JVM对自旋锁的实现进行了改进，引入了适应性自旋锁（Adaptive Spinning），并且不再需要通过`-XX:PreBlockSpin`参数来设置自旋次数。适应性自旋锁会根据锁的争用情况动态调整自旋次数，以提高自旋锁的效率和适应性。

在JDK 1.7及以后的版本中，自旋锁的开启和自旋次数的调整由JVM内部自动进行，开发者不需要手动设置这些参数。JVM会根据运行时的性能数据来决定是否使用自旋锁以及自旋的次数，以达到最佳的性能表现。

因此，对于JDK 1.7及以后的版本，开发者不需要关心自旋锁的开启和自旋次数的设置，只需关注如何合理使用锁来避免竞争和死锁，以及如何优化线程间的同步机制。JVM会根据实际情况自动调整自旋锁的策略，以提高并发程序的性能。

#### 在多核处理器上的表现

在多核处理器上，自旋锁的表现取决于多个因素，包括锁的使用频率、锁的持有时间、处理器核心的数量以及线程的调度策略。自旋锁在多核处理器上的表现通常比单核处理器上更为复杂，但也有其优势和潜在的性能提升。

**优势**

1. **减少上下文切换**：在多核处理器上，自旋锁可以减少线程上下文切换的开销。因为线程在等待锁时不会放弃CPU，而是继续执行，直到锁可用。这样，当锁最终被释放时，等待的线程可以立即开始执行，而不需要经历从就绪状态到运行状态的上下文切换。

2. **并发性**：多核处理器可以同时执行多个线程，因此，即使一个线程在自旋等待锁，其他线程仍然可以在其他核心上执行。这可以提高整体的并发性能。

**潜在问题**

1. **CPU资源消耗**：如果锁的持有时间较长，自旋锁会导致CPU资源的浪费，因为线程会持续占用CPU进行无用的自旋等待。在多核处理器上，这可能导致CPU资源的不公平分配，因为自旋的线程可能会占用过多的CPU时间。

2. **缓存一致性开销**：在多核处理器上，每个核心都有自己的缓存。当一个线程修改了共享数据时，需要通过缓存一致性协议（如MESI协议）来确保其他核心上的缓存行失效，以保持数据的一致性。自旋锁可能导致频繁的缓存行失效，增加缓存一致性开销。

3. **线程调度**：在多核处理器上，线程调度策略对自旋锁的性能有很大影响。如果操作系统调度策略不合理，可能会导致某些核心上的线程长时间自旋等待，而其他核心上的线程却无法充分利用。

**总结**

在多核处理器上，自旋锁可以提供较好的性能，特别是在锁的持有时间较短的情况下。然而，如果锁的持有时间较长，或者自旋等待的线程数量过多，自旋锁可能会导致CPU资源的浪费和缓存一致性开销的增加。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。

### 锁的内部状态和线程在获取锁时可能经历的几个阶段

这些概念与Java的内置锁机制（监视器锁）有关，它们是Java虚拟机（JVM）在内部实现的，用于管理线程对对象监视器（锁）的访问

1. **Wait Set**:
   - 当线程调用 `Object.wait()` 方法时，它会释放锁，并进入等待集（Wait Set）。等待集中的线程等待被其他线程通过 `Object.notify()` 或 `Object.notifyAll()` 方法唤醒。一旦被唤醒，线程将重新进入竞争队列（Contention List）以尝试重新获取锁。

2. **Contention List**:
   - 竞争队列是所有请求锁的线程的集合。当线程尝试获取一个锁时，如果锁已被其他线程持有，该线程将被放入竞争队列中等待。竞争队列中的线程将等待锁的释放。

3. **Entry List**:
   - Entry List 是竞争队列中的一个子集，包含那些已经准备好竞争锁的线程。当锁被释放时，Entry List 中的线程将被允许竞争锁。Entry List 有时也被称为“阻塞队列”或“等待队列”。JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争， JVM 会将一部分线程移动到 Entry List 中作为候选竞争线程。

4. **OnDeck**:
   - OnDeck 线程是竞争队列中下一个准备获取锁的线程。当锁被释放时，OnDeck 线程将被允许尝试获取锁。在某些实现中，OnDeck 线程可能被赋予一些优先级，以提高获取锁的效率。OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 Entry List 中。如果 Owner 线程被 wait 方法阻塞，则转移到 Wait Set 队列中，直到某个时刻通过 notify 或者 notifyAll 唤醒，会重新进去 EntryList 中。

5. **Owner**:
   - Owner 线程是当前持有锁的线程。Owner 线程可以执行 `synchronized` 代码块或方法。当 Owner 线程完成其工作并释放锁时，锁将变为可用状态。 Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 Entry List 中，并指定 Entry List 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“竞争切换”。

6. **!Owner**:
   - 当 Owner 线程释放锁时，它就不再是 Owner 线程了。此时，锁变为可用状态，其他线程可以尝试获取它。

处于 ContentionList、 EntryList、 WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。

Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。

每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的

synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。

Java1.6， synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。

锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；

JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过 `-XX:-UseBiasedLocking` 来禁用偏向锁。 

https://blog.csdn.net/zqz_zqz/article/details/70233767

## ReentrantLock

`ReentrantLock` 和 `synchronized` 都是 Java 中用于实现线程同步的机制，它们都可以用来控制对共享资源的访问。尽管它们的目的相似，但它们在实现细节和功能上存在一些区别：

1. **实现方式**：
   - `synchronized` 是 Java 语言的关键字，它依赖于 JVM 实现，是内置的同步机制。
   - `ReentrantLock` 是 `java.util.concurrent.locks` 包中的一个类，它是基于 API 的实现。

2. **灵活性**：
   - `synchronized` 提供的同步机制相对简单，只能在方法或代码块上使用，并且不能设置超时时间或中断响应。
   - `ReentrantLock` 提供了更多的灵活性，例如可以尝试获取锁（`tryLock()`），设置超时时间（`tryLock(long timeout, TimeUnit unit)`），以及响应中断（`lockInterruptibly()`）。

3. **公平性**：
   - `synchronized` 不能设置公平性，它不保证线程获取锁的顺序。
   - `ReentrantLock` 可以通过构造函数参数来创建公平锁或非公平锁。公平锁保证了线程按照请求锁的顺序来获取锁，而非公平锁则允许线程在锁可用时立即尝试获取锁。

4. **性能**：
   - 在大多数情况下，`synchronized` 和 `ReentrantLock` 的性能差异不大。但在某些极端情况下，`ReentrantLock` 可能提供更好的性能，尤其是在竞争非常激烈的情况下。
   - `ReentrantLock` 提供了更细粒度的控制，例如可以使用 `Condition` 对象来实现更复杂的等待/通知模式。

5. **使用场景**：
   - 如果同步需求简单，推荐使用 `synchronized`，因为它更简单、易于理解和使用。
   - 如果需要更高级的同步特性，如超时、中断响应、公平性控制等，或者需要实现复杂的同步逻辑，那么 `ReentrantLock` 是更好的选择。

6. **可重入性**：
   - `synchronized` 和 `ReentrantLock` 都是可重入的，这意味着同一个线程可以多次获取同一个锁。

7. **异常处理**：
   - 使用 `synchronized` 时，如果在同步块中抛出异常，锁会自动释放。
   - 使用 `ReentrantLock` 时，需要在 `finally` 块中显式调用 `unlock()` 方法来释放锁，以避免死锁。

- 使用 lock() 加锁，使用 unLock() 释放锁
- 使用对象监视器 Condition 的 await()/signalAll() 来实现 wait()/notify() 效果
- Condition 可以将线程分组,并选择性通知,粒度更细,这也是和 synchronized 的区别之一

生产者与消费者程序示例:

```java
public class Fo {

    private final List<Integer> list = new ArrayList<>(10);
    private final ReentrantLock lock = new ReentrantLock();
    //创建两个对象监视器,分别用于通知生产者和消费者
    private final Condition InCondition = lock.newCondition();
    private final Condition OutCondition = lock.newCondition();
    public static final int maxSize = 10;

    public Condition getInCondition() {
        return InCondition;
    }

    public Condition getOutCondition() {
        return OutCondition;
    }

    public ReentrantLock getLock() {
        return lock;
    }

    public Integer getFoSize(){
        return list.size();
    }

    public void putFo(){
        list.add(1);
    }

    public void gutFo(){
        list.remove(0);
    }

}
```

```java
public class In implements Runnable {

    private final Fo fo;

    public In(Fo fo) {
        this.fo = fo;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(4000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            doIn();
        }
    }

    private void doIn() {
        try {
            //加锁
            fo.getLock().lock();
            if (fo.getFoSize() >= Fo.maxSize) {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  已满等待");
                //作为生产者等待
                fo.getInCondition().await();
            } else {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  可以生产");
                fo.putFo();
                //唤醒所有消费者
                fo.getOutCondition().signalAll();
                System.out.println(Thread.currentThread().getName() + "生产后当前数量：" + fo.getFoSize());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            //释放锁
            fo.getLock().unlock();
        }
    }

}
```

```java
public class Out implements Runnable {

    private final Fo fo;

    public Out(Fo fo) {
        this.fo = fo;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(4000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            doOut();
        }
    }

    private void doOut() {
        try {
            //加锁
            fo.getLock().lock();
            if (fo.getFoSize() > 0) {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  可以拿取");
                fo.gutFo();
                //唤醒所有生产者
                fo.getInCondition().signalAll();
                System.out.println(Thread.currentThread().getName() + "拿取后当前数量：" + fo.getFoSize());
            } else {
                System.out.println(Thread.currentThread().getName() + "当前数量：" + fo.getFoSize() + "  无货等待");
                //作为消费者等待
                fo.getOutCondition().await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            //释放锁
            fo.getLock().unlock();
        }
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Fo fo = new Fo();
        new Thread(new In(fo)).start();
        new Thread(new In(fo)).start();
        new Thread(new In(fo)).start();

        new Thread(new Out(fo)).start();
    }
}
```

### 公平锁与非公平锁

锁Lock分为公平锁与非公平锁,公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的,即先来先得FIFO先进先出顺序,而非公平锁就是一种获取锁的强占机制,是随机获得锁的，ReentrantLock 可以通过构造函数参数来选择是否实现公平锁。

### ReentrantLock 的常用方法

- lock.getHoldCount() 查询当前线程持有此锁的个数,也就是调用lock()方法的次数,比如重入锁就是2
- lock.getQueueLength() 返回**正等待**获取此锁的线程估计个数
- lock.getWaitQueueLength(Condition condition) 返回等待此锁给定相关条件 condition 的估计线程数,比如5个线程都执行了同一个 condition 的 await 方法,则返回5
- lock.hasQueuedThreads() 查询是否有线程正等待获取此锁
- lock.hasQueuedThread(Thread thread) 查询指定线程是否正在等待获取此锁
- lock.hasWaiters(Condition condition) 查询是否有线程正等待与此锁定有关的 condition 条件
- lock.isFair() 查询是否为公平锁
- lock.isHeldByCurrentThread() 查询当前线程是否持有此锁
- lock.isLocked() 查询此锁定是否被任意线程持有
- lock.lockInterruptibly() 如果当前线程未被中断,则获取锁定,如果已被中断抛出异常
- lock.tryLock() 尝试获取锁,在锁未被别人获取时才会获取该锁
- lock.tryLock(long timeout, TimeUnit unit) 如果锁在给定时间内未被其他线程获取且当前线程未被中断,则获取该锁
- Condition.awaitUninterruptibly() 线程在调用condition.await()后处于await状态，此时调用thread.interrupt()会可能报错,但是使用condition.awaitUninterruptibly()后，调用thread.interrupt()则不会报错
- Condition.awaitUntil(Date deadline) 此方法可以证明线程在等待时间达到前，可以被其他线程提前唤醒

### 读写锁

ReentrantLock是完全排他锁,即同一时间只能有一个线程在执行,JDK中还提供了一种读写锁,来优化运行效率

ReentrantReadWriteLock 读写锁有两个锁,一个是读锁,也称为**共享锁**,另一个是写锁,也称为**排他锁**,读读锁之间不互斥,读写锁互斥,写写锁互斥,在没有线程进行写入操作时,进行读取的多个线程都可以获取读锁,而进行写入操作的线程只有获取写锁后才能进行写入操作,即多个线程可以同时读取,但同一时刻只允许一个线程进行写入

- lock.writeLock().lock() 写锁
- lock.readLock().lock() 读锁

**实现原理**：

1. **读锁（共享锁）**：
   - 当一个线程获取读锁时，它不会阻塞其他线程获取读锁，但会阻塞写锁的获取。
   - 读锁是共享的，允许多个线程同时持有读锁，但所有读锁必须在写锁释放后才能获取。
   - 读锁的实现通常基于一个计数器，记录当前有多少个线程持有读锁。

2. **写锁（排他锁）**：
   - 当一个线程获取写锁时，它会阻塞其他线程获取读锁和写锁，直到写锁被释放。
   - 写锁是排他的，同一时间只能有一个线程持有写锁。
   - 写锁的实现通常基于一个变量，记录当前是否有线程持有写锁。

3. **锁的获取与释放**：
   - 读锁和写锁的获取都是通过 `tryLock()` 或 `lock()` 方法实现的，这些方法会尝试获取锁。
   - 如果锁不可用，线程可以等待（通过 `lock()` 方法），或者返回失败（通过 `tryLock()` 方法）。
   - 读锁和写锁的释放是通过 `unlock()` 方法实现的，当线程不再需要锁时，它应该释放锁。

4. **锁的公平性**：
   - `ReentrantReadWriteLock` 可以通过构造函数参数来选择是否实现公平锁。
   - 公平锁意味着锁的获取顺序是按照线程请求锁的顺序来决定的，即先请求锁的线程先获得锁。
   - 非公平锁则允许线程在锁可用时立即尝试获取锁，这可能会导致某些线程饿死。

5. **锁的重入**：
   - `ReentrantReadWriteLock` 支持重入，即同一个线程可以多次获取同一个读锁或写锁。

6. **锁的升降级**：
   - 读锁可以升级为写锁，即一个线程可以先获取读锁，然后在不释放读锁的情况下获取写锁。
   - 但写锁不能降级为读锁，因为这可能会导致死锁。

使用示例：

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class Cache {
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Object cache = new Object();

    public void read() {
        rwl.readLock().lock();
        try {
            // 读取缓存
        } finally {
            rwl.readLock().unlock();
        }
    }

    public void write() {
        rwl.writeLock().lock();
        try {
            // 更新缓存
        } finally {
            rwl.writeLock().unlock();
        }
    }
}
```

在上面的示例中，`Cache` 类使用 `ReentrantReadWriteLock` 来保护对 `cache` 对象的读写操作。读操作使用读锁，写操作使用写锁。

注意事项：

- 使用 `ReentrantReadWriteLock` 时，必须确保在所有可能的执行路径上都释放了锁，以避免死锁。
- 读写锁的使用比 `synchronized` 关键字更复杂，因此在大多数情况下，如果 `synchronized` 能够满足需求，推荐使用 `synchronized`，因为它更简单且易于理解。

`ReentrantReadWriteLock` 提供了一种灵活的同步机制，适用于读多写少的并发场景，能够提高程序的并发性能。然而，它也带来了额外的复杂性，因此在使用时需要仔细考虑其适用场景和正确性。

## Semaphore

`Semaphore` 可以看作是一种信号量，它维护了一个许可集，线程在执行操作前必须获取许可，操作完成后释放许可。如果许可数量为零，则线程将被阻塞，直到有许可可用。

主要特性：

1. **许可数量**：`Semaphore` 可以初始化时指定许可的数量，这决定了同时可以有多少线程访问资源。

2. **公平性**：`Semaphore` 可以设置为公平模式或非公平模式。在公平模式下，线程将按照请求许可的顺序获得许可；在非公平模式下，没有这样的保证，线程可能会“插队”。

3. **可重入性**：`Semaphore` 是可重入的，即同一个线程可以多次获取同一个 `Semaphore` 的许可。

4. **等待和超时**：`Semaphore` 提供了 `acquire()` 方法来获取许可，如果许可不可用，线程将被阻塞直到有许可可用。此外，还提供了 `tryAcquire()` 方法，它尝试获取许可，如果许可不可用则立即返回 `false` 而不会阻塞。`tryAcquire(long timeout, TimeUnit unit)` 方法允许线程在指定的超时时间内等待许可。

5. **释放许可**：线程在完成操作后必须调用 `release()` 方法来释放许可，以便其他线程可以获取。

使用示例：

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    private static final int THREAD_COUNT = 30;
    private static final Semaphore semaphore = new Semaphore(10);

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(new Worker(i)).start();
        }
    }

    static class Worker implements Runnable {
        private final int workerNumber;

        Worker(int workerNumber) {
            this.workerNumber = workerNumber;
        }

        @Override
        public void run() {
            try {
                semaphore.acquire(); // 尝试获取许可
                System.out.println("Worker " + workerNumber + " acquired the semaphore.");
                Thread.sleep(1000); // 模拟工作
                System.out.println("Worker " + workerNumber + " released the semaphore.");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                semaphore.release(); // 释放许可
            }
        }
    }
}
```

在上面的示例中，我们创建了一个 `Semaphore` 实例，它允许最多 10 个线程同时访问资源。每个线程在执行任务前尝试获取许可，任务完成后释放许可。

注意事项：

- 使用 `Semaphore` 时，确保在所有可能的执行路径上都释放了许可，以避免死锁。
- 如果 `Semaphore` 的许可数量设置为 1，它就变成了一个互斥锁（类似于 `ReentrantLock`），可以用于实现互斥访问。
- `Semaphore` 可以用于控制对资源的访问量，例如限制同时访问数据库连接池的线程数量。

`Semaphore` 是一种灵活的同步工具，适用于控制对有限资源的访问，特别是在需要限制并发访问量的场景中非常有用。通过合理地设置许可数量，可以有效地控制并发度，避免资源竞争和系统过载。

Semaphore可以用来做流量控制，限制可以访问某些资源(物理或逻辑的)，特别公用资源有限的应用场景，比如数据库连接。

## Semaphore 和 ReentrantLock 的区别

`Semaphore` 和 `ReentrantLock` 都是 Java 中用于控制并发访问的同步工具，但它们在设计和使用上存在一些关键的区别：

1. **功能目的**：
   - `ReentrantLock` 是一种互斥锁，主要用于实现线程间的互斥访问，确保同一时间只有一个线程可以访问某个资源。
   - `Semaphore` 是一种信号量，用于控制同时访问某个资源的线程数量。它允许一定数量的线程同时访问资源，适用于控制资源的并发访问量。

2. **使用场景**：
   - `ReentrantLock` 适用于需要独占访问的场景，如保护共享资源不被多个线程同时修改。
   - `Semaphore` 适用于控制资源的访问量，如限制同时访问数据库连接池的线程数量，或者控制并发执行的任务数量。

3. **锁的获取与释放**：
   - `ReentrantLock` 的使用类似于 `synchronized` 关键字，线程通过调用 `lock()` 方法获取锁，通过 `unlock()` 方法释放锁。它支持公平锁和非公平锁的设置。
   - `Semaphore` 的使用通过 `acquire()` 方法获取许可，通过 `release()` 方法释放许可。它也支持公平和非公平的设置。

4. **可重入性**：
   - `ReentrantLock` 是可重入的，即同一个线程可以多次获取同一个锁。
   - `Semaphore` 本身不是可重入的，但可以与 `ReentrantLock` 结合使用来实现可重入性。

5. **超时和中断**：
   - `ReentrantLock` 提供了 `tryLock()` 方法，允许线程尝试获取锁，并在指定时间内等待，如果超时则返回 `false`。同时，它也支持中断响应。
   - `Semaphore` 提供了 `tryAcquire()` 方法，允许线程尝试获取许可，并在指定时间内等待，如果超时则返回 `false`。它也支持中断响应。

6. **锁的公平性**：
   - `ReentrantLock` 可以通过构造函数参数来设置为公平锁或非公平锁。
   - `Semaphore` 同样可以设置为公平或非公平。

7. **锁的降级**：
   - `ReentrantLock` 支持锁的降级，即一个线程可以先获取写锁，然后在不释放写锁的情况下获取读锁。
   - `Semaphore` 不支持锁的降级。

8. **锁的升级**：
   - `ReentrantLock` 支持锁的升级，即一个线程可以先获取读锁，然后在不释放读锁的情况下获取写锁。
   - `Semaphore` 不支持锁的升级。

总的来说，`ReentrantLock` 提供了互斥锁的功能，适用于需要独占访问的场景；而 `Semaphore` 提供了信号量的功能，适用于控制并发访问量的场景。选择使用哪种同步机制取决于具体的应用场景和需求。在某些情况下，`ReentrantLock` 和 `Semaphore` 可以结合使用，以实现更复杂的同步需求。

## StampedLock

`StampedLock`是Java 8中引入的一个新的锁机制，它提供了一种灵活的读写锁策略，旨在提高并发性能。`StampedLock`通过引入“戳”（stamp）的概念来实现读写锁的分离，从而允许读操作和写操作以更灵活的方式进行并发访问。

**主要特点**：

1. **读写分离**：`StampedLock`将读锁和写锁分离，提供了三种模式的锁：**读锁**（shared mode）、**写锁**（exclusive mode）和**乐观读**（optimistic read）。

2. **乐观读**：`StampedLock`提供了一种乐观读（optimistic read）的机制，允许读操作在没有锁的情况下进行。如果在读取过程中没有其他线程修改数据，那么读操作可以无锁地完成。如果在读取过程中数据被修改了，那么读操作会自动升级为悲观读锁。

3. **可升级和可降级**：`StampedLock`允许读锁升级为写锁，写锁也可以降级为读锁。这种灵活性可以减少锁的持有时间，提高并发性能。

4. **无饥饿性保证**：`StampedLock`不保证写锁的饥饿性，即写锁可能长时间得不到执行。因此，使用`StampedLock`时需要特别注意避免写锁饥饿的问题。

5. **不可重入**：`StampedLock`的读锁和写锁都是不可重入的。这意味着如果一个线程已经持有读锁或写锁，再次尝试获取相同的锁将会导致死锁。

**使用场景**：

`StampedLock`适用于读多写少的场景，特别是在读操作远多于写操作的情况下，可以显著提高性能。例如，缓存系统、读密集型数据库访问等。

示例代码：

```java
import java.util.concurrent.locks.StampedLock;

public class StampedLockExample {
    private final StampedLock lock = new StampedLock();

    private int value;

    public void write(int newValue) {
        long stamp = lock.writeLock(); // 获取写锁
        try {
            value = newValue;
        } finally {
            lock.unlockWrite(stamp); // 释放写锁
        }
    }

    public int read() {
        long stamp = lock.tryOptimisticRead(); // 尝试乐观读
        int current = value;
        if (!lock.validate(stamp)) { // 检查数据是否被修改
            stamp = lock.readLock(); // 如果数据被修改，获取读锁
            try {
                current = value;
            } finally {
                lock.unlockRead(stamp); // 释放读锁
            }
        }
        return current;
    }
}
```

在这个例子中，`write`方法获取写锁来更新数据，而`read`方法首先尝试使用乐观读，如果数据没有被修改，则直接返回；如果数据被修改，则获取读锁并返回数据。

`StampedLock`提供了一种新的并发控制机制，它在读多写少的场景下可以提供比传统的`ReentrantReadWriteLock`更高的性能。然而，由于其不可重入和无饥饿性保证的特性，使用时需要特别注意线程安全和锁的管理。

## StampedLock 与 ReentrantReadWriteLock 的区别

`StampedLock`和`ReentrantReadWriteLock`都是Java并发包中用于实现读写锁的工具，它们都允许读操作和写操作并发执行，但它们在设计和使用上存在一些关键的区别：

**ReentrantReadWriteLock**

- **可重入性**：`ReentrantReadWriteLock`支持读锁和写锁的可重入性。这意味着同一个线程可以多次获取同一个读锁或写锁，而不会导致死锁。
- **公平性**：`ReentrantReadWriteLock`可以配置为公平模式或非公平模式。在公平模式下，线程将按照请求锁的顺序获得锁；在非公平模式下，线程可能会“插队”。
- **锁降级**：`ReentrantReadWriteLock`支持锁降级，即一个线程可以先获取写锁，然后在不释放写锁的情况下获取读锁，之后再释放写锁。这样可以确保数据的一致性。
- **锁升级**：`ReentrantReadWriteLock`不支持锁升级，即从读锁升级到写锁。如果需要写锁，必须先释放读锁。

**StampedLock**

- **乐观读**：`StampedLock`引入了乐观读的概念，允许线程在没有锁的情况下读取数据。如果数据在读取过程中没有被其他线程修改，那么读取操作可以无锁完成。如果数据被修改了，那么读取操作会自动升级为悲观读锁。
- **不可重入性**：`StampedLock`的读锁和写锁都是不可重入的。这意味着如果一个线程已经持有读锁或写锁，再次尝试获取相同的锁将会导致死锁。
- **无饥饿性保证**：`StampedLock`不保证写锁的饥饿性，即写锁可能长时间得不到执行。因此，使用`StampedLock`时需要特别注意避免写锁饥饿的问题。
- **锁降级**：`StampedLock`不支持锁降级，即从写锁降级到读锁。如果需要读取数据，必须先释放写锁。

**区别总结**

- **可重入性**：`ReentrantReadWriteLock`支持读锁和写锁的可重入性，而`StampedLock`不支持。
- **公平性**：`ReentrantReadWriteLock`支持公平模式，而`StampedLock`不支持。
- **锁降级**：`ReentrantReadWriteLock`支持锁降级，而`StampedLock`不支持。
- **乐观读**：`StampedLock`提供了乐观读机制，而`ReentrantReadWriteLock`没有。
- **锁升级**：`ReentrantReadWriteLock`不支持锁升级，而`StampedLock`不支持锁降级。

在选择使用`StampedLock`还是`ReentrantReadWriteLock`时，需要根据具体的应用场景来决定。如果应用中读操作远多于写操作，并且对读操作的性能有较高要求，同时可以接受写锁可能的饥饿问题，那么`StampedLock`可能是一个更好的选择。如果需要保证写锁的公平性，或者需要锁的降级功能，那么`ReentrantReadWriteLock`可能更适合。

需要注意的是，`StampedLock`的使用相对复杂，且由于其不可重入和无饥饿性保证的特性，使用时需要特别注意线程安全和锁的管理。在某些情况下，`ReentrantReadWriteLock`可能提供更简单、更安全的读写锁实现。

## 死锁的检测

在Java中，死锁是指两个或多个线程无限期地等待对方释放锁，而无法继续执行的情况。死锁的检测通常比较复杂，因为需要分析线程的执行状态和锁的持有情况。Java本身并没有提供直接的死锁检测工具，但可以通过以下几种方法来检测和解决死锁问题：

1. 代码审查
- **手动检查**：通过阅读代码和线程的执行逻辑，分析是否存在互相等待对方释放锁的情况。
- **工具辅助**：使用IDE（如IntelliJ IDEA）的线程分析工具，可以查看线程的调用栈和锁的持有情况。

2. 使用调试工具
- **JVM参数**：通过设置JVM参数 `-XX:+PrintLocks` 和 `-XX:+PrintGCDetails`，可以在GC日志中查看锁的获取和释放情况。
- **jstack工具**：使用`jstack`命令可以打印出Java进程的线程堆栈信息，通过分析线程堆栈可以发现死锁的线索。

3. 死锁检测算法
- **银行家算法**：这是一种预防死锁的算法，通过预先分配资源并检查资源分配是否会导致系统进入不安全状态来避免死锁。
- **资源分配图**：通过构建资源分配图，分析是否存在环形等待的情况来检测死锁。

4. 死锁检测库
- **第三方库**：有一些第三方库提供了死锁检测的功能，例如`DeadLockDetector`，可以集成到应用程序中进行实时检测。

5. 死锁预防策略
- **锁顺序**：确保所有线程按照相同的顺序获取锁，可以避免死锁。
- **锁超时**：使用`tryLock(long timeout, TimeUnit unit)`方法，设置一个超时时间，如果在指定时间内无法获取锁，则放弃等待，避免无限期等待。

6. 死锁恢复
- **重启应用**：在某些情况下，如果检测到死锁，最简单的方法是重启应用。
- **手动干预**：在生产环境中，如果检测到死锁，可以手动干预，例如强制终止某个线程。

示例：使用jstack检测死锁

```shell
jstack <pid>
```

其中 `<pid>` 是Java进程的ID。执行上述命令后，你会得到一个线程堆栈的快照，其中包含了死锁的详细信息。例如：

```
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00000000030016e8 (object 0x000000076ab100f8, a java.lang.Object),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00000000030016f8 (object 0x000000076ab10108, a java.lang.Object),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at DeadlockExample$Thread1.run(DeadlockExample.java:25)
        - waiting to lock <0x000000076ab100f8> (a java.lang.Object)
        - locked <0x000000076ab10108> (a java.lang.Object)
"Thread-0":
        at DeadlockExample$Thread0.run(DeadlockExample.java:15)
        - waiting to lock <0x000000076ab10108> (a java.lang.Object)
        - locked <0x000000076ab100f8> (a java.lang.Object)

Found 1 deadlock.
```

在上面的输出中，`jstack`工具检测到两个线程互相等待对方释放锁，形成了死锁。

注意事项
- 死锁检测和预防策略需要根据具体的应用场景和需求来选择和实施。
- 死锁检测可能会带来一定的性能开销，因此在生产环境中应谨慎使用。
- 死锁预防策略（如锁顺序）需要在设计阶段就考虑周全，以避免死锁的发生。

在实际开发中，应尽量避免死锁的发生，通过良好的设计和编码实践来预防死锁。如果确实发生了死锁，应根据具体情况选择合适的检测和恢复策略。

## 饥饿

饥饿（Starvation）是多线程编程中的一种现象，指的是一个或多个线程因为资源竞争、调度策略或其他原因而长时间无法获得执行的机会，从而无法继续执行其任务。饥饿问题可能导致线程无法完成其工作，影响程序的性能和响应性。在Java中，导致线程饥饿的原因主要有以下几种：

1. **高优先级线程吞噬资源**：
   当系统中存在高优先级的线程时，低优先级的线程可能会因为无法获得足够的CPU时间而长时间处于等待状态。在Java中，可以通过`Thread.setPriority(int)`方法来设置线程的优先级，优先级范围从1（最低）到10（最高）。然而，高优先级线程并不保证能够完全避免饥饿，因为操作系统调度策略可能会影响线程的执行。

2. **线程被永久堵塞在同步块**：
   当多个线程竞争同一个锁时，如果一个线程总是能够先获得锁，其他线程可能会因为无法获得锁而长时间等待。例如，如果一个线程在同步块中执行了长时间的计算或I/O操作，其他线程可能会因为无法进入同步块而饥饿。

3. **线程在等待一个永久等待完成的对象**：
   如果一个线程调用了某个对象的`wait()`方法，并且没有其他线程调用该对象的`notify()`或`notifyAll()`方法来唤醒它，那么这个线程可能会无限期地等待下去。如果其他线程总是能够获得锁并调用`notify()`或`notifyAll()`，而这个线程始终无法获得锁，那么它就会处于饥饿状态。

为了避免线程饥饿，可以采取以下措施：

- **公平锁**：使用公平锁（Fair Lock）来确保线程按照请求锁的顺序获得锁，从而避免某些线程长时间等待。
- **线程优先级调整**：合理设置线程的优先级，避免高优先级线程长时间占用资源。
- **锁超时机制**：在获取锁时设置超时时间，如果超时未能获得锁，则可以采取其他策略，如重试或执行其他任务。
- **避免长时间持有锁**：尽量减少同步块中的代码执行时间，避免长时间持有锁。
- **使用线程池**：合理配置线程池的大小和任务队列，避免线程池中的线程长时间等待任务。

通过这些策略，可以在一定程度上减少线程饥饿的发生，提高程序的稳定性和响应性。然而，完全避免线程饥饿是非常困难的，特别是在复杂的并发环境中，因此需要根据具体的应用场景和需求来设计合理的并发控制策略。

# 线程间通信

线程之间可以相互通信和协作，线程通信主要可以分为三种方式，分别为共享内存、消息传递和管道流，每种方式可以有不同的方法来实现。

## 等待/通知机制（wait/notify）

[Java的等待-通知(wait-notify)机制](https://blog.csdn.net/y277an/article/details/98697454)

- wait/notify 方法必须在 synchronized 同步块中调用
- 必须是当前锁的对象调用
- 调用wait方法后线程进入等待状态同时释放锁，并使当前线程从运行状态退出进入等待队列
- 调用notify方法后不会释放锁
- 调用notify会随机唤醒一个等待当前锁的线程，使其退出等待队列进入可运行状态
- 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞挂起的线程，一个线程被唤醒后才会进入就绪队列，被wait后进入阻塞队列。
- 处于wait状态的线程调用interrupt方法会出现异常。
- wait(long)方法等待一段时间后自动唤醒，也可以在等待时间内被其他线程唤醒。

![](https://raw.githubusercontent.com/MrSunflowers/images/main/note/spring/202203231020627.png)

## CountDownLatch

`CountDownLatch`是Java并发包（`java.util.concurrent`）中的一个同步辅助类，它允许一个或多个线程等待直到在其他线程中执行的一组操作完成。`CountDownLatch`是基于AQS（AbstractQueuedSynchronizer）实现的，它使用一个内部计数器来跟踪线程等待的事件数量。

**主要特点**：

1. **计数器初始化**：在创建`CountDownLatch`实例时，需要指定一个整数作为计数器的初始值。这个值表示需要等待的事件数量。

2. **等待事件完成**：调用`await()`方法的线程将被阻塞，直到计数器的值减到0。如果计数器的值已经是0，则`await()`方法不会阻塞当前线程。

3. **减少计数器**：其他线程可以通过调用`countDown()`方法来减少计数器的值。每次调用`countDown()`，计数器的值减1。

4. **一次性使用**：一旦计数器的值减到0，就不能再次使用`CountDownLatch`。如果需要再次使用，必须创建一个新的`CountDownLatch`实例。

**使用场景**：

`CountDownLatch`常用于以下场景：

- **启动前准备**：在多个线程开始执行之前，等待所有线程完成准备工作。
- **主从任务**：主任务等待多个子任务完成后再继续执行。
- **测试**：在测试中，主线程等待多个测试用例执行完毕后再进行结果汇总。

**示例代码**：

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个计数器，初始值为3
        CountDownLatch latch = new CountDownLatch(3);

        // 启动三个线程
        new Thread(() -> {
            System.out.println("子线程1执行完毕");
            latch.countDown(); // 减少计数器的值
        }).start();

        new Thread(() -> {
            System.out.println("子线程2执行完毕");
            latch.countDown(); // 减少计数器的值
        }).start();

        new Thread(() -> {
            System.out.println("子线程3执行完毕");
            latch.countDown(); // 减少计数器的值
        }).start();

        // 主线程等待所有子线程执行完毕
        latch.await(); // 等待计数器减到0
        System.out.println("所有子线程执行完毕，主线程继续执行");
    }
}
```

在这个例子中，主线程创建了一个`CountDownLatch`实例，初始计数器值为3。然后启动了三个子线程，每个子线程执行完毕后调用`countDown()`方法减少计数器的值。主线程调用`await()`方法等待计数器减到0，然后继续执行。

`CountDownLatch`是一个非常有用的同步工具，它简化了线程间的协调工作，使得多线程编程更加高效和简洁。

## CyclicBarrier

`CyclicBarrier`是Java并发包（`java.util.concurrent`）中的一个同步辅助类，它允许一组线程互相等待，直到所有线程都到达某个公共的屏障点（Barrier Point）。当所有线程都到达屏障点时，屏障会打开，所有线程可以继续执行。`CyclicBarrier`可以被重用，这意味着它可以在多个阶段的同步中重复使用，直到达到预设的循环次数。

**主要特点**：

1. **屏障点**：所有线程在执行到某个点时必须等待，直到所有线程都到达这个点。

2. **重用性**：`CyclicBarrier`可以被重置，这意味着它可以在多个阶段的同步中重复使用。

3. **等待线程**：当线程到达屏障点时，它会调用`await()`方法，然后进入等待状态。如果所有线程都到达了屏障点，屏障会打开，所有线程会被唤醒继续执行。

4. **可选的屏障动作**：在所有线程到达屏障点后，可以执行一个可选的屏障动作（Runnable），这个动作由最后一个到达屏障的线程执行。

5. **构造函数**：`CyclicBarrier`的构造函数接受两个参数：屏障点的线程数和可选的屏障动作。

**使用场景**：

`CyclicBarrier`常用于以下场景：

- **并行处理**：在并行处理任务时，多个线程可以同时开始执行，但需要在某个点同步，确保所有线程都完成任务后再继续执行后续步骤。
- **多阶段任务**：在多阶段任务中，每个阶段的结束可以作为屏障点，所有线程必须等待直到所有线程都完成当前阶段。

**示例代码**：

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    public static void main(String[] args) {
        // 创建一个CyclicBarrier实例，指定需要等待的线程数为3
        CyclicBarrier barrier = new CyclicBarrier(3, () -> {
            System.out.println("所有线程已到达屏障点，执行屏障动作");
        });

        // 启动三个线程
        new Thread(() -> {
            try {
                System.out.println("线程1到达屏障点");
                barrier.await(); // 等待其他线程到达
                System.out.println("线程1继续执行");
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try {
                System.out.println("线程2到达屏障点");
                barrier.await(); // 等待其他线程到达
                System.out.println("线程2继续执行");
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try {
                System.out.println("线程3到达屏障点");
                barrier.await(); // 等待其他线程到达
                System.out.println("线程3继续执行");
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

在这个例子中，我们创建了一个`CyclicBarrier`实例，它要求三个线程都到达屏障点后才能继续执行。每个线程在到达屏障点时调用`await()`方法，当所有线程都到达后，屏障动作被执行，然后所有线程继续执行。

`CyclicBarrier`是实现线程间同步的一种有效方式，特别是在需要多个线程协作完成任务的场景中。它提供了一种灵活的方式来控制线程的执行流程，使得多线程编程更加方便和高效。

## CyclicBarrier 和 CountDownLatch 的区别

`CyclicBarrier`和`CountDownLatch`都是Java并发包中用于线程间同步的工具，它们都可以用来控制一组线程等待直到某个条件满足后继续执行。尽管它们在功能上有相似之处，但它们的设计和使用场景有所不同。

**CyclicBarrier**

- **重用性**：`CyclicBarrier`可以被重用，意味着它可以在多个阶段的同步中重复使用。当所有线程到达屏障点后，屏障会重置，等待下一轮的线程到达。
- **同步点**：`CyclicBarrier`在所有线程到达同步点后，可以执行一个可选的屏障动作（Runnable），这个动作由最后一个到达屏障的线程执行。
- **构造函数**：`CyclicBarrier`的构造函数接受两个参数：参与同步的线程数和可选的屏障动作。
- **使用场景**：适用于多个线程需要在某个共同点上等待，直到所有线程都到达该点后，再一起继续执行的场景。

**CountDownLatch**

- **一次性使用**：`CountDownLatch`是一次性的，一旦计数器减到0，就不能再次使用。如果需要再次使用，必须创建新的`CountDownLatch`实例。
- **计数器**：`CountDownLatch`的计数器是递减的，线程调用`countDown()`方法来减少计数器的值，当计数器减到0时，等待的线程会被唤醒。
- **构造函数**：`CountDownLatch`的构造函数接受一个整数参数，表示计数器的初始值。
- **使用场景**：适用于一个或多个线程等待直到其他线程完成一系列操作后继续执行的场景。

**区别总结**

- **重用性**：`CyclicBarrier`可以重用，而`CountDownLatch`是一次性的。
- **同步点**：`CyclicBarrier`在所有线程到达同步点后可以执行一个屏障动作，而`CountDownLatch`没有这个功能。
- **计数器**：`CountDownLatch`的计数器是递减的，而`CyclicBarrier`的计数器是递增的（虽然在使用时是递减的）。
- **使用场景**：`CyclicBarrier`适用于多个线程在某个共同点上等待，而`CountDownLatch`适用于一个或多个线程等待其他线程完成一系列操作。

在选择使用`CyclicBarrier`还是`CountDownLatch`时，需要根据具体的应用场景来决定。如果需要在多个阶段中重复使用同步机制，或者需要在所有线程到达同步点后执行额外的操作，那么`CyclicBarrier`可能是一个更好的选择。如果只需要等待其他线程完成一系列操作，那么`CountDownLatch`可能更简单、更直接。

## 通过管道进行线程间的通信

在java中提供了各种各样的输入输出流用于数据操作，其中管道流是一种特殊的流，可以用于在不同的线程之间传送数据。

管道流一共有四种：

- PipedReader
- PipedWriter
- PipedOutputStream
- PipedInputStream

示例程序：

```java
public class Thread1 implements Runnable{

    private final PipedReader reader;

    public Thread1(PipedReader reader) {
        this.reader = reader;
    }

    @Override
    public void run() {
        char[] chars = new char[20];
        int readLength = 0;
        try {
            //由于开始并没有数据被写入，线程在此阻塞，直到有数据写入，才继续向下运行
            readLength = reader.read(chars);
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(String.valueOf(chars,0,readLength));
    }
}
```

```java
public class Thread2 implements Runnable{

    private final PipedWriter writer;

    public Thread2(PipedWriter writer) {
        this.writer = writer;
    }

    @Override
    public void run() {
        try {
            writer.write("传递给Thread1的数据");
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Main {
    private static final PipedReader reader = new PipedReader();
    private static final PipedWriter writer = new PipedWriter();

    public static void main(String[] args) {

        try {
            //通过下面两种方法使两个流之间产生连接
            //writer.connect(reader);
            reader.connect(writer);
            new Thread(new Thread1(reader)).start();
            Thread.sleep(2000);
            new Thread(new Thread2(writer)).start();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

}
```

## join

在很多情况下，主线程创建子线程，如果子线程中要进行大量的耗时运算，主线程往往早于子线程结束，此时，如果子线程想等待子线程执行完成后再结束，比如主线程需要获取子线程处理的结果，此时可以使用join方法。

```java
public class SubThread implements Runnable{
    @Override
    public void run() {
        int secValue = (int) (Math.random()*10000);
        System.out.println("子线程需要处理时间："+secValue);
        try {
            Thread.sleep(secValue);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("子线程处理完成");
    }
}
```

```java
public class MainThread implements Runnable{
    @Override
    public void run() {
        Thread subThread = new Thread(new SubThread());
        System.out.println("主线程开始");
        subThread.start();
        System.out.println("主线程等待子线程处理");
        try {
            subThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程结束");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        new Thread(new MainThread()).start();
    }
}
```

- 方法join的作用是使**当前线程**无限期阻塞，等待join**所属**线程执行run方法中的任务
- join方法具有使线程排队运行的作用，类似于同步运行，于synchronized关键字的区别是，join在内部使用wait方法进行等待，而synchronized关键字使用对象锁原理同步
- join方法遇到interrupt会出现异常。
- join(long)其中long为等待时间，join(long)与sleep(long)的区别与wait()与sleep(long)的区别相同，join(long)会释放锁，sleep不会

## ThreadLocal

ThreadLocal主要用来存储每个线程自己的值。

- 第一次获取值为null；
- 每个线程拥有自己独立的值，互不影响；
- 底层容器使用 ThreadLocalMap 实现，每个线程中都有自己的一个 ThreadLocalMap
- ThreadLocalMap 又使用 ThreadLocal 实例作为其 key，这样就实现了横向与纵向的双重隔离
- remove 方法是删除特定的 ThreadLocal，建议在 ThreadLocal 使用完后一定要执行此方法。
- 调用remove()方法最佳时机是线程运行结束之前的finally代码块中调用，这样能完全避免操作不当导致的内存泄漏，这种主动清理的方式比惰性删除有效。

[ThreadLocal详解](https://blog.csdn.net/wangnanwlw/article/details/108866086)

## InheritableThreadLocal

- InheritableThreadLocal 类可以在子线程中取得父线程继承下来的值。
- 如果子线程在取得值的同时，主线程将 InheritableThreadLocal 中的值进行更改，那么子线程取到的值还是旧值

## volatile 

volatile 关键字的作用是**强制从公共堆栈中取得变量的值**，而不是从线程私有数据栈中取得变量的值以及**禁止指令重排序**，在 jvm 被设置为 server 模式运行时，为了提升运行效率，线程一直在线程私有堆栈中获取变量。多线程访问 volatile 时不会发生阻塞，而 synchronized 会出现阻塞，volatile 可以保证数据的可见性，但无法保证原子性，volatile 主要的使用场景是在多线程环境下，每个线程可以感知实例变量被更改了，并且可以获取最新的值使用。但是在对 volatile 实例变量修改时其实并不是一个原子操作，也就是非线程安全的。
1. 从内存中取出 i 值；

2. 计算 i 值；

3. 将 i 值写入内存中；

假如在步骤 2 计算 i 值时，其他线程也修改 i 值，那么此时就会出现脏读现象。

[Java并发编程之volatile可见及非原子特性](https://blog.csdn.net/weixin_44692700/article/details/121491956)

此时就需要使用原子类进行 i++ 操作，但

[原子类也并不完全安全](https://www.jianshu.com/p/f7dbb1e7b5c5)

## 原子类

Java Concurrency API 提供了一系列的原子类（atomic classes），这些类位于 `java.util.concurrent.atomic` 包中。原子类提供了一种线程安全的方式来更新基本类型（如 int、long、boolean 等）和对象引用。这些类通过使用无锁的算法和硬件级别的原子指令来实现线程安全，从而避免了使用传统的同步机制（如 synchronized 关键字）带来的性能开销。

以下是 Java Concurrency API 中一些常用的原子类：

1. `AtomicBoolean`：一个可以原子更新的布尔值。
2. `AtomicInteger`：一个可以原子更新的 int 值。
3. `AtomicLong`：一个可以原子更新的 long 值。
4. `AtomicIntegerArray`：一个可以原子更新的 int 数组。
5. `AtomicLongArray`：一个可以原子更新的 long 数组。
6. `AtomicReference`：一个可以原子更新的对象引用。
7. `AtomicReferenceArray`：一个可以原子更新的对象引用数组。
8. `AtomicMarkableReference`：一个可以原子更新的对象引用和一个布尔值。
9. `AtomicStampedReference`：一个可以原子更新的对象引用和一个整数“版本号”。
10. `AtomicIntegerFieldUpdater`：一个可以原子更新指定类的 int 类型字段的工具类。
11. `AtomicLongFieldUpdater`：一个可以原子更新指定类的 long 类型字段的工具类。
12. `AtomicReferenceFieldUpdater`：一个可以原子更新指定类的对象引用字段的工具类。

这些原子类提供了多种方法来更新它们的值，包括：

- `get()`：获取当前值。
- `set(newValue)`：设置新值。
- `getAndSet(newValue)`：获取当前值并设置新值。
- `compareAndSet(expect, update)`：如果当前值等于预期值，则设置新值，并返回 true；否则返回 false。
- `getAndUpdate(updateFunction)`：获取当前值并使用提供的函数更新它，然后返回更新前的值。
- `updateAndGet(updateFunction)`：获取当前值并使用提供的函数更新它，然后返回更新后的值。
- `getAndAccumulate(x, accumulatorFunction)`：获取当前值并使用提供的函数与 x 累积，然后返回更新前的值。
- `accumulateAndGet(x, accumulatorFunction)`：获取当前值并使用提供的函数与 x 累积，然后返回更新后的值。

使用这些原子类可以简化并发编程中的同步问题，提高程序的性能和可维护性。在多线程环境下，使用原子类可以避免竞态条件和数据不一致的问题。

# 线程安全

## 线程安全与 i--

对于线程安全来说，常常使用 synchronized 关键字来解决，但在 System.out.println 与 i-- 一起使用时可能会出现问题。

**System.out.println**

```java
public void println(String x) {
    synchronized (this) {
        print(x);
        newLine();
    }
}
```

可以看到 Java 提供的 println 方法内部是同步的。

```java
public class PrintAndNum implements Runnable{
    private int i = 5;
    @Override
    public void run() {
        System.out.println("i=" + i-- + " - " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        PrintAndNum printAndNum = new PrintAndNum();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
        new Thread(printAndNum).start();
    }
}
```

```text
i=5 - Thread-0
i=2 - Thread-3
i=4 - Thread-1
i=2 - Thread-4
i=3 - Thread-2
```

在测试结果中还是会出现线程安全问题，原因是虽然 println 方法内部是同步的，但 i-- 操作却是在进入 println 方法之前发生的。

## String 常量池的特性

```java
public class main {
    public static void main(String[] args) {
        String a = "a";
        String b = "a";
        System.out.println(a == b);//true
    }
}
```

由于 String 常量池的存在会导致两个方法拥有同样的锁。

# 定时器

在 JDK 中 Timer 类主要负责计划任务功能

```java
public class Demo1 {
    private static final Timer timer = new Timer(false
            /*是否使定时器作为守护线程启动,
            守护线程在程序运行结束后快速结束,
            定时任务也不再运行*/);
     static class MyTimer extends TimerTask{
        @Override
        public void run() {
            System.out.println(new Date().toLocaleString());
			
        }
    }

    public static void main(String[] args) throws ParseException {
        MyTimer myTimer = new MyTimer();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date parse = sdf.parse("2022-03-29 09:53:00");
		//在指定时间执行
        timer.schedule(myTimer,parse);
		//在指定时间之后,每隔3s执行一次
        //timer.schedule(myTimer,parse,3000);
		//在当前时间5后,每隔3s执行一次
        //timer.schedule(myTimer,5000,3000);
    }
}
```

- 执行时间晚于当前时间:在未来执行
- 执行时间早于当前时间:立即执行
- TimerTask以队列方式顺序执行,前面任务执行时间长会影响后面任务启动时间
- schedule方法scheduleAtFixedRate方法都是顺序执行,所以没有线程安全问题
- schedule与scheduleAtFixedRate方法的区别只在任务没有延时的情况
  - schedule:如果任务没有延时,则下一次任务的开始时间参考上一次任务的开始时间计算
  - scheduleAtFixedRate:如果任务没有延时,则下一次任务的开始时间参考上一次任务的结束时间计算
  - 在延时执行的情况下,两个方法没有区别,都是参考上一次任务的结束时间计算
  - schedule方法不具有追赶执行机制,而scheduleAtFixedRate具有追赶执行机制,错过的任务会补充性执行

# java 8 CompletableFuture 异步编排

https://juejin.cn/post/6970558076642394142

# 常见问题

1. start()与run()的区别，调用start()方法会创建一个新的子线程并启动，run()方法只是Thread的一个普通方法的调用。
2. Thread和Runnable的关系Runable接口并没有start方法，需要依赖Thread来启动，Thread是实现了Runnable接口的类，使得run支持多线程，因类的单一继承原则，推荐多使用Runnable
3. 如何给run()方法传参，实现的方式主要有三种：构造函数传参，成员变量传参，回调函数传参。
4. 如何处理线程的返回值，实现的方式有三种：主线程等待法，使用 Thread 类的join() 阻塞当前线程以等待子线程处理完毕，通过 Callable 接口实现：通过 FutureTask 或者线程池获取

# 利用原子类实现CAS递增

```java
package com.company;

import java.util.concurrent.atomic.AtomicInteger;

public class Main {

    private final AtomicInteger atomicInteger = new AtomicInteger(0);

    public static void main(String[] args) {
        Main main = new Main();
        int andIncrement = main.getAndIncrement();
        System.out.println(andIncrement);
    }

    public final int getAndIncrement() {
        int current;
        int next;
        do {
            current = atomicInteger.get();
            next = current >= Integer.MAX_VALUE ? 0 : current + 1;
            // CAS 操作，操作不成功则重复
        } while (!atomicInteger.compareAndSet(current, next));
        return next;
    }
}

```

