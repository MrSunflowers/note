# 二、对象和变量的并发访问

线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。

## 1. synchronized

&emsp;&emsp;非线程安全带来的问题就是多个线程在对同一个对象中的实例变量进行并发访问时。产生脏读，也就是取到的数据其实是被更改过的。

&emsp;&emsp;方法内的变量是线程安全的，而实例变量非线程安全。synchronized 关键字取得的锁都是对象锁，而不是把一段代码或方法当做锁，想要达到同步效果的前提是多个线程访问的是同一个对象，如果多个线程访问多个对象，就会产生多个锁。

&emsp;&emsp;synchronized 关键字具有锁重入功能，也就是在使用时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的，也就是说，在一个 synchronized 方法/块内部调用**本类**其他 synchronized 方法/块时永远可以得到锁，如果不可重入就会造成死锁。可重入锁也支持在父子类继承的环境中，也就是说，在子类的同步方法中完全可以调用父类的同步方法。

&emsp;&emsp;当线程执行出现异常时，其所持有的锁会自动释放。

&emsp;&emsp;同步方法不具有继承性，也就是说子类的方法无法从父类方法继承 synchronized 关键字的作用。

&emsp;&emsp;使用 synchronized 同步块可以减少同步代码的数量来提升运行效率，在使用同步块时需要注意的是，当一个线程访问 object 的同步代码块时，其他线程对同一个 object 中其他同步块的访问将会被阻塞。synchronized(this)也是锁定的当前对象，这说明 synchronized 使用的对象监视器是一个。另外，synchronized 加在 static 方法上时是为当前的 *.java 文件所对应的 Class 类进行持锁，而加到非 static 方法上是为当前对象上锁。synchronized(class) 代码块的作用与synchronized 加在 static 方法上的作用一样。

## 2. String 常量池的特性

```java
public class main {
    public static void main(String[] args) {
        String a = "a";
        String b = "a";
        System.out.println(a == b);//true
    }
}
```

&emsp;&emsp;String 常量池会导致两个方法拥有同样的锁。

## 3. 死锁

&emsp;&emsp;可以使用 JDK 自带的工具来检测是否有死锁的现象，使用 cmd 进入 jdk 安装的 bin 目录，执行 jps 命令，得到运行的线程 id ，再执行 jstack 命令检测死锁现象。在程序设计时要避免互相持有对方锁的情况。

## 4. 锁对象的改变

[锁对象的改变](https://www.cnblogs.com/newlangwen/p/7596416.html)

## 5. volatile 

&emsp;&emsp;volatile 关键字的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值和禁止指令重排序，在jvm被设置为server模式运行时，为了提升运行效率，线程一直在私有堆栈中获取变量，多线程访问volatile时不会发生阻塞，而synchronized会出现阻塞，volatile可以保证数据的可见性，但不能保证原子性，volatile主要的使用场景是在多线程环境下，每个线程可以感知实例变量被更改了，并且可以获取最新的值使用。但是在修改实例变量时，比如i++也就是i=i+1;则这样的操作其实并不是一个原子操作，也就是非线程安全的。
1. 从内存中取出i值；
2. 计算i值；
3. 将i值写入内存中；
假如在步骤2计算值时，其他线程也修改i值，那么此时就会出现脏读现象。

[volatile非原子的特性](https://blog.csdn.net/qq_26545305/article/details/79144791)
[Java并发编程之volatile可见及非原子特性](https://blog.csdn.net/weixin_44692700/article/details/121491956)
[原子类也并不安全](https://www.jianshu.com/p/f7dbb1e7b5c5)

## 6. volatile 