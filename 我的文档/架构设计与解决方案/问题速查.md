# 依赖&配置

## 加载自定义配置

```java
@EnableConfigurationProperties(ThreadPoolConfigProperties.class)
@Configuration
public class MyThreadConfig {
    @Bean
    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {
        return new ThreadPoolExecutor(
                pool.getCoreSize(),
                pool.getMaxSize(),
                pool.getKeepAliveTime(),
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(100000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }

    @ConfigurationProperties(prefix = "gulimall.thread")
    @Data
    public class ThreadPoolConfigProperties {
        private Integer coreSize;
        private Integer maxSize;
        private Integer keepAliveTime;
    }
}
```


```yml
gulimall:
  thread:
    core-size: 20
    max-size: 200
    keep-alive-time: 10
```

## parent

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.2.RELEASE</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
```

## web

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>servlet-api</artifactId>
    <version>2.5</version>
    <scope>provided</scope>
</dependency>
```

### 配置本地资源路径

```yml
spring:
  # 配置静态资源路径
  resources:
    static-locations: classpath:templates/,classpath:static/
```

### 静态资源映射

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 添加处理器
     * 未加该处理器时使用此链接请求资源localhost:10000/index/js/swiper-3.4.2.jquery.min.js
     * 添加处理器后使用此链接请求资源localhost:10000/static/index/js/swiper-3.4.2.jquery.min.js
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
    }
}
```

作用：
- 注册处理静态资源的处理器，指定静态资源的访问路径。
- 将请求映射到指定的静态资源位置，使得客户端可以访问这些静态资源。
调用addResourceHandler方法，指定了静态资源的访问路径为"/static/**"，并且指定了静态资源的位置为"classpath:/static/"，这样就将所有以"/static/"开头的请求映射到项目中的static文件夹下的静态资源。

### 配置应用名称

```yml
spring:
  application:
    name: gulimall-order
```

### 配置端口

```yml
server:
  port: 9000
```

### 配置项目上下文路径

```yml
server:
  servlet:
    context-path: urrp
```

## spring security

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

## mybatis-plus

```xml
<!--  mybatis-plus -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.2.0</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.17</version>
</dependency>
```

```yml
mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
  global-config:
    db-config:
      id-type: auto
      logic-delete-value: 1
      logic-not-delete-value: 0
```

```java
@Configuration
@EnableTransactionManagement //开启事务
@MapperScan("com.atguigu.gulimall.product.dao")
public class MyBatisConfig {
    //引入分页插件
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
         paginationInterceptor.setOverflow(true);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
        paginationInterceptor.setLimit(1000);
        return paginationInterceptor;
    }
}
```

## openfeign

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

## thymeleaf

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

开发禁用缓存

```yml
spring:
  thymeleaf:
    cache: false
```

## RabbitMQ

依赖

```xml
<!--amqp高级消息队列协议，rabbitmq实现-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

```yml
spring:
  rabbitmq:
    host: 192.168.56.10
    port: 5672
    # 虚拟主机
    virtual-host: /
    # 开启发送端发送确认，无论是否到达broker都会触发回调【发送端确认机制+本地事务表】
    publisher-confirm-type: correlated
    # 开启发送端抵达队列确认，消息未被队列接收时触发回调【发送端确认机制+本地事务表】
    publisher-returns: true
    # 消息在没有被队列接收时是否强行退回
    template:
      mandatory: true
    # 消费者手动确认模式，关闭自动确认，否则会消息丢失
    listener:
      simple:
        acknowledge-mode: manual
```

## redis

```xml
<!--redis启动器-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <exclusions>
        <!--lettuce，redis客户端，使用netty作网络通信-->
        <exclusion>
            <groupId>io.lettuce</groupId>
            <artifactId>lettuce-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!--jedis，redis客户端，解决压测堆外内存溢出，springboot2.3.2已解决-->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
<!--redisson，redis客户端，封装了分布式锁实现，也可以使用springboot的方式，不需要自己配置-->
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.13.3</version>
</dependency>
```

```yml
spring:
  redis:
    host: redis-dev
    port: 6379
```

```java
@Configuration
public class MyRedissonConfig {

    /**
     * 注入客户端实例对象
     */
    @Bean(destroyMethod="shutdown")
    public RedissonClient redisson(@Value("${spring.redis.host}") String host, @Value("${spring.redis.port}")String port) throws IOException {
        // 1.创建配置
        Config config = new Config();
        config.useSingleServer().setAddress("redis://" + host + ":" + port);// 单节点模式
//        config.useSingleServer().setAddress("rediss://" + host + ":" + port);// 使用安全连接
//        config.useClusterServers().addNodeAddress("127.0.0.1:7004", "127.0.0.1:7001");// 集群模式
        // 2.创建redisson客户端实例
        RedissonClient redissonClient = Redisson.create(config);
        return redissonClient;
    }
}
```

## spring cache

```xml
<!--Spring Cache，使用注解简化开发-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

```yml
spring:
  cache:
    type: redis # 使用redis作为缓存
    redis:
      time-to-live: 3600s # 过期时间
      # key-prefix: CACHE_ # 会导致自己在@Cacheable里设置的名字失效，所以这里不指定
      use-key-prefix: true # key值加前缀
      cache-null-values: true # 缓存空值
```

## spring session

```xml
<!--整合springsession，实现session共享-->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

```yml
spring:
  session:
    store-type: redis
```

```java
@Configuration
public class GulimallSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        cookieSerializer.setDomainName("gulimall.com");// 放大作用域
        cookieSerializer.setCookieName("GULISESSION");
        cookieSerializer.setCookieMaxAge(60 * 60 * 24 * 7);// 指定cookie有效期7天，会话级关闭浏览器后cookie即失效
        return cookieSerializer;
    }

    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        // 指定session序列化到redis的序列化器
//        return new Jackson2JsonRedisSerializer<Object>(Object.class);// 无法保存对象类型，反序列化后默认使用Map封装
        return new GenericJackson2JsonRedisSerializer();
    }
}
```

# 解决方案

## 跨域

在gateway中配置跨域

```java
@Configuration
public class GulimallCorsConfiguration {

    /**
     * 跨域解决办法之一：
     * 过滤器，给所有请求增加请求头信息
     * 使得预检请求通过
     */
    @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 1、配置跨域
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.setAllowCredentials(true);// 否则跨域请求会丢失cookie信息

        source.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```

## 对象云存储上传方式

上传方式【采用方式二】
方式一：
	文件先上传到应用服务器，然后在上传到 OSS
方式二：
	服务端签名后直传【https://www.baidu.com/index.php?tn=monline_3_dg】
	1）用户向应用服务器请求上传Policy
	2）应用服务器返回上传Policy【由服务器控制上传地址等信息】
	3）用户直接上传OSS

1. **文件先上传到应用服务器，然后再上传到OSS**：这种方式通常称为“先传到服务端再传到OSS”，即文件首先上传到你的应用服务器，然后应用服务器再将文件上传到OSS。这种方式的优点是你可以在应用服务器上对文件进行一些处理，比如校验、压缩、加密等，然后再上传到OSS。然而，这种方式会增加服务器的负担，并且会消耗额外的带宽和时间。如果应用服务器和OSS之间的网络延迟较大，上传速度可能会受到影响。
2. **服务端签名后直传**：这种方式通常称为“直传”，即客户端通过应用服务器获取OSS的上传凭证（通常是签名的URL或者一组临时的认证信息），然后直接通过这些凭证将文件上传到OSS，而不需要经过应用服务器。这种方式的优点是可以减轻应用服务器的负担，减少了文件上传的时间和带宽消耗，同时也可以更好地利用OSS的分布式存储和高速网络。

报表等需要校验的文件采用 方式一
图片等不需要校验的文件采用 方式二

## 后台返回前端时间格式化处理

未格式化之前返回数据：
2020-08-13T01:38:11.000+00:00

添加配置：（同时修改时区）
```yml
spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
```

## 静态资源前置

在 Vue + Java Web + Nginx 架构中，静态资源前置思想可以通过以下方式进行设计和应用：
1. Vue 前端部分：
   - 使用 Vue CLI 构建工具进行项目构建，可以通过配置 webpack 来进行静态资源的合并、压缩和打包。
   - 利用 Vue Router 进行页面的预加载和预渲染，以提高用户访问时的加载速度。
2. Java Web 后端部分：
   - 在 Java Web 应用中，可以通过设置合理的缓存策略，让浏览器能够缓存静态资源，减少重复下载。
   - 合理设置 HTTP 响应头，启用 Gzip 压缩，以减小静态资源的文件大小，提高传输速度。
3. Nginx 服务器部分：
   - 使用 Nginx 作为反向代理服务器，将静态资源（如 JavaScript、CSS、图片等）的请求直接由 Nginx 处理，减轻 Java Web 服务器的负担。
   - 在 Nginx 中配置合理的缓存策略，将静态资源缓存到本地，减少对后端服务器的请求，提高访问速度。
   - 使用 Nginx 的 Gzip 压缩功能，对静态资源进行压缩，减小文件大小，提高传输速度。
总的来说，静态资源前置思想在 Vue + Java Web + Nginx 架构中的设计应用主要包括前端构建优化、合理设置后端缓存策略、Nginx 作为反向代理服务器处理静态资源请求，以及利用 Nginx 的缓存和压缩功能来提高静态资源的加载速度和用户体验。这样的设计能够有效地提高网页的性能和响应速度。

增加mvc配置类，处理资源无法加载的问题

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 添加处理器
     * 未加该处理器时使用此链接请求资源localhost:10000/index/js/swiper-3.4.2.jquery.min.js
     * 添加处理器后使用此链接请求资源localhost:10000/static/index/js/swiper-3.4.2.jquery.min.js
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
    }
}
```

## nginx 丢失 host 信息

nginx反向代理时会丢失host信息，配置server块，转发时同时转发hosts
    server {
        listen 80;
        server_name gulimall.com;

        location / {
        	proxy_set_header Host $host;
            proxy_pass gulimall;
        }
    }

## 缓存

采用 redis 作为数据缓存

在查询缓存未命中时，大量查询打到DB导致DB宕机：采用redis分布式锁进行加锁处理
一直查询某个不存在的key时，缓存一直未命中，大量请求打到DB导致DB宕机：将查询到的null值也作为缓存缓存起来
在同一时间内大量缓存到期，大量请求打到DB导致DB宕机：设置缓存到期时间尽量分散

## 缓存和 DB 数据一直性问题

缓存和数据库（DB）数据一致性是一个常见的挑战，特别是在高并发和分布式系统中。以下是解决这一问题的一些常见方案：
1. 读写分离：
   - 将数据库的读和写操作分离到不同的实例上，读操作可以通过缓存层处理，而写操作则直接写入数据库。这样可以避免缓存和数据库数据不一致的问题。
2. 缓存更新策略：
   - 当数据库数据发生变化时，及时更新缓存中的数据。可以通过在数据变更时主动更新缓存，或者使用失效策略（例如设置缓存数据的过期时间），在缓存数据过期时重新从数据库中获取最新数据。（适用于对于数据实时性要求不高的情况，可保证数据的最终一致性）
3. 事务性缓存操作：
   - 在需要保证缓存和数据库数据一致性的操作中，可以使用事务性缓存操作，即在更新数据库的同时，更新缓存。这通常需要使用分布式事务管理或者缓存与数据库的双写机制来保证操作的原子性。
4. 缓存降级策略：
   - 当缓存数据无法及时更新或者失效时，可以通过降级策略直接从数据库中获取数据，以保证数据的一致性。
5. 数据变更通知：
   - 数据库数据发生变化时，可以通过发布订阅模式或者消息队列向缓存层发送数据变更通知，以触发缓存的更新操作。
6. 数据校验机制：
   - 在从缓存中获取数据时，可以通过校验数据的版本号或者时间戳来验证数据的一致性，确保缓存中的数据与数据库中的数据一致。
综合利用上述方案，可以有效地解决缓存和数据库数据一致性的问题，提高系统的性能和稳定性。然而，需要根据具体的业务场景和系统架构来选择合适的方案，并进行充分的测试和验证。

三种方案：
	1.仅加过期时间即可（首先考虑业务造成脏数据的概率，例如用户维度数据（订单数据、用户数据）并发几率很小，每过一段时间触发读的主动更新）
	2.canal订阅binlog的方式（菜单、商品介绍等基础数据）【完美解决】
	3.加读写锁
	4.实时性、一致性要求高的数据，应该直接查数据库
    
最终方案：
    1.所有数据加上过期时间
    2.读写数据加分布式读写锁（经常写的数据不要放在缓存里）

## 密码加密

采用国密加盐方式加密



## feign 远程调用丢失请求头问题

描述一个场景：cookie 丢失

当用户从浏览器发起请求时，浏览器已经携带了当前请求所需要的请求头信息，而当该服务调用其他服务的接口时，由于使用的是 feign ，请求中不会自动携带请求头信息，导致第三方服务认为当前用户没有权限或未登录，导致请求失败。




假设你正在开发一个电子商务平台，你的系统需要与第三方支付服务进行远程调用来处理用户的支付操作。你使用Feign来实现与第三方支付服务的交互。
在这个场景中，当用户下单并选择支付方式时，你的系统会调用第三方支付服务的API来发起支付请求。在这个过程中，你需要确保支付请求中包含了必要的认证信息和其他请求头，以便第三方支付服务能够正确处理请求。
通过使用Feign的`RequestInterceptor`，你可以在每次调用第三方支付服务的API时，自动地添加必要的请求头信息，比如认证信息、版本号、或者其他定制化的头部信息。这样，你的系统就能够顺利地与第三方支付服务进行通信，而不会出现请求头丢失的问题。


## 接口防重复提交

### 防重令牌

在接口提交数据时，一起提交一个防重复令牌