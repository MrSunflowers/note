# 基础

## 防抖与节流

在浏览器处理大量操作时，防抖（Debounce）和节流（Throttle）是两种常用的性能优化技术，它们主要用于控制高频率触发的事件，以避免过多的计算或操作影响性能。

**防抖（Debounce）**

防抖的核心思想是将多次执行变为最后一次执行。当持续触发某个事件时，只在事件停止触发后的指定时间内执行一次回调函数。防抖主要用于减少在短时间内重复触发的操作。

**实现原理**：
- 使用 `setTimeout` 来延迟执行回调函数。
- 每次触发事件时都重新设置计时器。
- 只有在指定时间内没有再次触发事件时，才会执行回调函数。

**应用场景**：
- 搜索框输入：在用户停止输入后再发送请求。
- 窗口大小调整：在用户停止调整窗口大小后再执行调整逻辑。
- 表单验证：在用户停止输入后进行验证。

**节流（Throttle）**

节流的核心思想是在一段时间内只允许一次执行。当持续触发某个事件时，在指定时间间隔内只执行一次回调函数。节流主要用于限制在一定时间内的执行次数。

**实现原理**：
- 通过 `setTimeout` 或时间戳来控制回调函数的执行频率。
- 使用时间戳实现：记录上一次执行回调函数的时间戳，只有当当前时间戳与上一次时间戳的差值大于指定间隔时，才执行回调函数。
- 使用 `setTimeout` 实现：设置一个定时器，在定时器执行回调函数后，只有在定时器结束后才能再次执行回调函数。

**应用场景**：
- 浏览器滚动条的滚动事件。
- 浏览器窗口调节的 `resize` 事件。
- 输入框内容校验以及在移动端的 `touchmove` 事件等。

防抖和节流都是前端开发中非常重要的性能优化技术。它们通过控制事件处理函数的调用频率，来减少不必要的计算和操作，从而提升应用的性能和用户体验。在实际开发中，根据不同的场景选择合适的防抖或节流策略，可以有效地优化应用的性能。

在JavaScript中，实现防抖（Debounce）和节流（Throttle）的工具通常可以通过自定义函数来完成，也可以使用一些流行的库，如Lodash，来简化实现。下面分别介绍如何使用原生JavaScript和Lodash来实现这两种技术。

### 使用原生JavaScript实现

#### 防抖（Debounce）

```javascript
function debounce(func, wait) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            func.apply(context, args);
        }, wait);
    };
}
```

使用示例：

```javascript
const handleScroll = () => console.log('滚动事件触发');
const debouncedScroll = debounce(handleScroll, 1000);

window.addEventListener('scroll', debouncedScroll);
```

#### 节流（Throttle）

```javascript
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}
```

使用示例：

```javascript
const handleResize = () => console.log('窗口大小调整');
const throttledResize = throttle(handleResize, 250);

window.addEventListener('resize', throttledResize);
```

### 使用Lodash实现

Lodash是一个广泛使用的JavaScript工具库，它提供了现成的防抖和节流函数，使用起来非常方便。

#### 防抖（Debounce）

```javascript
import _ from 'lodash';

const handleScroll = () => console.log('滚动事件触发');
const debouncedScroll = _.debounce(handleScroll, 1000);

window.addEventListener('scroll', debouncedScroll);
```

#### 节流（Throttle）

```javascript
import _ from 'lodash';

const handleResize = () => console.log('窗口大小调整');
const throttledResize = _.throttle(handleResize, 250);

window.addEventListener('resize', throttledResize);
```

使用Lodash可以简化代码，特别是当项目中已经包含了Lodash库时，可以很方便地引入和使用这些功能。不过，如果项目较小，或者对性能有特别要求，也可以选择使用原生JavaScript实现这些功能。

## 事件委派模型

当三级目录或者树形结构，要实现点击树中结点，跳转至另一个页面，那么一般来说可以有以下阆中解决方案

- 将每个节点都作为 router-link 来实现跳转
- 将每个节点都绑定一个点击事件，触发编程式导航方法实现跳转‘

这两种方案都有一个问题，即使用 router-link 来实现跳转会创建大量 router-link 组件，导致页面卡顿，而给每个元素都绑定点击事件又会有几千个点击事件。也会卡顿，此时就可以用到事件委派模型

**事件委派的工作原理**

事件委派利用了事件冒泡的原理。当一个事件在DOM树中发生时，它会从触发事件的元素开始，逐级向上冒泡到根节点。在父元素上设置一个事件监听器，可以捕获所有子元素上的事件，然后根据事件的目标元素来决定如何处理。

**实现事件委派**

在Vue中，你可以通过在父组件上绑定一个点击事件来实现事件委派。然后，根据事件的目标元素（`event.target`）来判断点击的是哪个子节点，并执行相应的跳转逻辑。

以下是一个简单的示例：

```vue
<template>
  <div class="tree-container" @click="handleClick">
    <div class="node" v-for="node in nodes" :key="node.id">
      {{ node.name }}
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      nodes: [
        { id: 1, name: 'Node 1' },
        { id: 2, name: 'Node 2' },
        // 更多节点...
      ]
    };
  },
  methods: {
    handleClick(event) {
      const target = event.target;
      // 假设每个节点都有一个唯一的id属性
      const nodeId = target.dataset.id;
      if (nodeId) {
        // 根据id进行路由跳转或其他逻辑处理
        this.$router.push(`/node/${nodeId}`);
      }
    }
  }
};
</script>

<style>
.tree-container {
  /* 样式定义 */
}
.node {
  /* 样式定义 */
}
</style>
```

在这个例子中，我们在父容器`.tree-container`上绑定了点击事件。当点击事件发生时，`handleClick`方法会被调用。通过检查`event.target`，我们可以确定哪个具体的节点被点击，并据此执行相应的操作。

**优势**

- **性能提升**：通过减少事件监听器的数量，可以显著提高性能，特别是在处理大量节点时。
- **灵活性**：事件委派使得事件处理逻辑更加集中，易于管理和修改。

**注意事项**

- 确保事件处理逻辑正确区分不同子元素的点击事件。
- 在处理复杂的DOM结构时，可能需要额外的逻辑来准确获取被点击的元素。

通过使用事件委派，你可以有效地管理大量节点的事件处理，同时保持应用的性能和响应速度。














